<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aYuのblog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-04T15:43:24.287Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>aYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC五种连接方式</title>
    <link href="http://example.com/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-04T15:11:56.000Z</published>
    <updated>2021-10-04T15:43:24.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC原理图"><a href="#JDBC原理图" class="headerlink" title="JDBC原理图"></a>JDBC原理图</h2><p><img src="/img/jdbc.png" alt="jdbc"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在项目目录下创建libs文件夹,将连接用的jar包导入</p><p><img src="/img/10-4-1.png" alt="10-4-1"></p></li><li><p>把导入的jar包加入到项目中,右键点击jar包</p><p><img src="/img/10-4-2.png" alt="10-4-2"></p></li></ol><h2 id="五种连接方式"><a href="#五种连接方式" class="headerlink" title="五种连接方式"></a>五种连接方式</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>该方式代码中显式出现了第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用反射实例化Driver,不在代码中体现第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用反射加载Driver类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用DriverManager代替Driver进行统一管理,实现数据库的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用DriverManager替代Driver进行统一管理</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><p>不必显式的注册驱动了,因为在DriverManager的源码中已经存在静态代码块,实现了驱动的注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用Class.forName自动完成注册驱动</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式五-推荐"><a href="#方式五-推荐" class="headerlink" title="方式五(推荐)"></a>方式五(推荐)</h3><p>使用配置文件的方式保存配置信息,在代码中加载配置文件<br>使用配置文件的好处:</p><ol><li>实现了代码和数据的分离,如果需要修改配置信息,直接在配置文件中修改,不需要深入代码</li><li>如果修改了配置信息,省去重新编译的过程</li></ol><p>使用方法:</p><p>​    在src目录下创建jdbc.properties文件,添加以下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四个基本要素(记得修改成自己的配置信息)</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/ayu_db2</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关值</span></span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDBC原理图&quot;&gt;&lt;a href=&quot;#JDBC原理图&quot; class=&quot;headerlink&quot; title=&quot;JDBC原理图&quot;&gt;&lt;/a&gt;JDBC原理图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/jdbc.png&quot; alt=&quot;jdbc&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准</summary>
      
    
    
    
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建博客并部署到云服务器</title>
    <link href="http://example.com/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-10-01T09:44:31.000Z</published>
    <updated>2021-10-04T13:19:14.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做基本不会出错,话不多说,下面开始</p><h2 id="本地部署Hexo"><a href="#本地部署Hexo" class="headerlink" title="本地部署Hexo"></a>本地部署Hexo</h2><h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h3><p>nodejs: <a href="https://nodejs.org/zh-cn/">下载</a></p><p>git: <a href="https://git-scm.com/downloads">下载</a></p><h3 id="二-安装本地hexo环境"><a href="#二-安装本地hexo环境" class="headerlink" title="二.安装本地hexo环境"></a>二.安装本地hexo环境</h3><p>nodejs和git的安装只需要无脑下一步即可,安装完成后可以在dos窗口进行检验,输入命令<code>node -v</code>和<code>npm -v</code>查看版本信息</p><p><img src="/img/10-1-1.png" alt="10-1-1"></p><h3 id="三-安装hexo框架"><a href="#三-安装hexo框架" class="headerlink" title="三.安装hexo框架"></a>三.安装hexo框架</h3><p>在非系统盘下新建一个blog文件夹,进入文件夹后右键Git Bash Here</p><p>输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//第一条   这是安装hexo的基础框架</span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">//第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">//第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">//第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">//第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>安装完成之后可以去浏览器输入localhost:4000进行查看,效果如下:</p><p><img src="/img/10-1-2.png" alt="img"></p><h2 id="将Hexo博客部署到服务器上"><a href="#将Hexo博客部署到服务器上" class="headerlink" title="将Hexo博客部署到服务器上"></a>将Hexo博客部署到服务器上</h2><h3 id="一-服务器和域名的购买"><a href="#一-服务器和域名的购买" class="headerlink" title="一.服务器和域名的购买"></a>一.服务器和域名的购买</h3><ul><li>云服务器可以选择阿里云,腾讯云,华为云,这里演示使用的是阿里云的学生机</li><li>域名建议服务器在哪个平台就在哪个平台购买,域名买完一定要第一时间备案,国内的服务器是必须要备案的,如果是香港和外国的服务器则可以不用备案</li></ul><h3 id="二-云服务器操作-阿里云为例"><a href="#二-云服务器操作-阿里云为例" class="headerlink" title="二.云服务器操作(阿里云为例)"></a>二.云服务器操作(阿里云为例)</h3><h4 id="配置安全组规则"><a href="#配置安全组规则" class="headerlink" title="配置安全组规则"></a>配置安全组规则</h4><p>阿里云默认是不授权80端口访问的,这个端口,这个端口跑的是网页服务器的访问,所以要先把它开启,否则后面配置好后也无法访问</p><p>登录控制台-&gt;云服务器ECS-&gt;安全组-&gt;安全组ID-&gt;手动添加</p><p><img src="/img/10-1-3.png" alt="10-1-3"></p><h4 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h4><h5 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h5><p>远程链接云服务器后,我们需要安装搭载网站的服务器nginx,安装命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx 安装nginx</span><br><span class="line"></span><br><span class="line">systemctl start nginx 开启nginx服务</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx 跟随系统启动</span><br></pre></td></tr></table></figure><p>安装完成之后,使用公网ip访问,如果显示的是nginx或者是centos的欢迎界面的话就代表安装成功</p><h5 id="创建博客目录"><a href="#创建博客目录" class="headerlink" title="创建博客目录"></a>创建博客目录</h5><p><code>cd /home</code></p><p><code>mkdir www</code></p><p><code>cd www</code></p><p><code>mkdir website</code></p><p>我么们在本地上传的blog文件都会存放在这个文件夹中</p><p>回到home目录修改权限</p><p><code>cd /home</code></p><p><code>chmod -R 777 ./www</code></p><p><code>chmod -R 777 ./www/website</code></p><h5 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h5><p>这里先写好配置文件,然后使用include的方式,引入到nginx的配置文件中</p><p>在/etc/nginx/的目录下创建vhost文件夹,在vhost文件夹下编写配置文件</p><p><code>cd /etc/nginx/</code></p><p><code>mkdir vhost</code></p><p><code>cd vhost</code></p><p><code>vim blog.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen    80;</span><br><span class="line">root /home/www/website;</span><br><span class="line">server_name ;这里填你的域名</span><br><span class="line">location /&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps:注释文字要删掉</span><br></pre></td></tr></table></figure><p>然后把这个文件引入到nginx的配置文件中,并修改server中的一些值</p><p><code>vim /etc/nginx/nginx.conf</code></p><p><img src="/img/10-1-4.png" alt="10-1-4"></p><p><img src="/img/10-1-5.png" alt="10-1-5"></p><h3 id="三-安装Git和node-js"><a href="#三-安装Git和node-js" class="headerlink" title="三.安装Git和node.js"></a>三.安装Git和node.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//安装Git</span><br><span class="line">yum install git</span><br><span class="line"></span><br><span class="line">// 安装Node</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><p>新建一个git用户并修改权限</p><p><code>adduser git</code></p><p><code>chmod 740 /etc/sudoers</code></p><p><code>vim /etc/sudoers</code></p><p>修改配置文件,如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line"></span><br><span class="line">添加以下内容</span><br><span class="line"></span><br><span class="line">git ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>再将权限修改过来</p><p><code>chmod 400 /etc/sudoers</code></p><h4 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h4><p>在本机桌面,右键GIt Bash Here打开终端,执行如下命令(三次回车)</p><p><code>ssh-keygen -t rsa</code></p><p>在C:\Users\用户名.ssh中找到id_rsa.pub</p><p>回到服务器端执行如下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git  //设置git密码</span><br><span class="line">su git//切换到git用户</span><br><span class="line"><span class="built_in">cd</span> ~//切换目录</span><br><span class="line">mkdir .ssh//新建.ssh文件夹</span><br><span class="line"><span class="built_in">cd</span> .ssh//进入文件夹</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys</span></span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>在本地Git终端测试连接云服务器</p><p><code>ssh -v git@你的公网IP</code></p><p>如果不需要输入密码就可以连接说明配置成功了,如果配置失败也不是什么大问题,只不过以后每次git需要输入密码</p><h3 id="四-创建git仓库"><a href="#四-创建git仓库" class="headerlink" title="四.创建git仓库"></a>四.创建git仓库</h3><p>在服务器端 创建git仓库</p><p><code>cd ~</code></p><p><code>git init --bare blog.git</code></p><p><code>vi ~/blog.git/hooks/post-receive</code></p><p>添加下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>修改权限</p><p><code>chmod +x ~/blog.git/hooks/post-receive</code></p><h3 id="五-完成部署"><a href="#五-完成部署" class="headerlink" title="五.完成部署"></a>五.完成部署</h3><p>修改hexo的配置文件,就是blog文件夹下的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@你的服务器公网IP:/home/git/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> </span><br></pre></td></tr></table></figure><p>之后在git终端执行</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>最后重新运行nginx服务器即可(ps:每次hexo d后都要重启nginx服务器)</p><p><code>nginx -s reload</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/09/04/hello-world/"/>
    <id>http://example.com/2021/09/04/hello-world/</id>
    <published>2021-09-04T09:07:46.000Z</published>
    <updated>2021-09-04T11:55:39.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的小破站"><a href="#欢迎来到我的小破站" class="headerlink" title="欢迎来到我的小破站"></a>欢迎来到我的小破站</h2><p>​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过wordpress，halo这些框架，和这些比起来hexo的配置好像更加麻烦，但也更加灵活，而且作为一款静态博客框架，安全性也是更高．</p><h2 id="这个站会发布什么内容"><a href="#这个站会发布什么内容" class="headerlink" title="这个站会发布什么内容"></a>这个站会发布什么内容</h2><p>​        主要是记录我个人的成长，分享一下code方面的经验，或者是一些趣事，anyway，关注一下总是不亏的．</p><h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a>自言自语</h2><p>​        搭建一个属于自己的网站一直是我的一个小心愿，这里可以是我的日记本，也可以是我的树洞，更可以是分享自己的一个平台，在各种短视频文化冲击的现代，如此浮躁的网络，能有一片属于自己的净土还是蛮不错的．</p><p>​        I’m OK！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;欢迎来到我的小破站&quot;&gt;&lt;a href=&quot;#欢迎来到我的小破站&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的小破站&quot;&gt;&lt;/a&gt;欢迎来到我的小破站&lt;/h2&gt;&lt;p&gt;​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过</summary>
      
    
    
    
    
    <category term="日志" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java SE基础面试题</title>
    <link href="http://example.com/2021/08/30/Java-SE%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2021/08/30/Java-SE%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-08-29T16:22:18.000Z</published>
    <updated>2021-09-04T13:22:11.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-面试题"><a href="#Java-SE-面试题" class="headerlink" title="Java SE 面试题"></a>Java SE 面试题</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#jump1">Java跨平台原理</a></li><li><a href="#jump2">写出JDK,JRE,JVM全称以及它们作用与关系</a></li><li><a href="#jump3">JDK三个环境变量的设置</a></li><li><a href="#jump4">Java缺点有什么(相对C++比较),产生这些缺点的原因</a></li><li><a href="#jump5">Java的三个分支以及他们的全称</a></li><li><a href="#jump6">JavaME 与android的关系</a></li><li><a href="#jump7">冒泡算法代码实现</a></li><li><a href="#jump8">二分查找代码实现</a></li><li><a href="#jump9">递归算法计算阶乘</a></li><li><a href="#jump10">构造方法 定义 特点 分类</a></li><li><a href="#jump11">static关键字</a></li><li><a href="#jump12">final关键字</a></li><li><a href="#jump13">JVM是如何管理内存的</a></li><li><a href="#jump14">Java有没有指针</a></li><li><a href="#jump15">Java数据类型有几种，它们的区别</a></li><li><a href="#jump16">int与Integer的区别</a></li><li><a href="#jump17">Java是方法参数的传递类型</a></li><li><a href="#jump19">String比较用什么方法，==与equals的区别</a></li><li><a href="#jump20">String与StringBuffer的区别</a></li><li><a href="#jump21">StringBuilder与StringBuffer的区别</a></li><li><a href="#jump22">日期处理</a></li><li><a href="#jump23">Java中有没有析构函数</a></li><li><a href="#jump24">什么是异常？异常处理的目的</a></li><li><a href="#jump25">异常的分类</a></li><li><a href="#jump27">异常处理有哪些关键字，它们的含义</a></li><li><a href="#jump29">Java中 final， finally， finalize的含义</a></li><li><a href="#jump30">Java中集合框架体系结构</a></li><li><a href="#jump31">Collection与Map的区别</a></li><li><a href="#jump32">List与Set的区别</a></li><li><a href="#jump33">ArrayList与Vector，LinkedList的区别</a></li><li><a href="#jump34">HashMap与Hashtable 的区别</a></li><li><a href="#jump35">得到Hashtable中所有的Value有哪些方法</a></li><li><a href="#jump36">如何对集合内的元素进行排序</a></li><li><a href="#jump37">Collection与Collections 的区别</a></li></ol><h2 id="面试题答案"><a href="#面试题答案" class="headerlink" title="面试题答案"></a>面试题答案</h2><h4 id="1-Java跨平台原理"><a href="#1-Java跨平台原理" class="headerlink" title="1. Java跨平台原理"></a><span id="jump1">1. Java跨平台原理</span></h4><p>Java语言最大的特点就是可以跨平台。Java之所以能够跨平台是因为Java源程序经过编译之后生成不是与平台绑定的可执行文件，而是中间字节码class文件。这些class文件是与平台无关的，它们不能直接运行，需要java虚拟机（JVM）加载它们，二次编译解释执行。</p><h4 id="2-写出JDK-JRE-JVM全称以及它们作用与关系"><a href="#2-写出JDK-JRE-JVM全称以及它们作用与关系" class="headerlink" title="2. 写出JDK,JRE,JVM全称以及它们作用与关系"></a><span id="jump2">2. 写出JDK,JRE,JVM全称以及它们作用与关系</span></h4><ul><li>JDK Java Development Kit Java开发工具包，JDK中包含Java编译器，Java运行时环境，以及其他组件，程序员使用</li><li>JRE Java Runtime Environment Java运行时环境，JRE 中包含JVM与Java运行支持类库</li><li>JVM Java Virtual Machine Java虚拟机，JVM是Java虚拟机，每种平台的Java虚拟机不同</li><li>关系：JDK包含JRE,JRE包含JVM</li></ul><h4 id="3-JDK三个环境变量的设置"><a href="#3-JDK三个环境变量的设置" class="headerlink" title="3. JDK三个环境变量的设置"></a><span id="jump3">3. JDK三个环境变量的设置</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java_home  JDK根文件夹</span><br><span class="line">classPath  .; %java_home%\lib</span><br><span class="line">path  %java_home%\bin</span><br></pre></td></tr></table></figure><h4 id="4-Java缺点有什么-相对C-比较-产生这些缺点的原因"><a href="#4-Java缺点有什么-相对C-比较-产生这些缺点的原因" class="headerlink" title="4. Java缺点有什么(相对C++比较),产生这些缺点的原因"></a><span id="jump4">4. Java缺点有什么(相对C++比较),产生这些缺点的原因</span></h4><p>运行速度慢，占用资源多。</p><p>原因：</p><ol><li>C++程序是二进制可执行文件，能够直接运行。Java是中间字节码，不能直接运行，他需要JVM加载解析运行</li><li>JVM也是个程序，JVM会占用资源</li><li>相比较C++，Java中无指针，不能直接操作内存</li><li>虽然Java内存不需要手工释放比较方便，但垃圾回收车不能实时收集内存</li></ol><h4 id="5-Java的三个分支以及它们的全称"><a href="#5-Java的三个分支以及它们的全称" class="headerlink" title="5. Java的三个分支以及它们的全称"></a><span id="jump5">5. Java的三个分支以及它们的全称</span></h4><ul><li><p>JavaSE   Java Standard Edition</p></li><li><p>JavaEE  Java Enterprise Edition</p></li><li><p>JavaME  Java Mobile Edition</p></li></ul><h4 id="6-JavaME-与android的关系"><a href="#6-JavaME-与android的关系" class="headerlink" title="6. JavaME 与android的关系"></a><span id="jump6">6. JavaME 与android的关系</span></h4><p>JavaME是Java的移动版，使用JavaME开发的程序要在各移动平台运行，必须安装对应平台的Java虚拟机，如Nokia的塞班系统运行JavaME需要安装对应JVM。</p><p>Android使用Java开发的手机操作系统，可以直接运行Java。</p><p>JavaME与Android的类库API不同。</p><h4 id="7-冒泡算法代码实现"><a href="#7-冒泡算法代码实现" class="headerlink" title="7. 冒泡算法代码实现"></a><span id="jump7">7. 冒泡算法代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = nums[j];</span><br><span class="line">nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-二分查找代码实现"><a href="#8-二分查找代码实现" class="headerlink" title="8. 二分查找代码实现"></a><span id="jump8">8. 二分查找代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">13</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">167</span>, <span class="number">209</span>, <span class="number">789</span>, <span class="number">999</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> guess = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">index = (begin + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (guess == nums[index]) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了，位置在:&quot;</span> + index);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(guess &lt; nums[index]) &#123;</span><br><span class="line">end = index - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(guess &gt; nums[index]) &#123;</span><br><span class="line">begin = index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(begin &lt;= end);</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">System.out.println(guess + <span class="string">&quot;在数组内不存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-递归算法计算阶乘"><a href="#9-递归算法计算阶乘" class="headerlink" title="9. 递归算法计算阶乘"></a><span id="jump9">9. 递归算法计算阶乘</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">cheng</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * cheng(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">long</span> result = test.cheng(<span class="number">4</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-构造方法-定义-特点-分类"><a href="#10-构造方法-定义-特点-分类" class="headerlink" title="10. 构造方法 定义 特点 分类"></a><span id="jump10">10. 构造方法 定义 特点 分类</span></h4><p>特点：</p><ol><li>方法名与类名相同（普通方法首字母小写，构造方法因为与类名相同，大写）</li><li>没有返回值（连void关键字也没有）</li><li>在创建对象时（new）由系统JVM自动调用</li></ol><p>分类：</p><ul><li>显式构造方法：由程序员添加，根据参数的个数与类型不同可以有多个</li><li>隐式构造方法：当类中没有显式构造方法时，在类由.java源文件编译为.class类文件时由系统Java编译器自动添加一个没有参数的构造方法</li></ul><h4 id="11-static关键字"><a href="#11-static关键字" class="headerlink" title="11. static关键字"></a><span id="jump11">11. static关键字</span></h4><p>static表示静态的，唯一的</p><ul><li><p>修饰变量：表示静态变量，通过类名.变量名访问，普通变量通过对象名.变量名访问。内存空间在方法区内，整个类只有一份。普通变量在堆内，一个对象一份</p></li><li><p>修饰方法：表示静态方法，通过类名.方法名名访问，普通方法通过对象名.方法名访问。静态的只能访问静态，静态方法中只能访问静态变量与其它静态方法，不同访问普通方法</p></li><li><p>静态块：当JVM加载完类，如果这个类中有静态块，马上执行其中代码</p></li></ul><h4 id="12-final关键字"><a href="#12-final关键字" class="headerlink" title="12. final关键字"></a><span id="jump12">12. final关键字</span></h4><p>final表示最终的，不变的</p><ul><li><p>修饰类：类不能被继承。Java String,八个包装类全部是final类</p></li><li><p>修饰方法：表示方法不能被重写</p></li><li><p>修饰变量：表示数值不能被改变，常量，常量必须赋初值，当把一个变量修饰为final，一般还会把它修饰为static，常量字母全部大写</p></li></ul><h4 id="13-JVM是如何管理内存的"><a href="#13-JVM是如何管理内存的" class="headerlink" title="13. JVM是如何管理内存的"></a><span id="jump13">13. JVM是如何管理内存的</span></h4><p>JVM向系统申请的内存从逻辑上分为很多个区域，比较重要的有三个：堆，栈，方法区</p><ul><li><p>栈：对于基本型，存储的是具体的数值，对于引用型，存储的是堆中内存首地址</p></li><li><p>堆：存储对象数据，有几个对象，堆中就有几份内存</p></li><li><p>方法区：存储类结构，包括所有方法，还有静态变量的数值也存储在方法区中，只有一份</p></li></ul><h4 id="14-Java有没有指针"><a href="#14-Java有没有指针" class="headerlink" title="14. Java有没有指针"></a><span id="jump14">14. Java有没有指针</span></h4><p>Java中没有指针，因为Java不能声明指针类型的变量。但是Java底层封装了指针，但是也不是所有数据类型都封装了指针，根据是否封装指针，java数据类型分为两种，值类型与引用类型</p><ul><li><p>值类型又称为基本数据类型，就是没有封装指针的，在Java中只有八个，使用值类型变量，只在栈中有一块内存</p></li><li><p>引用数据类型是封装指针的，包括类，抽象类，接口与数组。使用引用类型变量在栈与堆中各一块</p></li></ul><h4 id="15-Java数据类型有几种，它们的区别"><a href="#15-Java数据类型有几种，它们的区别" class="headerlink" title="15. Java数据类型有几种，它们的区别"></a><span id="jump15">15. Java数据类型有几种，它们的区别</span></h4><p>基本型和引用型</p><ul><li><p>基本型：使用基本型变量，只在栈中有一块内存，数值存储在栈中</p></li><li><p>引用型：使用引用型变量，栈与堆中各一块内存，栈中并不存储具体的数值，存储的是堆中内存地址的引用，具体的数值存储在堆中</p></li></ul><h4 id="16-int与Integer的区别"><a href="#16-int与Integer的区别" class="headerlink" title="16. int与Integer的区别"></a><span id="jump16">16. int与Integer的区别</span></h4><ol><li>Integer是int的包装类，int则是java的一种基本数据类型 </li><li>Integer变量必须实例化后才能使用，而int变量不需要 </li><li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </li><li>Integer的默认值是null，int的默认值是0</li></ol><h4 id="17-Java方法参数的传递类型"><a href="#17-Java方法参数的传递类型" class="headerlink" title="17. Java方法参数的传递类型"></a><span id="jump17">17. Java方法参数的传递类型</span></h4><p>类中有方法，方法有参数列表，参数根据传递的方式，有两种：值传递与引用传递。对于Java而言，又有两种说法：</p><ul><li>第一种：基本数据类型（值类型）是按值传递的，引用数据类型是按引用传递的。这种说法的依据是：方法调用完,是否会改变参数的原始数值（基本型不会改变，引用型会改变）</li><li>第二种：所有数据类型都是按值传递的，因为不管是基本型还是引用型，方法调用时都是把栈中的数据拷贝了一份（拷贝栈值），只不过基本型拷贝的是具体的数值，而引用型拷贝的是内存首地址</li></ul><h4 id="18-String比较用什么方法，-与equals的区别"><a href="#18-String比较用什么方法，-与equals的区别" class="headerlink" title="18. String比较用什么方法，== 与equals的区别"></a><span id="jump19">18. String比较用什么方法，== 与equals的区别</span></h4><p>String类是定长的。字符串每改变一次数值，都会分配新的内存。为了节省内存，Java中引出字符串池。</p><p>String的赋值有两种方式，new String(“haha”)与直接赋值。直接赋值首先会去字符串池中寻找，如果找到，直接使用; 如果没找到，创建一块新的使用。new方式定义字符串，不会寻找，直接在堆中创建使用。</p><ul><li><p>== 比较的是栈值，是否指向同一块内存。</p></li><li><p>equals比较的是指向的两块内存存储的数值是否相等。== 为true,equals一定为true；equals为true，== 不一定为true。</p></li></ul><h4 id="19-String与StringBuffer的区别"><a href="#19-String与StringBuffer的区别" class="headerlink" title="19. String与StringBuffer的区别"></a><span id="jump20">19. String与StringBuffer的区别</span></h4><ul><li>String而是一个类，它被用来表示字符序列，其字符本身符合Unicode标准，初始化方式有两种</li><li>StringBuffer是-个具有对象引用传递特点的字符串对象，可以调用其方法动态的进行增加、插入、修改和删<br>除操作，不用像数组那样事先指定大小，从而实现多次插入字符,一次整体取出的效果，因而操作字符串非<br>常灵活方便。</li></ul><h4 id="20-StringBuilder与StringBuffer的区别"><a href="#20-StringBuilder与StringBuffer的区别" class="headerlink" title="20. StringBuilder与StringBuffer的区别"></a><span id="jump21">20. StringBuilder与StringBuffer的区别</span></h4><ol><li><p>线程安全：</p><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰</p></li><li><p>缓冲区：</p><p>StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p><p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串</p></li><li><p>性能：</p><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer</p></li></ol><h4 id="21-日期处理"><a href="#21-日期处理" class="headerlink" title="21. 日期处理"></a><span id="jump22">21. 日期处理</span></h4><p>三个类：Date DateFormat Calendar</p><p>三个需求：</p><ul><li><p>Date→String String→Date Date操作</p></li><li><p>Date→String ： String str = df.format()</p></li><li><p>String→Date : Date date = df.parse(); throws 编译时异常 ParseException</p></li></ul><h4 id="22-Java中有没有析构函数"><a href="#22-Java中有没有析构函数" class="headerlink" title="22. Java中有没有析构函数"></a><span id="jump23">22. Java中有没有析构函数</span></h4><p>Java中没有析构函数，但是Object提供了finalize方法，完成了类似析构函数的功能，它也是在对象消亡时由系统自动调用。Java与C++还有不同，因为Java是由垃圾回收车收集对象内存，虽然我们可以使用System.gc()建议垃圾回收线程运行，我们不知道具体它什么时候运行。但只要运行，一定会调用finalize方法。</p><h4 id="23-什么是异常-异常处理的目的"><a href="#23-什么是异常-异常处理的目的" class="headerlink" title="23. 什么是异常? 异常处理的目的"></a><span id="jump24">23. 什么是异常? 异常处理的目的</span></h4><p>程序在编译与运行时发生的错误称为异常。</p><p>目的：使程序能够编译成功和发生异常时能够继续运行。</p><h4 id="24-异常的分类"><a href="#24-异常的分类" class="headerlink" title="24. 异常的分类"></a><span id="jump25">24. 异常的分类</span></h4><p>大分类：</p><ul><li><p>Error 错误，无法处理，一般由虚拟机抛出。如内存溢出，线程错误。Error一般很难发生，但发生后程序就得终止重启。</p></li><li><p>Exception 异常，能处理，由程序抛出，我们说异常处理，指的就是Exception。</p></li></ul><p>小分类：</p><ul><li>编译时异常：必须处理，否则程序无法编译；编译时异常是由特定代码（特定方法）抛出的，只有调用了特定方法，才会抛出对应的编译时异常。</li><li>运行时异常：可以处理，也可以不处理。不处理程序也能编译通过。</li></ul><h4 id="25-异常处理有哪些关键字，它们的含义"><a href="#25-异常处理有哪些关键字，它们的含义" class="headerlink" title="25. 异常处理有哪些关键字，它们的含义"></a><span id="jump27">25. 异常处理有哪些关键字，它们的含义</span></h4><ul><li><p>try:try块内包含的是可能发生异常的业务逻辑代码，就是正常的程序代码。</p></li><li><p>catch：是异常处理的代码，一个try块后可以包含多个catch块，同等级的catch没有先后顺序，但子类catch块的一定要在父类catch块的前面。</p></li><li><p>finally：最后的收尾工作，不管有没有异常发生，finally块一定会执行，并且是最后执行。一般用来关闭资源。</p></li><li><p>throw：用在方法体内，表示此方法正在向外抛出异常。</p></li><li><p>throws：出现在方法声明的最后面，复数，可以有多个异常。表示调用此方法有可能抛出对应异常，调用方法的客户端需要处理。</p></li></ul><h4 id="26-Java中-final，-finally，-finalize的含义"><a href="#26-Java中-final，-finally，-finalize的含义" class="headerlink" title="26. Java中 final， finally， finalize的含义"></a><span id="jump29">26. Java中 final， finally， finalize的含义</span></h4><ul><li><p>final是Java的一个关键字，修饰符，它表示最终的，不变的，其中final修饰一个类，表示此类不能被继承，如Java中String类与八个包装类都是final类。final修饰一个方法，表示此方法不能被重写；修饰一个变量，表示为常量，当我们把一个变量修饰为final时，一般还会把它修饰为static，并且常量必须赋初值，而且所有字母为大写</p></li><li><p>finally是Java中异常处理的一个关键字。Finally常常进行最后的收尾工作，不管有没有异常发生，finally块一定会执行，并且是最后执行</p></li><li><p>finalize是Object提供的一个方法，Object类是Java中所有类的直接父类或者间接父类。Java中没有析构函数，但finalize方法提供类似析构函数的功能，当我们需要在对象消亡时做些事情，就可以把代码写入finalize方法中；但我们又不知道垃圾回收车什么时候收集对象内存，也就不知道finalize方法什么时候被调用，但我们知道，最后它一定会执行</p></li></ul><h4 id="27-Java中集合框架体系结构"><a href="#27-Java中集合框架体系结构" class="headerlink" title="27. Java中集合框架体系结构"></a><span id="jump30">27. Java中集合框架体系结构</span></h4><p><img src="http://39.105.29.254/2021/08/30/Java-SE%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg"></p><h4 id="28-Collection与Map的区别"><a href="#28-Collection与Map的区别" class="headerlink" title="28. Collection与Map的区别"></a><span id="jump31">28. Collection与Map的区别</span></h4><p>Collection与Map都是集合接口。Collection表示元素可以直接存放，Map不能直接存放，需要给每个元素一个别名，就是键值对，其中键不能重复，值可以重复。</p><p>Collection又分为两种，List与Set。List表示有序的，元素可以重复。Set表示无序的，元素不允许重复。</p><h4 id="29-List与Set的区别"><a href="#29-List与Set的区别" class="headerlink" title="29. List与Set的区别"></a><span id="jump32">29. List与Set的区别</span></h4><p>List与Set接口都是继承自Collection接口，List表示有序的，元素可以重复。Set表示无序的，元素不允许重复。</p><h4 id="30-ArrayList与Vector-LinkedList的区别"><a href="#30-ArrayList与Vector-LinkedList的区别" class="headerlink" title="30. ArrayList与Vector, LinkedList的区别"></a><span id="jump33">30. ArrayList与Vector, LinkedList的区别</span></h4><p>ArrayList,Vector与LinkedList都实现了List接口。ArrayList是线程非安全的，如果开发的是单线程程序，可以使用ArrayList。Vector是线程安全的，开发多线程程序，使用Vector。当我们需要对集合内的元素频繁的进行增删改操作时一般使用LinkedList。</p><h4 id="31-HashMap与Hashtable的区别"><a href="#31-HashMap与Hashtable的区别" class="headerlink" title="31. HashMap与Hashtable的区别"></a><span id="jump34">31. HashMap与Hashtable的区别</span></h4><ol><li><p>Hashtable是线程安全的，HashMap是线程非安全</p></li><li><p>HashMap允许用null作为key或者value, Hashtable不允许</p></li><li><p>循环遍历HashMap只有一组方法，而循环遍历Hashtable有两组方法</p></li></ol><h4 id="32-得到Hashtable中所有的Value有哪些方法"><a href="#32-得到Hashtable中所有的Value有哪些方法" class="headerlink" title="32. 得到Hashtable中所有的Value有哪些方法"></a><span id="jump35">32. 得到Hashtable中所有的Value有哪些方法</span></h4><p>Map接口提供了两个方法：</p><ol><li><p> keyset()得到所有键的集合（返回Set类型），通过每个键得到每个value</p></li><li><p>values()直接返回值的集合，返回的是Collection类型</p></li></ol><p>Hashtable额外提供了两个方法：</p><ol start="3"><li><p>keys()返回所有键的枚举（Enumeration）,通过键得到值</p></li><li><p>elements()直接返回值的Enumeration</p></li></ol><h4 id="33-如何对集合内的元素进行排序"><a href="#33-如何对集合内的元素进行排序" class="headerlink" title="33. 如何对集合内的元素进行排序"></a><span id="jump36">33. 如何对集合内的元素进行排序</span></h4><p>第一种方法：</p><ul><li><p>第一步：让实体类实现Comparable接口的compareTo方法</p></li><li><p>第二步: 调用Collections工具类的sort方法，一个参数</p></li><li><p>缺点：</p><ol><li>只能按照一种属性排序 </li><li>实体类功能臃肿，应该只存储数据</li></ol></li></ul><p>第二种方法：</p><ul><li><p>第一步：单独编写类实现Comparator接口的compare方法</p></li><li><p>第二步：调用Collections工具类的sort方法，两个参数</p></li><li><p>优点：在不同的业务需求下，可以按照多个属性排序</p></li></ul><h4 id="34-Collection与Collections的区别"><a href="#34-Collection与Collections的区别" class="headerlink" title="34. Collection与Collections的区别"></a><span id="jump37">34. Collection与Collections的区别</span></h4><ul><li><p>Collection是Java集合提供的一个顶层接口</p></li><li><p>Collections是集合提供的一个工具类，它有很多个静态方法，可以实现排序，找最大最小值等功能</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-SE-面试题&quot;&gt;&lt;a href=&quot;#Java-SE-面试题&quot; class=&quot;headerlink&quot; title=&quot;Java SE 面试题&quot;&gt;&lt;/a&gt;Java SE 面试题&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
