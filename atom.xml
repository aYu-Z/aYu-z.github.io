<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aYuのblog</title>
  
  
  <link href="http://www.ayu.link/atom.xml" rel="self"/>
  
  <link href="http://www.ayu.link/"/>
  <updated>2022-04-26T13:57:15.176Z</updated>
  <id>http://www.ayu.link/</id>
  
  <author>
    <name>aYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-04-26T13:34:00.000Z</published>
    <updated>2022-04-26T13:57:15.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>当一个对象被引用时, 该对象的引用值就加1, 当这个对象不再被引用时, 引用值就减1, 当引用值为0时, 就表示该对象可以被垃圾回收器回收。引用计数法有一个弊端, 那就是当两个对象相互引用的时, 两个对象的引用值都为1, 此时这两个对象就算用不到了, 也不会被回收。</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 </li><li>扫描堆中的对象, 看是否能够沿着 GC Root对象 为起点的引用链找到该对象, 找不到, 表示可以回收 </li><li>哪些对象可以作为 GC Root <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI (即一般说的Native方法)引用的对象</li></ul></li></ul><p>我们使用Eclipse Memory Analyzer(内存分析工具)对一下代码进行分析:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    list = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用jps命令找到程序进程</p><blockquote><p>PS D:\JVM\JVM_Study&gt; jps<br>14304 Jps<br>11060 Demo1<br>19532<br>26108 Launcher</p></blockquote></li><li><p>使用jmap命令生成内存快照</p><blockquote><p>PS D:\JVM\JVM_Study&gt; jmap -dump:format=b,live,file=1.bin 11060<br>Dumping heap to D:\JVM\JVM_Study\1.bin …<br>Heap dump file created</p></blockquote><p> 命令解释:</p><ul><li>dump: 转储文件</li><li>format=b: 使用二进制文件存储</li><li>live: 只抓取存活的对象, 并且抓取快照之前会进行垃圾回收</li><li>file=1.bin: 文件名</li><li>11060: 进程的id</li></ul></li><li><p>使用mat打开生成的快照, 选择GC Roots分析</p><p> <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/GC_Root.png" alt="GC_Root"></p></li></ol><p><code>list=null</code>前:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%89%8D.png" alt="null前"></p><p><code>list=null</code>后:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%90%8E.png" alt="null后"></p><p>可以看到, 在第一个快照中找到了ArrayList对象, 并且里面存储的对象也能找到, 第二个快照(也就是<code>list=null</code>后), ArrayList对象找不到了, 说明被回收了。</p><h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="引用类型"></p><ol><li>强引用 <ul><li>只有所有<strong>GC Roots</strong>对象都不通过【强引用】引用该对象, 该对象才能被垃圾回收 </li></ul></li><li>软引用(SoftReference)<ul><li>仅有软引用引用该对象时, 在垃圾回收后, 内存仍不足时会再次出发垃圾回收, 回收软引用对象 </li><li>可以配合引用队列来释放软引用自身 </li></ul></li><li>弱引用(WeakReference)<ul><li>仅有弱引用引用该对象时, 在垃圾回收时, 无论内存是否充足, 都会回收弱引用对象 </li><li>可以配合引用队列来释放弱引用自身 </li></ul></li><li>虚引用(PhantomReference)<ul><li>必须配合引用队列使用, 主要配合<strong>ByteBuffer</strong>使用, 被引用对象回收时, 会将虚引用入队</li><li>由<strong>Reference Handler</strong>线程调用虚引用相关方法(如unsafe.freememory)释放直接内存 </li></ul></li><li>终结器引用(FinalReference)<ul><li>无需手动编码, 但其内部配合引用队列使用, 在垃圾回收时, 终结器引用入队(被引用对象暂时没有被回收)</li><li>再由<strong>Finalizer</strong>线程通过终结器引用找到被引用对象并调用它的<strong>finalize</strong>方法, 第二次 GC 时才能回收被引用对象</li></ul></li></ol><p>软引用演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示软引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束: &quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强引用会直接因为内存不足报错:</p><blockquote><p>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p></blockquote><p>软引用分析:</p><blockquote><p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3</p><p>在第四次循环之前内存已经吃紧了, 所以触发了一次垃圾回收, 这是一次minor gc<br>[GC (Allocation Failure) [PSYoungGen: 1900K-&gt;488K(6144K)] 14188K-&gt;12996K(19968K), 0.0010493 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@1540e19d<br>4</p><p>第五次循环之前内存已经彻底不够用的, 而且此时一个minor gc也释放不了多少内存, 所以触发了一次full fc<br>[GC (Allocation Failure) –[PSYoungGen: 4696K-&gt;4696K(6144K)] 17204K-&gt;17220K(19968K), 0.0005897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4529K(6144K)] [ParOldGen: 12524K-&gt;12477K(13824K)] 17220K-&gt;17006K(19968K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0039704 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[GC (Allocation Failure) –[PSYoungGen: 4529K-&gt;4529K(6144K)] 17006K-&gt;17038K(19968K), 0.0006478 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Allocation Failure) [PSYoungGen: 4529K-&gt;0K(6144K)] [ParOldGen: 12509K-&gt;604K(8704K)] 17038K-&gt;604K(14848K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0052899 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@677327b6<br>5</p><p>可以看到这次full gc将前面的软引用的几个byte数组全部回收, 只留下最后一个byte数组<br>循环结束: 5<br>null<br>null<br>null<br>null<br>[B@677327b6<br>Heap<br>PSYoungGen      total 6144K, used 4263K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda9f70,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 8704K, used 604K [0x00000000fec00000, 0x00000000ff480000, 0x00000000ff980000)<br>object space 8704K, 6% used [0x00000000fec00000,0x00000000fec971a8,0x00000000ff480000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</p><p>Process finished with exit code 0</p></blockquote><p>上面的代码可以看到, 虽然软引用的对象已经被回收了, 但是软引用本身还没有被回收, 虽然软引用只占用很少的内存, 但是也不能留下它, 可以使用引用队列来清理软引用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示软引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列, 当软引用所关联的 byte[] 被回收时, 软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象, 并移除</span></span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3<br>[B@1540e19d<br>4<br>[B@677327b6</p><p>5</p><p>[B@677327b6</p><p>Process finished with exit code 0</p></blockquote><p>可以看到, 软引用本身也被回收了</p><p>弱引用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">        System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;488K(6144K)] 5632K-&gt;4760K(19968K), 0.0041741 secs] [Times: user=0.00 sys=0.03, real=0.02 secs]<br>[B@1b6d3586,<br>[B@1b6d3586,[B@4554617c,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,[B@1540e19d,</p><p>第五次循环前, 触发full gc, 回收弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4951K-&gt;0K(6144K)] [ParOldGen: 12464K-&gt;595K(13824K)] 17415K-&gt;595K(19968K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0052947 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,[B@677327b6,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,[B@6d6f6e28,</p><p>第九次循环前, 内存再次不够触发full gc, 最后只剩下一个弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4207K-&gt;0K(6144K)] [ParOldGen: 12911K-&gt;619K(13824K)] 17118K-&gt;619K(19968K), [Metaspace: 3224K-&gt;3224K(1056768K)], 0.0061594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,null,null,null,null,[B@135fbaa4,</p><p>===========================================<br>[B@135fbaa4,Heap<br>PSYoungGen      total 6144K, used 4247K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda5c78,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 13824K, used 619K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)<br>object space 13824K, 4% used [0x00000000fec00000,0x00000000fec9ae68,0x00000000ff980000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</p><p>Process finished with exit code 0</p></blockquote><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法(Mark Sweep):</p><ul><li>速度较快</li><li>会产生内存碎片</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法(Mark Compact)</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制(Copy)</p><ul><li>不会有内存碎片</li><li>需要占用两倍内存空间</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><ul><li>新创建的对象首先分配在<strong>eden</strong>区</li><li>新生代空间不足时, 触发<strong>minor gc</strong>, <strong>eden</strong>区和<strong>from</strong>区存活的对象使用 copy 复制到 to 中, 存活的对象年龄加一, 然后交换 from 和 to</li><li><strong>minor gc</strong> 会引发 <strong>stop the world</strong>(咋瓦鲁多), 暂停其他线程, 等垃圾回收结束后, 恢复用户线程运行</li><li>当幸存区对象的寿命超过阈值时, 会晋升到老年代, 默认最大的寿命是15(4bit)</li><li>当老年代空间不足时, 会先触发<strong>minor gc</strong>, 如果空间仍然不足, 那么就触发<strong>full gc</strong> , STW的时间更长</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="分代垃圾回收"></p><h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>Full GC前Minor GC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>相关概念:</p><ul><li>并行收集: 指多条垃圾收集线程并行工作, 但此时用户线程仍处于等待状态</li><li>并发收集: 指用户线程与垃圾收集线程同时工作(不一定是并行的可能会交替执行), 用户程序在继续运行, 而垃圾收集程序运行在另一个CPU上</li><li>吞吐量: 即CPU用于运行用户代码的时间与CPU总消耗时间的比值(吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )), 例如, 虚拟机共运行 100 分钟, 垃圾收集器花掉 1 分钟, 那么吞吐量就是 99% </li></ul><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul><li>单线程</li><li>堆内存较少, 适合个人电脑</li></ul><p><code>-XX:+UseSerialGC = Serial + SerialOld</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%B2%E8%A1%8C.png" alt="串行"></p><p><strong>安全点</strong>: 让其他线程都在这个点停下来, 以免垃圾回收时移动对象地址, 使得其他线程找不到被移动的对象<br>因为是串行的, 所以只有一个垃圾回收线程。且在该线程执行回收工作时, 其他线程进入阻塞状态。</p><p><strong>Serial 收集器</strong><br>Serial 收集器是最基本的、发展历史最悠久的收集器<br><strong>特点</strong>: 单线程、简单高效(与其他收集器的单线程相比), 采用复制算法。对于限定单个 CPU 的环境来说, Serial 收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时, 必须暂停其他所有的工作线程, 直到它结束(Stop The World)</p><p><strong>ParNew 收集器</strong><br>ParNew 收集器其实就是 Serial 收集器的多线程版本<br><strong>特点</strong>: 多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同, 在 CPU 非常多的环境中, 可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p><p><strong>Serial Old 收集器</strong><br>Serial Old 是 Serial 收集器的老年代版本<br><strong>特点</strong>: 同样是单线程收集器, 采用标记-整理算法</p><h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大, 多核CPU</li><li>让单位时间内, STW 的时间最短</li></ul><p><code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></p><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p><code>-XX:GCTimeRatio=ratio</code></p><p><code>-XX:MaxGCPauseMillis=ms</code></p><p><code>-XX:ParallelGCThreads=n</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png" alt="吞吐量优先"></p><p><strong>Parallel Scavenge 收集器</strong><br>与吞吐量关系密切, 故也称为吞吐量优先收集器<br><strong>特点</strong>: 属于新生代收集器也是采用复制算法的收集器(用到了新生代的幸存区), 又是并行的多线程收集器(与 ParNew 收集器类似)<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是: GC自适应调节策略(与 ParNew 收集器最重要的一个区别)</p><p>**GC自适应调节策略: **<br>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小(-Xmn)、Eden 与 Survivor 区的比例(-XX:SurvivorRation)、晋升老年代的对象年龄(-XX:PretenureSizeThreshold)等, 虚拟机会根据系统的运行状况收集性能监控信息, 动态设置这些参数以提供最优的停顿时间和最高的吞吐量, 这种调节方式称为 GC 的自适应调节策略。</p><p>Parallel Scavenge 收集器使用两个参数控制吞吐量: </p><ul><li><p>XX:MaxGCPauseMillis=ms 控制最大的垃圾收集停顿时间(默认200ms)</p></li><li><p>XX:GCTimeRatio=rario 直接设置吞吐量的大小(默认值为99, 但是不容易达到, 一般设置为19)</p></li></ul><p><strong>Parallel Old 收集器</strong><br>是 Parallel Scavenge 收集器的老年代版本<br><strong>特点</strong>: 多线程, 采用标记-整理算法(老年代没有幸存区)</p><h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul><li>多线程</li><li>堆内存较大, 多核CPU</li><li>尽可能让 STW 的单次时间最短</li></ul><p><code>-XX:+UseConcMarkSweepGC</code> ~ <code>-XX:+UseParNewGC</code> ~ <code>SerialOld</code><br><code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConcGCThreads=threads</code><br><code>-XX:CMSInitiatingOccupancyFraction=percent</code><br><code>-XX:+CMSScavengeBeforeRemark</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="响应时间优先"></p><p><strong>CMS 收集器</strong><br>Concurrent Mark Sweep, 一种以获取最短回收停顿时间为目标的老年代收集器<br><strong>特点</strong>: 基于标记-清除算法实现。并发收集, 低停顿, 但是会产生内存碎片<br><strong>应用场景</strong>: 适用于注重服务的响应速度, 希望系统停顿时间最短, 给用户带来更好的体验等场景下。如 web 程序、b/s 服务<br><strong>CMS 收集器的运行过程分为下列4步</strong>:<br><strong>初始标记</strong>: 标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。<br><strong>并发标记</strong>: 进行 GC Roots Tracing 的过程, 找出存活对象且用户线程可并发执行。<br><strong>重新标记</strong>: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题<br><strong>并发清除</strong>: 对标记的对象进行清除回收, 清除的过程中, 可能任然会有新的垃圾产生, 这些垃圾就叫浮动垃圾, 如果当用户需要存入一个很大的对象时, 新生代放不下去, 老年代由于浮动垃圾过多, 就会退化为 serial Old 收集器, 将老年代垃圾进行标记-整理, 当然这也是很耗费时间的！</p><p>CMS 收集器的内存回收过程是与用户线程一起并发执行的, 可以搭配 ParNew 收集器(多线程, 新生代, 复制算法)与 Serial Old 收集器(单线程, 老年代, 标记-整理算法)使用。</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>定义</strong>:  Garbage First</p><p><strong>适用场景</strong>: </p><ul><li>同时注重吞吐量和低延迟(响应时间), 默认暂停目标是200ms</li><li>超大堆内存(内存大的), 会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法, 两个区域之间是复制算法</li></ul><p><strong>相关参数</strong>:<br>JDK8 并不是默认开启的, 所需要参数开启<br><code>-XX:+UseG1GC</code><br><code>-XX:G1HeapRegionSize=size</code><br><code>-XX:MaxGCPauseMillis=time</code></p><h4 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h4><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="G1垃圾回收阶段"></p><p>Young Collection: 对新生代垃圾收集<br>Young Collection + Concurrent Mark: 如果老年代内存到达一定的阈值了, 新生代垃圾收集同时会执行一些并发的标记<br>Mixed Collection: 会对新生代 + 老年代 + 幸存区等进行混合收集, 然后收集结束, 会重新进入新生代收集</p><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p><strong>新生代存在 STW</strong>:<br>分代是按对象的生命周期划分, 分区则是将堆空间划分连续几个不同小区间, 每一个小区间独立回收, 可以控制一次回收多少个小区间, 方便控制 GC 产生的停顿时间！<br>E: 伊甸园, S: 幸存区, O: 老年代</p><p>![Young Collection](/img/垃圾回收/Young Collection.gif)</p><h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><ul><li><p>在 Young GC 时会进行 GC Root 的初始标记 </p></li><li><p>老年代占用堆空间比例达到阈值时, 进行并发标记(不会 STW), 由下面的 JVM 参数决定</p><p>  <code>-XX:InitiatingHeapOccupancyPercent=percent</code> (默认45%)</p></li></ul><p>![Young Collection + CM](/img/垃圾回收/Young Collection + CM.png)</p><h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记(Remark), 会 STW </li><li>拷贝存活(Evacuation), 会 STW</li></ul><p> <code>-XX:MaxGCPauseMillis=ms</code> 用于指定最长的停顿时间</p><blockquote><p>为什么有的老年代被拷贝了, 有的没拷贝？<br>因为指定了最大停顿时间, 如果对所有老年代都进行回收, 耗时可能过高, 为了保证时间不超过设定的停顿时间, 会回收最有价值的老年代(回收后, 能够得到更多内存)</p></blockquote><p>![Mixed Collection](/img/垃圾回收/Mixed Collection.png)</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ul><li><strong>SerialGC</strong> <ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足发生的垃圾收集 - full gc </li></ul></li><li><strong>ParallelGC</strong> <ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足发生的垃圾收集 - full gc </li></ul></li><li><strong>CMS</strong><ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足 </li></ul></li><li><strong>G1</strong><ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足</li><li>如果垃圾产生速度慢于垃圾回收速度, 不会触发 Full GC, 还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度, 便会触发 Full GC, 然后退化成 serial Old 收集器串行的收集, 就会导致停顿的时间较长</li></ul></li></ul><h4 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h4><ul><li><p>新生代回收的跨代引用(老年代引用新生代)问题</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" alt="跨代引用"></p></li><li><p>卡表 与 Remembered Set</p><ul><li><p>卡表: O 被划分为多个区域(一个区域512K)</p></li><li><p>脏卡: 如果卡表中有区域引用了新生代对象, 则该区域被称为脏卡</p></li><li><p>Remembered Set 存在于E中, 用于保存新生代对象对应的脏卡</p></li></ul></li><li><p>在引用变更时通过 post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%84%8F%E5%8D%A1.png" alt="脏卡"></p><h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h4><p>pre-write barrier + satb_mark_queue<br>重新标记阶段<br>在垃圾回收时, 收集器处理对象的过程中</p><ul><li>黑色: 已被处理, 需要保留的</li><li>灰色: 正在处理中的</li><li>白色: 还未处理的</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark.png" alt="Remark"></p><p>看一下案例:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-1.png" alt="Remark-1"></p><ul><li><p>在处理B的过程中, B断开了对C的引用, 这样B会变成黑色, C最终会标记为白色</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-2.png" alt="Remark-2"></p></li><li><p>但是此时A又引用了C, 可是C已经被标记为白色, C最终会被回收</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-3.png" alt="Remark-3"></p></li><li><p>这样就有问题了, C还在被A引用, 不该被回收, 这时就要用到<strong>Remark</strong>, 在C的引用改变时, JVM会给加上一个pre-write barrier(写屏障)</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-4.png" alt="Remark-4"></p></li><li><p>当A引用C时, C的引用发生变化, 写屏障指令触发, 将C放入一个队列(satb_mark_queue)中, 并将C的状态修改为处理中状态</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-5.png" alt="Remark-5"></p></li><li><p>在并发标记阶段结束以后, 重新标记阶段会 STW , 然后将放在该队列中的对象重新处理, 发现有A强引用C, 就会处理它, 由灰色变成黑色</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-6.png" alt="Remark-6"></p></li></ul><h4 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h4><p><code>-XX:+UseStringDeduplication</code></p><ul><li>优点: 节省大量内存 </li><li>缺点: 略微多占用了 cpu 时间, 新生代回收时间略微增加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>过程: </p><ul><li>将所有新分配的字符串(底层是 char[])放入一个队列</li><li>当新生代回收时, G1 并发检查是否有重复的字符串</li><li>如果字符串的值一样, 就让他们引用同一个char[]</li><li>注意, 其与 String.intern() 的区别<ul><li>String.intern() 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 JVM 内部, 使用了不同的字符串标</li></ul></li></ul><h4 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后, 就能知道哪些类不再被使用, 当一个类加载器的所有类都不再使用, 则卸载它所加载的所有类<br><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p><h4 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于 region 的一半时, 称之为巨型对象</li><li>G1 不会对巨型对象进行拷贝 </li><li>回收时被优先考虑 </li><li>G1 会跟踪老年代所有 incoming 引用, 这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="回收巨型对象"></p><h4 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成, 否则退化为 Full GC</li><li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code></li><li>JDK 9 可以动态调整<ul><li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><p>查看虚拟机参数命令:</p><blockquote><p>java  -XX:+PrintFlagsFinal -version | findstr “GC”</p></blockquote><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li><li>gc</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><ul><li><strong>低延迟</strong>还是<strong>高吞吐量</strong>, 选择合适的回收器</li><li>CMS, G1, ZGC </li><li>ParallelGC</li><li>Zing(低延迟JVM, 宣称0停顿)</li></ul><h4 id="最快的-GC"><a href="#最快的-GC" class="headerlink" title="最快的 GC"></a>最快的 GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><p>查看 Full GC 前后的内存占用, 考虑以下几个问题</p><ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏<ul><li>static Map map …</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p>新生代的特点</p><ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价为零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远低于 Full GC</li></ul><p>新生代内存越大越好吗?</p><blockquote><p>-Xmn </p><p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p>设置新生代（托儿所）堆的初始大小和最大值（字节）。GC在该区域的执行频率高于其他区域。如果新生代的内存太小，则会执行大量Minor GC。如果内存太大，则只执行Full GC，这可能需要很长时间才能完成。Oracle建议将新生代的堆内存大小保持在总堆大小的25%以上，50%以下。</p></blockquote><ul><li><p>新生代能容纳所有【并发量 * (请求-响应)】的数据 </p></li><li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】 </p></li><li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p>  <code>-XX:MaxTenuringThreshold=threshold</code></p><p>  <code>-XX:+PrintTenuringDistribution</code></p>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, new threshold <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例:</p><ul><li><p>CMS 的老年代内存越大越好</p></li><li><p>先尝试不做调优, 如果没有 Full GC, 那么已经OK了, 否则先尝试调优新生代</p></li><li><p>观察发生 Full GC 时老年代内存占用, 将老年代内存预设调大1/4 ~ 1/3</p><p>  <code>-XX:CMSInitiatingOccupancyFraction=percent</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如何判断对象可以回收&quot;&gt;&lt;a href=&quot;#1-如何判断对象可以回收&quot; class=&quot;headerlink&quot; title=&quot;1. 如何判断对象可以回收&quot;&gt;&lt;/a&gt;1. 如何判断对象可以回收&lt;/h2&gt;&lt;h3 id=&quot;引用计数法&quot;&gt;&lt;a href=&quot;#引用计数法&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存结构</title>
    <link href="http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-04-15T11:49:14.000Z</published>
    <updated>2022-04-15T12:09:09.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p><img src="/img/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="程序计数器"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>Program Count Register 程序计数器(寄存器)</p><ul><li>作用: 记住下一条JVM指令的执行地址</li><li>特点:<ul><li>是线程私有的(每一个线程都有自己的程序计数器)</li><li>不会存在内存溢出</li></ul></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制字节码        //JVM指令//Java源代码</span></span><br><span class="line"> <span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out;</span></span><br><span class="line"> <span class="number">3</span>: astore_1 <span class="comment">// --</span></span><br><span class="line"> <span class="number">4</span>: aload_1 <span class="comment">// out.println(1);</span></span><br><span class="line"> <span class="number">5</span>: iconst_1 <span class="comment">// --</span></span><br><span class="line"> <span class="number">6</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"> <span class="number">9</span>: aload_1 <span class="comment">// out.println(2);</span></span><br><span class="line"><span class="number">10</span>: iconst_2<span class="comment">// --</span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">14</span>: aload_1 <span class="comment">// out.println(3);</span></span><br><span class="line"><span class="number">15</span>: iconst_3 <span class="comment">// --</span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">19</span>: aload_1 <span class="comment">// out.println(4);</span></span><br><span class="line"><span class="number">20</span>: iconst_4 <span class="comment">// --</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">24</span>: aload_1 <span class="comment">// out.println(5);</span></span><br><span class="line"><span class="number">25</span>: iconst_5 <span class="comment">// --</span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>解释器会解释指令为机器码交给 cpu 执行, 程序计数器会记录下一条指令的地址行号, 这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下, 每一个线程都有自己的程序计数器, 如果两个线程发生了上下文切换, 那么各自程序计数器会记录线程下一行指令的地址行号, 以便于接着往下执行。</li></ul></blockquote><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p><img src="/img/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="虚拟机栈"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h3><p>Java Virtual Machine Stacks (Java虚拟机栈)</p><ul><li>每个线程运行需要的内存空间, 称为虚拟机栈</li><li>每个栈由多个栈帧(Frame)组成, 对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧, 对应着当前正在执行的方法</li></ul><p><img src="/img/JVM/%E6%A0%88%E5%AE%9A%E4%B9%89.png" alt="栈定义"></p><p>看一下代码的实际运行情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debug运行, 查看栈内情况</p><p><img src="/img/JVM/%E6%A0%88%E5%86%85%E8%BF%90%E8%A1%8C.gif" alt="栈内运行"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>垃圾回收是否涉及栈内存?</p><p> 不会, 栈内存是方法调用产生的, 每次方法调用完毕会自动弹出栈(释放内存)</p></li><li><p>栈内存的分配是越大越好么?</p><p> 不是, 栈内存分配越大, 所能运行的线程也就越少, 一般使用默认即可</p></li><li><p>方法内的局部变量是否线程安全?</p><ul><li>如果方法内的局部变量没有逃离方法的作用范围, 它是线程安全的</li><li>如果是局部变量引用了对象, 并逃离了方法的作用范围, 那就要考虑线程安全问题</li></ul></li></ol><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><blockquote><p>-Xss参数用于设置栈内存大小</p><p>java.lang.StackOverflowError(栈溢出错误)</p></blockquote><ul><li><p>栈帧过多导致栈内存溢出(死循环, 死锁等)</p><p>  <img src="/img/JVM/%E6%A0%88%E5%B8%A7%E8%BF%87%E5%A4%9A.png" alt="栈帧过多"></p></li><li><p>栈帧过大导致栈内存溢出</p><p>  <img src="/img/JVM/%E6%A0%88%E5%B8%A7%E8%BF%87%E5%A4%A7.png" alt="栈帧过大"></p></li><li><p>第三方类库操作导致栈内存溢出</p></li></ul><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><p>案例一: cpu 占用过多<br>Linux 环境下运行某些程序的时候, 可能导致 CPU 的占用过高, 这时需要定位占用 CPU 过高的线程:</p><ul><li>top 命令, 查看是哪个进程占用 CPU 过高</li><li>ps H -eo pid, tid(线程id), %cpu | grep 刚才通过 top 查到的进程号, 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</li><li>jstack 进程 id 通过查看进程中的线程的 nid , 刚才通过 ps 命令看到的 tid 来对比定位, 注意 jstack 查找出的线程 id 是 16 进制的, 需要转换</li></ul><p>案例二: 程序运行很长时间没有结果</p><p>解决方法: 使用jstack命令排查死锁</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p><img src="/img/JVM/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.png" alt="本地方法栈"></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h3><p>Native Method Stacks(本地方法栈), 是JVM调用一些本地方法时, 给这些本地方法提供的内存空间</p><blockquote><p>由于Java的局限性, 一些与本地操作系统进行交互的方法就要用到操作系统的原生API</p></blockquote><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><p><img src="/img/JVM/%E5%A0%86.png" alt="堆"></p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h3><p>Heap(堆)</p><ul><li>通过new关键字创建的对象都会使用堆内存</li><li>它是线程共享的, 堆中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><blockquote><p>-Xmx用于设置堆内存大小</p><p>java.lang.OutofMemoryError ：java heap space 堆内存溢出错误</p></blockquote><p>代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><ol><li><p>jps 工具<br> 查看当前系统中有哪些 java 进程</p></li><li><p>jmap 工具<br> 查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具<br> 图形界面的, 多功能的监测工具, 可以连续监测</p></li><li><p>jvisualvm 工具</p><p> 同样是一个图形界面的检测工具</p></li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="/img/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="方法区"></p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h3><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域, 或者类似于操作系统进程中的“文本”段。它存储每个类的结构, 例如运行时常量池、字段和方法数据, 以及方法和构造函数的代码, 包括特殊方法, 用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。</p><p>尽管方法区域在逻辑上是堆的一部分, 但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小, 或者可以根据计算的需要进行扩展, 并且如果不需要更大的方法区域, 则可以收缩。方法区域的内存不需要是连续的！</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成:"></a>组成:</h3><p><img src="/img/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%84%E6%88%90.png" alt="方法区组成"></p><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><blockquote><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul></blockquote><p>代码演示内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先设置元空间内存 -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo4 test = <span class="keyword">new</span> Demo4();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>二进制<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>包含(类的基本信息, 常量池, 类方法定义, 包含了虚拟机的指令)<br>首先看看常量池是什么, 编译如下代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>javap -v HelloWorld.class</code>命令反编译查看结果。</p><p>常量池表: </p><p><img src="/img/JVM/%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="常量池"></p><blockquote><p>每条指令都会对应常量池表中一个地址, 常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p></blockquote><p>类方法定义:</p><p><img src="/img/JVM/%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.png" alt="类方法"></p><blockquote><p><strong>常量池</strong>:<br>就是一张表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>:<br>常量池是 *.class 文件中的, 当该类被加载以后, 它的常量池信息就会放入运行时常量池, 并把里面的符号地址变为真实地址</p></blockquote><h3 id="StringTable-字符串池"><a href="#StringTable-字符串池" class="headerlink" title="StringTable(字符串池)"></a>StringTable(字符串池)</h3><p>先看下面几段代码, 你能知道运行结果么:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s6 = s4.intern();</span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line">System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">String x1 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2);</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>常量池中的字符串仅是符号, 只有在被用到时才会转化为对象</li><li>利用串池的机制, 来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法, 主动将串池中还没有的字符串对象放入串池中</li></ul><h4 id="intern方法-JDK1-8"><a href="#intern方法-JDK1-8" class="headerlink" title="intern方法(JDK1.8)"></a>intern方法(JDK1.8)</h4><p>调用字符串对象的 intern 方法, 会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象, 则放入成功</li><li>如果有该字符串对象, 则放入失败</li><li>无论放入是否成功, 都会返回串池中的字符串对象</li></ul><blockquote><p>注意: </p><p>JDK1.8中, 此时如果调用 intern 方法成功, 堆内存与串池中的字符串对象是同一个对象; 如果失败, 则不是同一个对象</p><p>而在JDK1.6中, 将这个字符串对象尝试放入串池, 如果有则并不会放入, 如果没有会把此对象复制一份, 放入串池, 会把串池中的对象返回</p></blockquote><p>例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span></span><br><span class="line">String st2 = str.intern();</span><br><span class="line"><span class="comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br></pre></td></tr></table></figure><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span></span><br><span class="line">String str2 = str.intern();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str == str2);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str == str3);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(str2 == str3);</span><br></pre></td></tr></table></figure><p>知道了这些再来看看上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s4 = s1 + s2; <span class="comment">//底层使用StringBulider的append方法进行拼接, 存入堆内存</span></span><br><span class="line">String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">//编译时会对常量字符串进行优化, &quot;a&quot; + &quot;b&quot; 直接被优化为 &quot;ab&quot;</span></span><br><span class="line">String s6 = s4.intern(); <span class="comment">//取到串池中的&quot;ab&quot;</span></span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">String x1 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern(); <span class="comment">//尝试入池失败</span></span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2); </span><br><span class="line"><span class="comment">//如果先入池, x2入池成功, x1直接从常量池中取, 所以结果为true</span></span><br><span class="line"><span class="comment">//如果是JDK1.6, 入池intern不会将对象直接入池, 而是复制一份, 所以结果为false</span></span><br></pre></td></tr></table></figure><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><img src="/img/JVM/%E4%B8%B2%E6%B1%A0%E4%BD%8D%E7%BD%AE.png" alt="串池位置"></p><blockquote><p>在JDK1.6, StringTable是在永久代中的, 由于在永久代中对于GC不太方便, 在JDK1.7开始就把StringTable放在了堆中, 方便进行内存回收</p></blockquote><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>先看一个示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * 虚拟机参数设置如下</span></span><br><span class="line"><span class="comment"> * -Xmx10m 设置堆内存大小</span></span><br><span class="line"><span class="comment"> * -XX:+PrintStringTableStatistics 打印字符串常量池信息</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails -verbose:gc 打印GC的次数, 耗时等信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123; <span class="comment">// j = 100, j = 10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//垃圾回收信息</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;624K(9728K), <span class="number">0.0036565</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">10000</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 569K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">4</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd147c0</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">95</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7a020</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 136K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">1</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff622000</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3216K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 348<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">//符号表</span></span><br><span class="line"><span class="class"><span class="title">SymbolTable</span> <span class="title">statistics</span>:</span></span><br><span class="line"><span class="class"><span class="title">Number</span> <span class="title">of</span> <span class="title">buckets</span>       :     20011 </span>=    <span class="number">160088</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :     <span class="number">13269</span> =    <span class="number">318456</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :     <span class="number">13269</span> =    <span class="number">567376</span> bytes, avg  <span class="number">42.760</span></span><br><span class="line">Total footprint         :           =   <span class="number">1045920</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.663</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.663</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.814</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line"><span class="comment">//StringTable底层实现是HashTable</span></span><br><span class="line">StringTable statistics:</span><br><span class="line"><span class="comment">//桶的个数</span></span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line"><span class="comment">//字符串个数</span></span><br><span class="line">Number of entries       :      <span class="number">2559</span> =     <span class="number">61416</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :      <span class="number">2559</span> =    <span class="number">196144</span> bytes, avg  <span class="number">76.649</span></span><br><span class="line"><span class="comment">//总占用空间</span></span><br><span class="line">Total footprint         :           =    <span class="number">737664</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.043</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.043</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.207</span></span><br><span class="line">Maximum bucket size     :         <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><ul><li><p>因为StringTable是由HashTable实现的, 所以可以适当增加HashTable桶的个数, 来减少字符串放入串池所需要的时间</p><blockquote><p>-XX:StringTableSize=桶个数(最少设置为1009 )</p></blockquote></li><li><p>考虑是否需要将字符串对象入池<br>  可以通过 intern 方法减少重复入池</p></li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h3><p>Direct Meory(直接内存)</p><ul><li>常见于NIO操作时, 用于数据缓冲区</li><li>分配回收成本较高, 但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h3><p>读写文件对比案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String FROM = <span class="string">&quot;D:\\video\\moive.mp4&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String TO = <span class="string">&quot;D:\\a.mp4&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1Mb = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    io(); <span class="comment">// io 用时: 17.5304 14.2835 10.1162</span></span><br><span class="line">    directBuffer(); <span class="comment">// directBuffer 用时: 9.9542 7.9202 6.5641</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(FROM).getChannel();</span><br><span class="line">         FileChannel to = <span class="keyword">new</span> FileOutputStream(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = from.read(bb);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bb.flip();</span><br><span class="line">            to.write(bb);</span><br><span class="line">            bb.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream from = <span class="keyword">new</span> FileInputStream(FROM);</span><br><span class="line">         FileOutputStream to = <span class="keyword">new</span> FileOutputStream(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[_1Mb];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = from.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现使用directBuffer的总是要快一点, 为什么呢, 看一下读取过程</p><p>文件读写过程(使用普通IO):</p><p><img src="/img/JVM/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B.png" alt="文件读写过程"></p><p>因为 Java 不能直接操作文件管理, 需要切换到内核态, 使用本地方法进行操作, 然后读取磁盘文件, 会在系统内存中创建一个缓冲区, 将数据读到系统缓冲区,  然后在将系统缓冲区数据, 复制到 Java 堆内存中。缺点是数据存储了两份, 在系统内存中有一份, Java 堆中有一份, 造成了不必要的复制。</p><p>使用DirectBuffer的读写过程: </p><p><img src="/img/JVM/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png" alt="直接内存"></p><p>直接内存是操作系统和 Java 代码都可以访问的一块区域, 无需将代码从系统内存复制到 Java 堆内存, 从而提高了效率。</p><h3 id="直接内存释放原理"><a href="#直接内存释放原理" class="headerlink" title="直接内存释放原理"></a>直接内存释放原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">    System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">    System.gc(); <span class="comment">// 手动 gc</span></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接内存不由JVM进行管理, 所以要通过任务管理器查看</p><ol><li><p>分配完毕</p><p> <img src="/img/JVM/%E5%88%86%E9%85%8D%E5%AE%8C%E6%AF%95.png" alt="分配完毕"></p></li><li><p>开始释放</p><p> <img src="/img/JVM/%E5%BC%80%E5%A7%8B%E9%87%8A%E6%94%BE.png" alt="开始释放"></p></li></ol><p>但其实直接内存不是由JVM的垃圾回收释放的, 而是通过<code>unsafe.freeMemory</code>来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    <span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">long</span> base = unsafe.allocateMemory(_1GB); </span><br><span class="line">    unsafe.setMemory(base,_1GB, (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    unsafe.freeMemory(base); </span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (Unsafe) field.get(Unsafe.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>分配内存:</p><p> <img src="/img/JVM/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" alt="分配内存"></p></li><li><p>释放内存</p><p> <img src="/img/JVM/%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98.png" alt="释放内存"></p></li></ol><h3 id="ByteBuffer底层源码"><a href="#ByteBuffer底层源码" class="headerlink" title="ByteBuffer底层源码"></a>ByteBuffer底层源码</h3><p>allocateDirect方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 这里是给我们返回了一个DirectByteBuffer, 我们接着往下看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显看到底层就是使用unsafe来分配内存的, 而且里面还调用了一个<code>Cleaner.create</code>方法, 使用了 Cleaner(虚引用)来监测 ByteBuffer 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : add(<span class="keyword">new</span> Cleaner(var0, var1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一旦 ByteBuffer 对象被垃圾回收, 那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用<code>unsafe.freeMemory</code>来释放直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>一般用 jvm 调优时, 会加上下面的参数：</p><blockquote><p>-XX:+DisableExplicitGC  // 静止显示的 GC</p></blockquote><p>意思就是禁止我们手动的 GC, 比如手动 System.gc() 无效, 它是一种 full gc, 会回收新生代、老年代, 会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-程序计数器&quot;&gt;&lt;a href=&quot;#1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;1. 程序计数器&quot;&gt;&lt;/a&gt;1. 程序计数器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之初识JVM</title>
    <link href="http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%88%9D%E8%AF%86JVM/"/>
    <id>http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%88%9D%E8%AF%86JVM/</id>
    <published>2022-04-15T11:49:03.000Z</published>
    <updated>2022-04-15T12:07:34.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><p>定义:</p><p>Java Virtual Machine - Java程序的运行环境(Java二进制字节码的运行环境)</p><p>好处:</p><ul><li>一次编写, 到处运行</li><li>自动内存管理, 垃圾回收机制</li><li>数组下标越界检查</li><li>实现多态</li></ul><p>比较:</p><p>JVM, JRE, JDK各种关系如下</p><p><img src="/img/JVM/%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="相关概念"></p><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p>JVM是一种规范, 很多厂商都有自己定制的JVM, 下面是一些常见的JVM, 我们学习的主要是原厂的HotSpot</p><p><img src="/img/JVM/%E5%B8%B8%E8%A7%81JVM.png" alt="常见JVM"></p><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="/img/JVM/JVM%E6%9E%84%E9%80%A0.png" alt="JVM构造"></p><p>ClassLoader: Java 代码编译成二进制后, 会经过类加载器, 这样才能加载到 JVM 中运行。<br>Method Area: 类是放在方法区中。<br>Heap: 类的实例对象。<br>当类调用方法时, 会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行, 方法中的热点代码频繁调用的方法, 由 JIT 编译器优化后执行, GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是JVM&quot;&gt;&lt;a href=&quot;#什么是JVM&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM?&quot;&gt;&lt;/a&gt;什么是JVM?&lt;/h2&gt;&lt;p&gt;定义:&lt;/p&gt;
&lt;p&gt;Java Virtual Machine - Java程序的运行环境(Java二进</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC之ForkJoin框架</title>
    <link href="http://www.ayu.link/2022/04/10/JUC%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.ayu.link/2022/04/10/JUC%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-10T06:18:53.000Z</published>
    <updated>2022-04-10T07:33:56.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是由JDK1.7后提供多线并发处理框架, ForkJoin的框架的基本思想是分而治之。使用ForkJoin将相同的计算任务通过多线程的进行执行, 从而能提高数据的计算速度。在google的中的大数据处理框架mapreduce就通过类似ForkJoin的思想, 通过多线程提高大数据的处理。</p><p>使用ForkJoin框架, 需要创建一个ForkJoin的任务。因为ForkJoin框架为我们提供了RecursiveAction和RecursiveTask。我们只需要继承ForkJoin为我们提供的抽象类的其中一个并且实现compute方法。</p><ul><li>RecursiveTask在进行exec之后会使用一个result的变量进行接受返回的结果。</li><li>而RecursiveAction在exec后是不会保存返回结果。</li></ul><blockquote><p>分而治之就是将一个复杂的计算, 按照设定的阈值进行分解成多个计算, 然后将各个计算结果进行汇总。相应的ForkJoin将复杂的计算当做一个任务, 而分解的多个计算则是当做一个子任务。</p></blockquote><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>Task要通过ForkJoinPool来执行, 的子任务也会添加到当前工作线程的双端队列中, 进入队列的头部。当一个工作线程中没有任务时, 会从其他工作线程的队列尾部获取一个任务(工作窃取)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//创建MyTask对象</span></span><br><span class="line">    MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//创建分支合并池对象</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//获取合并之后非结果</span></span><br><span class="line">    ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(myTask);</span><br><span class="line">    Integer result = submit.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="comment">//关闭线程池对象</span></span><br><span class="line">    forkJoinPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>工作窃取</strong>(work-stealing)</p><p>任务进行分解成多个子任务的时候，每个子任务的处理时间都不一样。</p><p>例如分别有子任务A和B。如果子任务A的1ms的时候已经执行，子任务B还在执行。那么如果子任务A的线程等待子任务B完毕后在进行汇总，那么子任务A线程就会在浪费执行时间，最终的执行时间就以最耗时的子任务为准。</p><p>而如果子任务A执行完毕后，处理子任务B的任务，并且执行完毕后将任务归还给子任务B。这样就可以提高执行效率，这就是工作窃取。</p></blockquote><h2 id="案例1-1-100的和"><a href="#案例1-1-100的和" class="headerlink" title="案例1: 1-100的和"></a>案例1: 1-100的和</h2><p>使用二分法将100不断拆分, 直到每个线程的任务都相对轻松为止, 直接看代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写这段代码的人肯定没听说过高斯的故事</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//获取合并之后非结果</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(myTask);</span><br><span class="line">        Integer result = submit.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭线程池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分值不能超过10, 防止线程过度创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - begin) &lt;= VALUE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            MyTask myTask1 = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">            MyTask myTask2 = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            myTask1.fork();</span><br><span class="line">            myTask2.fork();</span><br><span class="line">            result = result + myTask1.join() + myTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例2-八皇后问题"><a href="#案例2-八皇后问题" class="headerlink" title="案例2: 八皇后问题"></a>案例2: 八皇后问题</h2><blockquote><p>八皇后问题是一个古老而又著名的问题, 是学习回溯算法的一个经典案例。</p><p>在8×8格的国际象棋上摆放八个皇后, 使其不能互相攻击, 即任意两个皇后都不能处于同一行、同一列或同一斜线上, 问一共有多少种摆法。</p><p>我们这里使用Fork Join框架并行解决问题, 加快处理速度。</p></blockquote><p>上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0为棋盘, 8为皇后, 1为皇后攻击位</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> EightQueen(<span class="number">0</span>, chessboard));</span><br><span class="line">        <span class="comment">//等待任务完成</span></span><br><span class="line">        forkJoinPool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EightQueen</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span>[][] chessboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EightQueen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] chessboard)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.chessboard = chessboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘, 这里一定要加把锁, 不然打印会乱套</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----第&quot;</span> + (++count) + <span class="string">&quot;种解法----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; chessboard.length; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessboard[row][col] == <span class="number">1</span>) chessboard[row][col] = <span class="number">0</span>;<span class="comment">//将被判定为攻击位的地方重新初始化为*</span></span><br><span class="line">                System.out.print(chessboard[row][col]);</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把攻击位设置为1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putAttack</span><span class="params">(<span class="keyword">int</span> nowRow, <span class="keyword">int</span> nowCol, <span class="keyword">int</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; chessboard.length; row++) &#123;</span><br><span class="line">            chessboard[row][nowCol] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">                chessboard[nowRow][col] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (row + col == nowRow + nowCol) chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (row - col == nowRow - nowCol) chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chessboard[nowRow][nowCol] = <span class="number">8</span>;<span class="comment">//上面的方法会把皇后位修改成攻击位，这里需要复原成皇后位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == chessboard.length) &#123;<span class="comment">//如果行数等于length，说明最后一行放置完毕，打印棋盘并退出方法</span></span><br><span class="line">            printChessboard(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//创建备份, 等待分支结束后数组复原</span></span><br><span class="line">                <span class="keyword">int</span>[][] backup = <span class="keyword">new</span> <span class="keyword">int</span>[chessboard.length][chessboard.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessboard.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessboard[i].length; j++) &#123;</span><br><span class="line">                        backup[i][j] = chessboard[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chessboard[row][col] = <span class="number">8</span>;</span><br><span class="line">                putAttack(row, col, chessboard);</span><br><span class="line">                <span class="comment">//开启分支, 进入下一行</span></span><br><span class="line">                EightQueen eightQueen = <span class="keyword">new</span> EightQueen(row + <span class="number">1</span>, chessboard);</span><br><span class="line">                eightQueen.fork();</span><br><span class="line">                <span class="comment">//分支结束, 数组复原</span></span><br><span class="line">                chessboard = backup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h2><ul><li>使用这种多线程带来的数据共享问题, 在处理结果的合并的时候如果涉及到数据共享的问题, 我们尽可能使用JDK为我们提供的并发容器。</li><li>在使用JVM的时候我们要考虑OOM的问题, 如果我们的任务处理时间非常耗时, 并且处理的数据非常大的时候会造成OOM。</li><li>ForkJoin也是通过多线程的方式进行处理任务。, 那么我们不得不考虑是否应该使用ForkJoin。因为当数据量不是特别大的时候, 我们没有必要使用ForkJoin, 多线程会涉及到上下文的切换, 所以数据量不大的时候使用串行比使用多线程快。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ForkJoin&quot;&gt;&lt;a href=&quot;#ForkJoin&quot; class=&quot;headerlink&quot; title=&quot;ForkJoin&quot;&gt;&lt;/a&gt;ForkJoin&lt;/h2&gt;&lt;p&gt;ForkJoin是由JDK1.7后提供多线并发处理框架, ForkJoin的框架的基本思想是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池</title>
    <link href="http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-04-09T08:20:09.000Z</published>
    <updated>2022-04-09T13:31:01.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销, 进而影响缓存局部性和整体性能。而线程池维护着多个线程, 等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用, 还能防止过分调度。</p><p>特点:</p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时, 任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源, 如果无限制的创建 ,不仅会销耗系统资源 ,还会降低系统的稳定性 ,使用线程池可以进行统一的分配, 调优和监控。</li></ul><p>架构:</p><p>Java中的线程池是通过Executor框架实现的,该框架中用到了Executor, Executors, ExecutorService, ThreadPoolExecutor这几个类</p><p><img src="/img/2022-04-09/01.png"></p><h2 id="三种线程池"><a href="#三种线程池" class="headerlink" title="三种线程池"></a>三种线程池</h2><ol><li>Executors.newFixedThreadPool(int) : 一池定线程<ul><li>创建一个定长的线程池, 可控制线程的最大并发量, 超出的线程会在阻塞队列(<strong>LinkedBlockingQueue</strong>)中等待</li><li>线程池的<strong>corePoolSize</strong>和<strong>MaxmumPoolSize</strong>是相等的</li></ul></li><li>Executors.newSingleThreadExecutor( ) : 一池一线程<ul><li>创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, 超出的线程会在阻塞队列(<strong>LinkedBlockingQueue</strong>)中等待, 保证所有的任务都按照指定顺序执行</li><li>线程池的<strong>corePoolSize</strong>和<strong>MaxmumPoolSize</strong>都为1</li></ul></li><li>Executors.newCachedThreadPool( ) : 一池N线程<ul><li>创建一个可缓存线程池, 如果线程池长度超过处理需要, 可灵活会后空闲线程, 若无可回收, 则创建新线程</li><li>线程池的<strong>corePoolSize</strong>设置为0, <strong>MaxmumPoolSize</strong>设置为<code>Integer.MAX_VALUE</code></li><li>阻塞队列使用的是<strong>SynchronousQueue</strong>, 也就是说来了任务就创建线程运行, 如果线程空闲超过60秒, 就销毁该线程</li></ul></li></ol><p>具体代码使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一池多线程</span></span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newFixedThreadPool(5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可扩容线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//十个请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种线程池其实是并不常用的, 我们在写业务的时候会遇到各种各样的情况, 这三种线程池很难满足各式各样的需求, 就需要用到自定义线程池, 想要定制化线程池, 就需要了解创建线程池的七大参数。</p><h2 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h2><ul><li><strong>int corePoolSize</strong>, 常驻线程数量(核心)</li><li><strong>int maximumPoolSize</strong>, 最大线程数量, 就是线程池扩容的最大值</li><li><strong>long keepAliveTime</strong>, 额外扩容线程的存活时间</li><li><strong>TimeUnit unit</strong>, 存活时间单位</li><li><strong>BlockingQueue workQueue</strong>, 阻塞队列, 常驻线程数量都在被使用, 新的请求会被阻塞</li><li><strong>ThreadFactory threadFactory</strong>,  线程工厂, 用来创建线程</li><li><strong>RejetedExecutionHandler handler</strong>,  拒绝策略, 表示当线程队列满了并且工作线程大于等于线程池的最大值(maxnumPoolSize)时如何来拒绝</li></ul><p>下面用一个简单的银行场景来解释一下这几个参数</p><p><img src="/img/2022-04-09/02.png"></p><p>在上面的场景中:</p><ul><li>bank银行就是我们的线程池</li><li>椭圆的窗口一共有5个, 但是实线的在开放的只有2个, 这里一直使用的窗口就是corePoolSize, 而窗口总数量就是maximumPoolSize</li><li>候客区就是workQueue, 可以看到候客区只有5个位置, 说明最多只能有5个等待线程</li><li>当候客区超了, 这时经理(threadFactory)就带着超出来的人去把闲置的窗口打开使用, 也就是扩容线程池, 创建新线程, 但是线程总数不能超过5</li><li>当人少的时候, 多开出来的窗口一直空闲, 超过了keepAliveTime就会被关闭</li><li>保安就是拒绝策略handler, 当五个窗口都开放了, 候客区还超标的话, 这时候保安就得做点什么, 比如让人出去, 或者把在窗口前墨迹的人赶出去, 这些就需要了解拒绝策略到底有哪几种了</li></ul><p>底层运行流程:</p><p><img src="/img/2022-04-09/03.png"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>JDK内置了四种拒绝策略:</p><ul><li><strong>AbortPolicy</strong>(默认), 这种拒绝策略在拒绝任务时, 会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException, 让你感知到任务被拒绝了, 于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</li><li><strong>DiscardPolicy</strong>, 这种拒绝策略正如它的名字所描述的一样, 当新任务被提交后直接被丢弃掉, 也不会给你任何的通知, 相对而言存在一定的风险, 因为我们提交的时候根本不知道这个任务会被丢弃, 可能造成数据丢失。</li><li><strong>DiscardOldestPolicy</strong>, 如果线程池没被关闭且没有能力执行, 则会丢弃任务队列中的头结点, 通常是存活时间最长的任务, 这种策略与第二种不同之处在于它丢弃的不是最新提交的, 而是队列中存活时间最长的, 这样就可以腾出空间给新提交的任务, 但同理它也存在一定的数据丢失风险。明明是我等的最久, 却让我走, 表示很难受。</li><li><strong>CallerRunsPolicy</strong>, 相对而言它就比较完善了, 当有新任务提交后, 如果线程池没被关闭且没有能力执行, 则把这个任务交于提交任务的线程执行, 也就是谁提交任务, 谁就负责执行任务。这样做主要有两点好处: <ol><li>新提交的任务不会被丢弃, 这样也就不会造成业务损失。</li><li>由于谁提交任务谁就要负责执行任务, 这样提交任务的线程就得负责执行任务, 而执行任务又是比较耗时的, 在这段期间, 提交任务的线程被占用, 也就不会再提交新的任务, 减缓了任务提交的速度, 相当于是一个负反馈。在此期间, 线程池中的线程也可以充分利用这段时间来执行掉一部分任务, 腾出一定的空间, 相当于是给了线程池一定的缓冲期。</li></ol></li></ul><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>下面就尝试自己创建一个线程池, 使用<code> new ThreadPoolExecutor()</code>方法, 需求是常驻线程数为2, 最大线程数为5, 等待队列长度为3, 其余使用默认即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义线程</span></span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//十个请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h2&gt;&lt;p&gt;线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销, 进而影响缓存局部性和整体性能。</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之阻塞队列</title>
    <link href="http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2022-04-09T07:19:57.000Z</published>
    <updated>2022-04-09T08:18:15.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是: 在队列为空时, 获取元素的线程会等待队列变为非空。当队列满时, 存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景, 生产者是往队列里添加元素的线程, 消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器, 而消费者也只从容器里拿元素。</p><ul><li>当队列是空的, 从队列中获取元素的操作将会被阻塞</li><li>当队列是满的, 从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞, 直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞, 直到其他线程从队列中移除一个或多个元素或者完全清空, 使队列变得空闲起来并后续新增</li></ul><h2 id="阻塞队列种类"><a href="#阻塞队列种类" class="headerlink" title="阻塞队列种类"></a>阻塞队列种类</h2><ol><li><p><strong>ArrayBlockingQueue</strong></p><ul><li>基于数组构成的有界阻塞队列</li><li>在生产者插入数据和消费者获取数据时用的是同一把锁, 无法并行</li></ul></li><li><p><strong>LinkedBlockingQueue</strong></p><ul><li>基于链表构成的有界(默认值为<code>Integer.MAX_VALUE</code>)阻塞队列</li><li>插入数据和获取数据分别采用了独立的锁, 有较好的并发性能</li></ul></li><li><p><strong>DelayQueue</strong></p><ul><li>基于优先级队列实现的延迟无界阻塞队列</li><li>DelayQueue 中的元素只有当其指定的延迟时间到了, 才能够从队列中获取到该元素。</li><li>DelayQueue 是一个没有大小限制的队列, 因此往队列中插入数据的操作永远不会被阻塞, 只有获取数据的操作才会被阻塞</li></ul></li><li><p><strong>PriorityBlockingQueue</strong></p><ul><li>基于优先级队列实现的无界阻塞队列</li><li>支持优先级排序</li><li>不会阻塞生产者, 当队列中没有数据时, 会阻塞消费者</li></ul></li><li><p><strong>SynchronousQueue</strong></p><ul><li>一种无缓冲的等待队列</li><li>相对于有缓冲的BlockingQueue来说, 少了一个中间环节(缓冲区)</li><li>不存储元素, 是一个单个元素的队列</li></ul><blockquote><p><strong>SynchronousQueue</strong>公平模式与非公平模式的区别</p><ul><li><strong>公平模式</strong>: SynchronousQueue 会采用公平锁, 并配合一个 FIFO 队列来阻塞多余的生产者和消费者, 从而体系整体的公平策略</li><li><strong>非公平模式</strong>(默认)：SynchronousQueue 采用非公平锁, 同时配合一个 LIFO 队列来管理多余的生产者和消费者, 再高并发的情况下容易出现线程饥饿</li></ul></blockquote></li><li><p><strong>LinkedTransferQueue</strong></p><ul><li>基于链表结构实现的无界TransferQueue队列</li><li><strong>预占模式</strong>: 意思就是消费者线程取元素时, 如果队列不为空, 则直接取走数据, 若队列为空, 生成一个节点(元素为 null)入队, 消费者线程被等待在这个节点上, 生产者线程入队时发现有一个元素为 null 的节点, 生产者线程就不入队了, 直接就将元素填充到该节点, 并唤醒该节点等待的线程, 被唤醒的消费者线程取走元素, 从调用的方法返回</li></ul></li><li><p><strong>LinkedBlockingDeque</strong></p><ul><li>基于链表实现的双向有界阻塞队列</li><li>可以从队列的两端插入和移除元素, 双向队列因为多了一个操作队列的入口, 在多线程同时入队时, 也就减少了一半的竞争</li><li>插入元素时: 如果当前队列已满将会进入阻塞状态, 一直等到队列有空的位置时再该元素插入, 该操作可以通过设置超时参数, 超时后返回 false 表示操作失败, 也可以不设置超时参数一直阻塞, 中断后抛出 InterruptedException异常</li><li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素, 同样可以通过设置超时参数</li></ul></li></ol><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>NA</td><td>NA</td></tr></tbody></table><p>各种方法类型的具体效果</p><table><thead><tr><th align="left">方法类型</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">抛出异常</td><td align="left">当阻塞队列满时, 再往队列里add插入元素会抛出IllegalStateException:Queue full<br/>当阻塞队列空时, 再对队列remove移除元素会抛出NoSuchElementException</td></tr><tr><td align="left">特殊值</td><td align="left">插入方法, 成功返回true, 失败返回false<br />移出方法, 成功返回取出的元素, 失败返回null</td></tr><tr><td align="left">阻塞</td><td align="left">当阻塞队列满时, 生产者线程继续往队列里put元素, 队列就会一直阻塞生产者知道put数据成功或中断退出<br />当阻塞队列空时, 消费者线程试图从队列里take元素, 队列就会一直阻塞消费者线程知道队列里有数据</td></tr><tr><td align="left">超时</td><td align="left">当阻塞队列满时, 队列会阻塞生产者线程, 超过等待时限后生产者线程会退出<br />当阻塞队列空时, 队列会阻塞消费者线程, 超过等待时限后消费者线程会退出</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是阻塞队列&quot;&gt;&lt;a href=&quot;#什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;什么是阻塞队列&quot;&gt;&lt;/a&gt;什么是阻塞队列&lt;/h2&gt;&lt;p&gt;阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是: 在队列为空</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之辅助类</title>
    <link href="http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <id>http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/</id>
    <published>2022-04-07T11:19:53.000Z</published>
    <updated>2022-04-07T13:26:39.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch(闭锁)"></a>CountDownLatch(闭锁)</h2><h3 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h3><p>CountDownLatch是一个同步工具类, 用来协调多个线程之间的同步, 或者说起到线程之间的通信(而不是用作互斥的作用)。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后, 再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后, 计数器的值就会减一, 当计数器的值为0时, 表示所有的线程都已经完成一些任务, 然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a>CountDownLatch的用法</h3><ul><li>当一个或多个线程调用await方法时, 这些线程会阻塞</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</li><li>计数器的值变为0时, 因await方法阻塞的线程会被唤醒, 继续执行</li></ul><p>案例: 秦始皇灭掉六国, 一统天下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举类创建六个国家</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">    one(<span class="number">1</span>, <span class="string">&quot;齐&quot;</span>), two(<span class="number">2</span>, <span class="string">&quot;楚&quot;</span>), three(<span class="number">3</span>, <span class="string">&quot;燕&quot;</span>),</span><br><span class="line">    four(<span class="number">4</span>, <span class="string">&quot;赵&quot;</span>), five(<span class="number">5</span>, <span class="string">&quot;魏&quot;</span>), six(<span class="number">6</span>, <span class="string">&quot;韩&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer retCode;</span><br><span class="line">    <span class="keyword">private</span> String retMessage;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountryEnum</span><span class="params">(Integer retCode, String retMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">        <span class="keyword">this</span>.retMessage = retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">getCountryEnum</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        CountryEnum[] countryEnums = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum countryEnum : countryEnums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countryEnum.getRetCode().equals(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> countryEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRetCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRetMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;国, 被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.getCountryEnum(i).getRetMessage()).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;秦国一统天下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/01.png"></p><p>额, 好像没有按照历史顺序来, 不过无伤大雅</p><h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p>CountDownLatch是一次性的, 计数器的值只能在构造方法中初始化一次, 之后没有任何机制再次对其设置值, 当CountDownLatch使用完毕后, 它不能再次被使用。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h2><h3 id="CyclicBarrier是什么"><a href="#CyclicBarrier是什么" class="headerlink" title="CyclicBarrier是什么"></a>CyclicBarrier是什么</h3><p>CyclicBarrier是一个同步辅助类, 它允许一组线程相互等待直到所有线程都到达一个公共的屏障点。<br>在程序中有固定数量的线程, 这些线程有时候必须等待彼此, 意思就是每个线程都得执行到等待点进行等待, 直到所有线程都执行到等待点, 才会继续往下执行。这种情况下, 使用CyclicBarrier很有帮助。这个屏障之所以用循环修饰, 是因为在所有的线程释放彼此之后, 这个屏障是可以重新使用的。</p><h3 id="CyclicBarrier的用法"><a href="#CyclicBarrier的用法" class="headerlink" title="CyclicBarrier的用法"></a>CyclicBarrier的用法</h3><p>构造方法:</p><ul><li><p>CyclicBarrier(int parties), 当等待线程数量达到parties时, 放行所有线程</p></li><li><p>CyclicBarrier(int parties，Runnable barrierAction), 当等待线程数量达到parties时, 放行所有线程, 并由最后一个线程执行barrierAction</p></li></ul><p>案例: 收集七龙珠召唤神龙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/02.png"></p><h3 id="CyclicBarrier与CountDownLatch的区别"><a href="#CyclicBarrier与CountDownLatch的区别" class="headerlink" title="CyclicBarrier与CountDownLatch的区别"></a>CyclicBarrier与CountDownLatch的区别</h3><ul><li>CyclicBarrier是对计数器做加法</li><li>CountDownLatch是对计数器做减法</li><li>CountdownLatch是一次性的</li><li>CycliBarrier是可以重复使用的, 使用<code>reset()</code>方法即可重置计数器</li></ul><h2 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore(信号灯)"></a>Semaphore(信号灯)</h2><h3 id="Semaphore是什么"><a href="#Semaphore是什么" class="headerlink" title="Semaphore是什么"></a>Semaphore是什么</h3><p>Semaphore是计数信号量。Semaphore管理一系列许可。每个acquire方法阻塞, 直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可, 这可能会释放一个阻塞的acquire方法。然而, 其实并没有实际的许可这个对象, Semaphore只是维持了一个可获得许可证的数量。</p><h3 id="Semaphore的用法"><a href="#Semaphore的用法" class="headerlink" title="Semaphore的用法"></a>Semaphore的用法</h3><ul><li>acquire(获取)当一个线程调用acquire操作时, 它要么通过成功获取信号量(信号量减1), 要么一直等下去, 直到有线程释放信号量, 或超时。</li><li>release(释放)实际上会将信号量的值加1, 然后唤醒等待的线程。</li><li>信号量主要用于两个目的, 一个是用于多个共享资源的互斥使用, 另一个用于并发线程数的控制。</li></ul><p>案例: 停车场抢车位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore, 设置许可量, 模拟三个车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟六辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车抢到车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/03.png"></p><p>可以看到, 如果有三个线程得到了许可, 那么剩下的线程就会被阻塞, 知道有线程释放许可, 才会随机释放一个被阻塞的线程获得许可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CountDownLatch-闭锁&quot;&gt;&lt;a href=&quot;#CountDownLatch-闭锁&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch(闭锁)&quot;&gt;&lt;/a&gt;CountDownLatch(闭锁)&lt;/h2&gt;&lt;h3 id=&quot;什么是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Callable接口</title>
    <link href="http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-04-06T08:56:46.000Z</published>
    <updated>2022-04-07T08:22:23.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>创建线程有四种方式:</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Callable接口</li><li>线程池</li></ul><p>前两种前面说过了, Runnable接口是比较常用的, 因为在Java中继承是很重要的, 不能随便使用, 但是Runnable接口有一个缺点, run()方法没有返回值, 也就是当线程结束时, 不能返回结果, 为了能返回结果, 在JDK1.5以后出现了Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Callable接口中的call()方法可以用来处理任务并返回一个结果, 如果无法处理, 则会抛出异常。</p></blockquote><p>Runnable和Callable的区别:</p><ul><li>Callable规定的方法是call(), Runnable规定的方法是run()</li><li>Callable的任务执行后可返回值, 而Runnable的任务是不能返回值</li><li>call()方法可以抛出异常, run()方法不能</li></ul><p>下面就写一个简单的类实现Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个10以内的随机数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当我们想要去创建这样一个线程去测试的时候发现, Thread的构造方法里没有一个是需要传入Callable接口的, 只能传入Runnable接口, 那么有什么方法可以让Callable接口转成Runnable接口呢?</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>先来看一下FutureTask的继承结构</p><p><img src="/img/2022-04-06/01.png"></p><p>FutureTask是Runnable的一个实现类, 再来看一下FutureTask的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要传入一个Callable接口, 那么使用FutureTask就可以将Callable接口转成Runnable接口了</p></blockquote><p>再来看一下FutureTask的另一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Runnable&#125;, and arrange that &#123;<span class="doctag">@code</span> get&#125; will return the</span></span><br><span class="line"><span class="comment"> * given result on successful completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result to return on successful completion. If</span></span><br><span class="line"><span class="comment"> * you don&#x27;t need a particular result, consider using</span></span><br><span class="line"><span class="comment"> * constructions of the form:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个FutureTask将在运行, 执行给定Runnable, 安排get()将返回给定的成功完成。 </p></blockquote><p>最后看一下FutureTask的常用方法</p><ul><li><code>get()</code>, 如果有必要等待计算完成, 然后获取它的结果</li><li><code>isDone()</code>, 如果正常终止, 或是发生异常, 或是手动取消, 返回true</li></ul><p>使用FutureTask来完成我们的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//普通创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> GetNumber());</span><br><span class="line">        <span class="comment">//Lambda表达式创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">            <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask1, <span class="string">&quot;tom&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask2, <span class="string">&quot;jerry&quot;</span>).start();</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom get &quot;</span> + integerFutureTask1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;jerry get &quot;</span> + integerFutureTask2.get());</span><br><span class="line">        <span class="comment">//主线程结束</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">        <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行结果:</p><p><img src="/img/2022-04-06/02.png"></p><p>运行成功!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;创建线程有四种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;实现R</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之各种锁</title>
    <link href="http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/</id>
    <published>2022-04-05T05:06:01.000Z</published>
    <updated>2022-04-05T10:43:45.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>回头看一下之前的一个多线程买票案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/01.png"></p><p>CC线程几乎卖出了一多半的票, 而BB线程只卖出了2张票, 这是因为在线程抢占的过程中, CC总能抢到锁, 这样就容易导致其他线程饥饿, 那么为什么会这样呢? 来看一下ReentrantLock的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字面意思上也能看出来, ReentrantLock在创建的时候如果不传入任何参数, 默认创建的是一个非公平锁, 当传入一个布尔值为<strong>true</strong>时, 创建的则是一个公平锁, 使用公平锁修改上面的案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/02.png"></p><p>可以看到, 当三个线程都创建完成后, 遵循的就是一个线程卖一张票的的规则, 很公平, 但是公平锁也有缺点, 那就是效率低下, 所以使用的时候还是要视情况而定。</p><blockquote><p>注意: synchronized 和 ReentrantLock 默认是非公平锁</p></blockquote><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>什么是可重入锁?</p><ul><li>可重入锁又称递归锁, 是指在同一个线程在外层方法获取锁的时候, 再进入该线程的内层方法会自动获取锁(前提,锁对象得是同一个对象), 不会因为之前已经获取过还没有释放而阻塞</li><li>Java中synchronized和ReentrantLock都是可重入锁, 可重入锁的存在就是为了在一定程度上避免<strong>死锁</strong></li></ul><p>只看概念不太能理解可重入锁这个东西, 来通过代码演示一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外中内三层代码块上的都是同一把锁o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入中层&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/03.png"></p><p>可以看到因为三层代码块用的是同一把锁, 所以不用等到上一层得到锁的代码块释放锁就能进入, 接着看一下ReentrantLock版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock演示可重入锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/04.png"></p><p>依旧是不用等到上一层代码块的锁释放就可以得到锁进入代码块</p><blockquote><p>注意: lock的lock()和unlock()方法要一一对应, 否则会对其他线程造成影响</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>什么是死锁?</p><ul><li><p>死锁是指两个或两个以上的线程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力干涉那它们都将无法推进下去, 如果资源充足, 进程的资源请求都能够得到满足, 死锁出现的可能性就很低, 否则就会因争夺有限的资源而陷入死锁</p></li><li><p>如果有两个线程各自持有一把锁, 却同时想获取对方的锁而双发都未释放锁, 这时就产生了死锁</p><p>  <img src="/img/2022-04-05/05.png"></p></li></ul><p>来看一下代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁a, 等待锁b释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁b, 等待锁a释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/06.png"></p><p>两个线程都在等待对方的锁释放, 然而如果它们获取不到对方的锁就不会释放自己的锁, 这就产生了死锁, 如果我们不人为去干预, 会一直卡在这里占用系统资源, 但是很多时候思索地产生是因为资源分配不当导致的, 我们很难这么清晰的观察到, 那么就需要通过命令的方式排查死锁并人为关闭死锁线程</p><blockquote><p>在终端输入jps排查进程</p><p>PS D:\JUC\JUC_study\one&gt; jps<br>16640 Jps<br>28472 Launcher<br>17164<br>7692 DeadLock</p><p>发现除正常线程以外, 还有一个一直在的进程7692, 使用堆栈跟踪工具jstack查看此进程</p><p>PS D:\JUC\JUC_study\one&gt; jstack 7692<br>2022-04-05 15:47:56</p><p>Found one Java-level deadlock:</p><p>“B”:<br>  waiting to lock monitor 0x0000000017a206f8 (object 0x00000000d6046488, a java.lang.Object),<br>  which is held by “A”<br>“A”:<br>  waiting to lock monitor 0x0000000017a23038 (object 0x00000000d6046498, a java.lang.Object),<br>  which is held by “B”</p><p>Java stack information for the threads listed above:</p><p>“B”:<br>        at com.ayu.sync.DeadLock.lambda$main$1(DeadLock.java:39)</p><pre><code>    - waiting to lock &lt;0x00000000d6046488&gt; (a java.lang.Object)    - locked &lt;0x00000000d6046498&gt; (a java.lang.Object)            at com.ayu.sync.DeadLock$$Lambda$2/990368553.run(Unknown Source)            at java.lang.Thread.run(Thread.java:748)</code></pre><p>“A”:<br>                at com.ayu.sync.DeadLock.lambda$main$0(DeadLock.java:25)<br>        - waiting to lock &lt;0x00000000d6046498&gt; (a java.lang.Object)<br>        - locked &lt;0x00000000d6046488&gt; (a java.lang.Object)<br>                at com.ayu.sync.DeadLock$$Lambda$1/2003749087.run(Unknown Source)<br>                at java.lang.Thread.run(Thread.java:748)</p><p>Found 1 deadlock.</p><p>果然发现了一个死锁进程, 可以通过重新分配资源的方式解决, 也可以直接杀掉此进程(前提是此进程不重要)</p><p>PS D:\JUC\JUC_study\one&gt; kill 7692</p></blockquote><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁:</p><ul><li>认为自己在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确保数据不会被别的线程修改</li><li>适合写操作多的场景, 先加锁可以保证写操作时数据正确(写操作包括增删改), 显式的锁定之后再操作同步资源</li><li>synchronized关键字和Lock的实现类都是悲观锁</li></ul><p><img src="/img/2022-04-05/07.png"></p><p>乐观锁:</p><ul><li>乐观锁认为自己在使用数据时不会有别的线程修改数据, 所以不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据, 如果这个数据没有被更新, 当前线程将自己修改的数据成功写入, 如果数据已经被其他线程更新, 则根据不同的实现方式执行不同的操作</li><li>适合读操作多的场景, 不加锁的特点能够使其读操作的性能大幅度提升</li><li>乐观锁一般有两种实现方式(采用版本号机制、CAS算法实现)</li><li>乐观锁在Java中通过使用无锁编程来实现, 最常采用的时CAS算法, Java原子类中的递增操作就通过CAS自旋实现的</li></ul><p><img src="/img/2022-04-05/08.png"></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在多线程对同一资源进行操作的时候肯定是要加锁的, 对于写操作(增删改)来说, 肯定是要考虑并发场景下的操作原子性的, 所以写操作必须是独占锁, 但是对于读操作来说, 多线程同时读一个资源并没有任何问题, 为了满足并发情况下的效率, 读操作应为共享锁。为了满足这种需求就出现了<strong>读写锁</strong>。</p><p>读写锁特点:</p><ul><li>读-读可以共享</li><li>读-写互斥</li><li>写-写互斥</li></ul><blockquote><p>Java中读写锁为<code>ReentrantReadWriteLock</code></p><p>读锁为<code>ReentrantReadWriteLock.ReadLock</code>, 使用<code>readLock()</code>方法获得</p><p>写锁为<code>ReentrantReadWriteLock.WriteLock</code>, 使用<code>writeLock()</code>方法获得</p></blockquote><p>用一个小案例来演示一下读写锁的使用: 多个线程对Map进行写入和读取操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">//创建写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.put(number + <span class="string">&quot;&quot;</span>, number + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.get(<span class="string">&quot;&quot;</span> + number);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁, 独占锁啊</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行写操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写操作结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加读锁, 共享锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读操作结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/09.png"></p><p>可以看到, 写操作未结束时, 不会有其他的线程进行操作, 但是读操作未结束时, 其他读操作线程也可以进行操作, 这就说明写锁是独占的, 读锁是共享的。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>如果我们在做完写操作之后又想进行读操作, 但是由于写锁是独占锁, 这时候进行读操作很浪费资源, 这时候就可以将写锁降级为读锁, 这样读取的时候其他线程也能共享读取</p><p>具体步骤:</p><p>获取写锁-&gt;进行写操作-&gt;获取读锁-&gt;释放写锁-&gt;进行读操作-&gt;释放读锁</p><p>代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写锁上锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁降级, 先读锁上锁再释放写锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        <span class="comment">//进行读操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放读锁, 操作完成</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/10.png"></p><p>成功从写锁降级成读锁</p><p>写锁可以降级为读锁, 那么读锁可不可以升级为写锁呢, 把上面的代码改一下试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读锁上锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁升级, 先写锁上锁再释放读锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放写锁</span></span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-04-05/11.png"></p><p>卡在这里了, 说明不能将读锁升级为写锁!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;p&gt;回头看一下之前的一个多线程买票案例&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之锁的八种情况</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/</id>
    <published>2022-03-27T07:30:47.000Z</published>
    <updated>2022-03-27T08:23:20.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据我们以下八种情况来进行调用"><a href="#根据我们以下八种情况来进行调用" class="headerlink" title="根据我们以下八种情况来进行调用"></a>根据我们以下八种情况来进行调用</h2><ol><li><p>标准访问, 两个线程, 各自访问一个方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote></li><li><p>在sendSMS方法中停留4秒, 其余与第一种情况一样</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//停留4秒</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote><p> 1-2情况说明:</p><ul><li>一个对象里面如果有多个synchronized方法, 某一个时刻内, 只要一个线程去调用其中的一个synchronized方法了, 其它的线程都只能等待, 换句话说,某一个时刻内, 只能有唯一的一个线程去访问这些synchronized方法</li></ul><ul><li> 锁的是当前对象this, 被锁定后, 其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul></li><li><p>新增普通方法hello(), 第一个线程调用sendSMS(), 第二个线程调用hello()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源类中增加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主类中修改</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    phone.hello();</span><br><span class="line">&#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——hello<br>——sendSMS</p></blockquote></li><li><p>创建两个Phone实例, 一个调用sendSMS, 一个调用sendEmail</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 3-4情况说明:</p><ul><li>普通方法与锁无关, 不会被阻塞</li><li>两个实例对象不是同一把锁</li></ul></li><li><p>将sendSMS()和sendEmail()变成静态方法, 一个实例对象去调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote></li><li><p>两个实例对象调用静态方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote><p> 5-6情况说明:</p><ul><li>对于普通方法来说, 锁的对象是this, 也就是当前实例对象</li><li>对于静态方法来说, 锁的对象就是当前类的Class对象, 也就是说这个类的所有实例对象公用同一把锁</li></ul></li><li><p>一个静态方法, 一个普通方法, 一个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote></li><li><p>一个静态方法, 一个普通方法, 两个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 7-8情况说明:</p><ul><li>不管是一个实例对象还是多个实例对象, 普通同步方法与静态同步方法的锁都不是同一把</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之集合线程安全</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-03-27T05:43:59.000Z</published>
    <updated>2022-03-27T07:01:47.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合演示"><a href="#List集合演示" class="headerlink" title="List集合演示"></a>List集合演示</h2><p>先来看下面一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//多线程并发访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个ArrayList集合, 下面十个线程每个都往里放一条数据并读取这个集合, 看一下运行结果</p><p><img src="/img/2022-03-27/01.png" alt="image-20220327140910524"></p><p>报了java.util.ConcurrentModificationException这么一个错误, 这个错误是并发修改异常, 看一下ArrayList的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add()这个方法没有加synchronized关键字也没有Lock接口, 说明这是一个线程不安全的类。</p><p>想要线程安全有以下三种解决方法</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector也是List的子类, 并且Vector的方法有synchronized关键字修饰, 所以Vector是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们只需要将ArrayList改为Vector就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但是Vector在高并发情况下的性能堪忧, 所以不推荐使用</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>使用Collections工具类返回一个线程同步列表, 方法是<code>Collections.synchronizedList(List<T> list)</code></p><p>改一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>但是这种方法也比较过时了, 不推荐使用</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList底层使用<strong>写时复制技术</strong>, 每次往列表里写入的时候会复制整个列表到新的列表, 读的时候读原来的那个旧的, 当写操作进行完之后再将新老列表合并覆盖, 我们推荐使用写时复制列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><p>同理, 来看一下另外两个常用的集合类, <code>HashSet</code>和 <code>HashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的add方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看的出来, 这两个类都是线程不安全的。</p><ul><li><p>Set想要实现线程安全, 推荐使用<code>CopyOnWriteArraySet</code>, 底层同样是写时复制技术</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>Map推荐使用<code>ConcurrentHashMap</code>, 底层使用自旋锁CAS实现线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List集合演示&quot;&gt;&lt;a href=&quot;#List集合演示&quot; class=&quot;headerlink&quot; title=&quot;List集合演示&quot;&gt;&lt;/a&gt;List集合演示&lt;/h2&gt;&lt;p&gt;先来看下面一段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程间通信</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2022-03-26T13:21:25.000Z</published>
    <updated>2022-03-26T15:09:43.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>谈到线程间通信就不得不说一个经典的生产者-消费者模型, 我们假定这样一个场景:</p><ol><li>一个小小的饮品店, 桌子太小了每次只能放一杯饮品</li><li>桌子上没有饮品的时候顾客就会等待</li><li>桌子上有饮品的时候店长就不做了(很佛系)</li></ol><p>我们尝试用代码实现以下这个场景:</p><ol><li><p>把饮品店, 饮品, 做饮品, 取饮品给抽象出来</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的具体实现, 考虑多线程操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>来个main()方法调用一下</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行一下:</p><p> <img src="/img/2022-03-26/11.png"></p><p> 发现非常和睦, produce1做一杯, consume1买一杯。</p></li></ol><p>这时我们需求升级了, 多来个做饮品的, 买饮品的也多排了一队, 但是桌子还是那么大, 简单, 我们再来两个线程就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建生产线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce2&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/12.png"></p><p>出大问题, 不是说好的桌子上只能放一杯么, 为什么会出现这种问题呢, 那是因为在程序中发生了虚假唤醒:</p><p>之前说过, wait()这个方法是在哪里停下就在那里开始, 回头看一眼代码两个方法中进行判断的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用while循环替代if, 这样每次醒过来就会重新进行判断, 改完之后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次看一下运行结果: </p><p><img src="/img/2022-03-26/13.png"></p><p>又和睦起来了!</p><h3 id="多线程编程步骤"><a href="#多线程编程步骤" class="headerlink" title="多线程编程步骤"></a>多线程编程步骤</h3><p>经过上面的那个案例, 可以总结一下四个步骤:</p><ol><li>创建资源类, 在资源类中创建共享属性和操作方法</li><li>在资源类操作方法: 判断、操作、通知</li><li>创建多个线程, 调用资源类的操作方法</li><li>防止虚拟唤醒问题</li></ol><h3 id="Lock接口版"><a href="#Lock接口版" class="headerlink" title="Lock接口版"></a>Lock接口版</h3><p>既然synchronized可以实现上面的案例, 那么Lock接口肯定也可以实现, 使用Condition的两个方法实现线程等待和唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//获得condition实例</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有咱就做一杯</span></span><br><span class="line">            water++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有就取走</span></span><br><span class="line">            water--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉店家该做了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/14.png"></p><p>完美复刻!</p><h3 id="线程定制化通信"><a href="#线程定制化通信" class="headerlink" title="线程定制化通信"></a>线程定制化通信</h3><p>上面案例的结果都有一个特点, 两个生产者和两个消费者出现的很乱, 有没有可能让线程间按照我们想要的顺序运行呢?</p><p>来看一个简单案例, 要求是</p><ul><li>AA, BB, CC三个线程, 每个线程调用一个方法</li><li>执行顺序是AA-&gt;BB-&gt;CC</li><li>循环执行10轮</li></ul><p>看一下思路</p><p><img src="/img/2022-03-26/15.png"></p><p>根据这个思路, 来编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    Condition cA = lock.newCondition();</span><br><span class="line">    Condition cB = lock.newCondition();</span><br><span class="line">    Condition cC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//A方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                cA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodA : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为2</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//cB唤醒</span></span><br><span class="line">            cB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                cB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodB : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为3</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//cC唤醒</span></span><br><span class="line">            cC.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                cC.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodC : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cA唤醒</span></span><br><span class="line">            cA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个主类测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下运行结果</p><p><img src="/img/2022-03-26/16.png"></p><p>按照我们的需求完美运行, 这就是线程定制化通信!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识锁</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/</id>
    <published>2022-03-26T07:14:57.000Z</published>
    <updated>2022-03-26T15:10:28.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先来看一段代码"><a href="#先来看一段代码" class="headerlink" title="先来看一段代码"></a>先来看一段代码</h2><p>使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下运行结果:</p><p><img src="/img/2022-03-26/01.png"> </p><p>我们发现一个很奇怪的事情, 买票的顺序不是从19到0, 是一个很混乱的顺序, 这是为什么呢? 因为我们在多个线程进行操作的时候难免会发生线程抢占, 明明我这个线程进来做完操作了准备打印结果, 但这时又被另一个线程抢了过去运行权, 它先打印了结果, 我这好不容易再次抢了回来, 可这时已经晚了, 打印出了原本的结果, 可这个结果却是过时错误的结果, 那么怎样避免这样的事发生呢, 我们就需要给买票操作加把锁。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>synchronized是Java中的关键字, 中文意思是同步, 也称之为”同步锁”。</p><p>作用主要有三个:</p><ul><li>原子性: 确保线程互斥地访问同步代码</li><li>可见性: 保证共享变量的修改能够及时可见, 其实是通过Java内存模型中的”对一个变量unlock操作之前, 必须要同步到主内存中; 如果对一个变量进行lock操作, 则将会清空工作内存中此变量的值, 在执行引擎使用此变量前, 需要重新从主内存中load操作或assign操作初始化变量值 “来保证的</li><li>有序性: 有效解决重排序问题, 即”一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</li></ul></blockquote><p>synchronized的3种使用方式:</p><ul><li><p>修饰实例方法: 作用于当前实例加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意: </p><ul><li>在定义接口方法时不能使用synchronized关键字。</li><li>构造方法不能使用synchronized关键字, 但可以使用synchronized代码块来进行同步。 </li></ul></li><li><p>修饰静态方法: 作用于当前类对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  与上一个不同的是, 被synchronized修饰的静态方法是对于这个类的所有实例对象都起作用的, 也就是说所有这个类的实例对象用的是同一把锁。</p></li><li><p>修饰代码块: 指定加锁对象, 对给定对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给这个类的某一代码块加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给这个对象加锁</span></span><br><span class="line">Object obj;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在我们就可以使用synchronized帮我们上边的例子进行加锁操作, 很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一看运行结果:</p><p><img src="/img/2022-03-26/02.png"> </p><p>很明显, 票按照正常的顺序出售了。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><blockquote><p>Lock是java.util.concurrent.locks包下常用的接口</p><p>代表实现类是ReentrantLock(可重入锁)</p></blockquote><p>常用方法:</p><ul><li>lock(): 获取锁, 也就是给下面操作上锁</li><li>unlock(): 释放锁</li></ul><p>被lock()上锁后即使发生异常也不会释放锁, 所以我们通常在lock()方法后紧跟try…catch…块, 并将unlock()释放锁方法放在finally块中, 以此来保证锁的释放, 防止死锁的产生。</p><p>下面我们使用Lock接口对上面的例子进行修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//lock()方法一定紧跟try块</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有余票</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/03.png"> </p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>synchronized与Lock的异同：</p><ul><li>synchronized是java关键字, 内置, 而lock不是内置, 是一个接口, 可以实现同步访问且比synchronized中的方法更加丰富</li><li>synchronized不用手动释放锁, 而lock需手动释放锁(不解锁会出现死锁, 需要在 finally 块中释放锁)</li><li>Lock等待锁的线程会响应中断, 而synchronized不会响应，只会一直等待</li><li>通过 Lock 可以知道有没有成功获取锁, 而 synchronized 却无法办到</li><li>Lock 可以提高多个线程进行读操作的效率(当多个线程竞争的时候)</li></ul><h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>在synchronized中, 如果要对线程进行一些操作可以使用Object类自带的这些方法:</p><ul><li>wait(): 让当前线程进入等待, 并且遵循在哪里停下, 被唤醒时就在哪里开始的原则</li><li>notify(): JVM随机唤醒一个线程</li><li>notifyAll(): 唤醒所有线程</li></ul><p>而Lock锁可以使用newCondition()方法返回一个Condition对象, Condition类中有下面几个方法:</p><ul><li>await(): 使当前线程进入等待, 并且释放锁, 当被其他线程调用signal()唤醒时会重新获得锁</li><li>signal(): 唤醒被这个Condition实例等待的线程</li><li>signalAll(): 唤醒所有线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;先来看一段代码&quot;&gt;&lt;a href=&quot;#先来看一段代码&quot; class=&quot;headerlink&quot; title=&quot;先来看一段代码&quot;&gt;&lt;/a&gt;先来看一段代码&lt;/h2&gt;&lt;p&gt;使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识线程</title>
    <link href="http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-25T08:01:21.000Z</published>
    <updated>2022-03-26T10:02:57.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:</p><blockquote><p>进程（Process）</p><ul><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>进程是线程的容器</li><li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li><li>系统进行资源分配和调度的基本单位，是操作系统结构的基础</li></ul><p>线程（thread）</p><ul><li>操作系统能够进行运算调度的最小单位</li><li>被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流</li></ul></blockquote><p>如果没有操作系统知识的话有点难理解上面的话, 我用一个简单的比喻来解释一下, 把一个进程比作一辆正在运行的火车, 那么线程就是火车中的一个车厢, 每个车厢里都在干着自己的事, 车厢与车厢之间可以相互连通的。听不懂也没有关系, 抽象的概念往往是难以理解的, 会在后面的学习中不断领悟。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>我们平常写的程序只有一个main()方法入口, 这就是一个典型的单线程程序, 为了后面的学习我们先来认识一下<strong>Thread</strong>这个类和这个类中一些常用的方法:</p><blockquote><p>public class Thread extends Object<br>                                    implements Runnable</p><p>线程是一个线程的执行程序。Java虚拟机允许应用程序同时运行多个线程的执行。 </p></blockquote><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody><tr><td><code>start()</code></td><td>开始执行这个线程;Java虚拟机调用 <code>run</code>这个线程的方法。</td></tr><tr><td><code>sleep(long millis)</code></td><td>线程睡眠(暂时停止执行)指定的毫秒数。</td></tr><tr><td><code>currentThread()</code></td><td>返回当前线程的引用。</td></tr><tr><td><code>getName()</code></td><td>返回当前线程的名称。</td></tr><tr><td><code>setDaemon(boolean on)</code></td><td>将线程设置为守护线程或用户线程。</td></tr><tr><td><code>isDaemon()</code></td><td>这个线程是否为一个守护线程。</td></tr></tbody></table><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>通过线程枚举类的状态我么可以得知有以下六种状态:</p><ul><li><strong>NEW</strong>, 创建线程</li><li><strong>RUNNABLE</strong>, 线程准备就绪</li><li><strong>BLOCKED</strong>, 线程阻塞</li><li><strong>WAITING</strong>, 线程等待(会一直等待)</li><li><strong>TIMED_WAITING</strong>, 线程等待(超时会取消等待状态)</li><li><strong>TERMINATED</strong>, 线程终结(消亡)</li></ul><p>线程状态之间的相互转换:</p><p><img src="/img/2022-03-25/02.jpg"></p><h3 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h3><ul><li><p>通过继承Thread类(不推荐)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为在Java中继承是很宝贵的, 每个类只能继承一个类, 所以我们通常不使用这种方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过实现Runnable接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用匿名内部类实现Runnable接口传入Thread(常用)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Runnable接口是一个函数式接口, 所以我们可以使用Lambda表达式简化开发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Callable接口</p></li><li><p>使用线程池创建</p></li></ul><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><ul><li>用户线程是自定义的线程</li><li>守护线程是后台的特殊线程, 依赖于创建它的线程, 比如JVM的垃圾回收</li><li>主线程如果结束了用户线程还在执行, JVM还会存活</li><li>没有用户线程后，剩下都是守护线程, JVM就会结束</li></ul><p>我们写个小Demo来演示以下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/03.png"></p><p>发现程序打印完并未结束, 是因为我们自己创建的线程是用户线程, 而用户线程不结束, JVM是不会结束的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    aa.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    aa.start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/04.png"></p><p>程序直接结束了, 这是因为我们将自己创建的线程设置为了守护线程, 当只剩下守护线程, JVM就会结束。</p><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><blockquote><p>不同点:</p><ul><li>wait()是Object 的方法, 会释放锁, 调用它的前提是当前线程占有锁(即代码要在 synchronized 中)</li><li>sleep()是Thread 的静态方法, 任何对象实例都能调用, 不会释放锁, 也不需要占用锁</li></ul><p>相同点:</p><ul><li>都可以被interrupted()方法中断</li></ul></blockquote><h3 id="串行、并行和并发"><a href="#串行、并行和并发" class="headerlink" title="串行、并行和并发"></a>串行、并行和并发</h3><ul><li><p><strong>串行</strong>表示程序所有任务都按先后顺序进行</p></li><li><p><strong>并行</strong>表示程序同时执行多个任务</p></li><li><p><strong>并发</strong>(concurrent)：同一时刻多个线程访问统一资源</p></li></ul><p><img src="/img/2022-03-25/05.png"></p><blockquote><p>实际上, 对于单核 CPU 来说, 同一时刻只能运行一个线程, 所以, 这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象, 这是并行的概念, 而是提供一种功能让用户看来多个程序同时运行起来了, 但实际上这些程序中的进程不是一直霸占 CPU 的, 而是执行一会停一会。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h2&gt;&lt;p&gt;在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:&lt;/p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC配置与使用</title>
    <link href="http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-07T08:03:00.000Z</published>
    <updated>2021-12-08T14:50:34.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件和注解, 我们都会一一讲到。</p><h2 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h2><p>IOC容器的底层就是对象工厂</p><p>Spring提供了IOC容器的两种实现方式(两个接口):</p><ul><li><p>BeanFactory: IOC容器基本实现, 是Spring内部使用的接口, 不提供给开发人员使用, <strong>加载文件的时候不会船舰对象, 在获取对象的时候才会创建对象</strong>。</p></li><li><p>ApplicationContext: BeanFactory接口的子接口, 提供更多更强大的功能, <strong>加载配置文件的时候就会把在配置文件中配置好的对象进行创建</strong>。</p><p>ApplicationContext的四个常用实现类:</p><ul><li><strong>FileSystemXmlApplicationContext：</strong>加载配置文件的时候采用的是项目的路径, 也就是绝对路径。</li><li><strong>ClassPathXmlApplicationContext：</strong>加载配置文件的时候根据ClassPath位置, 也就是项目相对路径。</li><li><strong>XmlWebApplicationContext：</strong>在Web环境下初始化监听器的时候会加载该类。</li><li><strong>AnnotationConfigApplicationContext：</strong>根据注解的方式启动Spring 容器。</li></ul></li></ul><h2 id="SpringDI的方式"><a href="#SpringDI的方式" class="headerlink" title="SpringDI的方式"></a>SpringDI的方式</h2><p>​    Spring提供了三种方式来依赖注入,有构造方法注入, setter方法注入以及接口注入。其中Spring以往推荐使用Setter的方法现在改成推荐构造方法注入。使用构造方法注入需要注意的一点就是要避免循环依赖。所谓的循环依赖指的就是在A对象的构造方法中Spring要注入B，而在B对象中Spring要注入A。这个时候会形成一个闭环因为Spring不知道该先注入哪一个接着会抛出异常。而Spring建议的处理方式是说如果遇到这种情况的话就改用Setter方式注入。</p><h2 id="Bean管理-基于xml"><a href="#Bean管理-基于xml" class="headerlink" title="Bean管理(基于xml)"></a>Bean管理(基于xml)</h2><h3 id="基于xml创建对象"><a href="#基于xml创建对象" class="headerlink" title="基于xml创建对象:"></a>基于xml创建对象:</h3><ul><li>在Spring配置文件中, 使用bean标签创建对象</li><li>在bean标签中有多个属性, 常用的有:<ul><li>id: 唯一标识, 用于获取对象</li><li>class: 类的全路径</li></ul></li><li>创建对象的时候, 默认的是执行无参构造方法完成对象创建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性:"></a>基于xml方式注入属性:</h3><ul><li><p>使用set方法进行注入</p><p>在bean标签内使用property标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用set方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用有参构造器进行注入</p><p>在bean标签内使用constructor-arg标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用有参构造方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jerry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入其他属性"><a href="#xml注入其他属性" class="headerlink" title="xml注入其他属性:"></a>xml注入其他属性:</h3><ul><li><p>字面量</p><ul><li><p>null值</p><p>使用<code><null/></code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊符号</p><p>使用CDATA</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特殊字符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[&lt;&lt;时生&gt;&gt;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注入外部bean</p><p>使用ref属性注入外部创建好的bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--外部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注入内部bean</p><p>直接在property标签里创建bean标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;101&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联赋值</p><p>对属性里的bean对象的属性进行赋值操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;102&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入集合属性"><a href="#xml注入集合属性" class="headerlink" title="xml注入集合属性:"></a>xml注入集合属性:</h3><ul><li>array标签对数组进行赋值</li><li>list标签对List集合进行赋值</li><li>set标签对Set集合进行赋值</li><li>map标签对Map集合进行赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>go<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java&quot;</span> <span class="attr">value</span>=<span class="string">&quot;88&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;c++&quot;</span> <span class="attr">value</span>=<span class="string">&quot;78&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>SQLServer<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SpringMVC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用util标签共享bean"><a href="#使用util标签共享bean" class="headerlink" title="使用util标签共享bean:"></a>使用util标签共享bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                    http://www.springframework.org/schema/util</span><br><span class="line">                    http://www.springframework.org/schema/util/spring-util-2.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用util标签来配置共享的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>大话数据结构<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>程序是怎样跑起来的<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>操作系统导论<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用p命名空间配置bean"><a href="#使用p命名空间配置bean" class="headerlink" title="使用p命名空间配置bean:"></a>使用p命名空间配置bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用p命名空间来配置bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域:"></a>Bean作用域:</h3><p>Spring中可以使用scope属性来配置bean的作用域：</p><ul><li>singleton: 单例, 在初始化配置文件时生成单例bean对象(<strong>默认</strong>)</li><li>prototype: 原型的, 在初始化配置文件时不生成bean对象, 使用时返回不同的bean对象</li><li>request: web环境下每一个request请求都会返回一个不同的bean, 只在本次请求中有效</li><li>session: web环境下每一个request请求都会返回一个不同的bean, 在session中有效</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置scope属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期:"></a>Bean生命周期:</h3><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个测试用的Order类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.set方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">        Order order = context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;4.获取到bean对象&quot;</span>);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Order&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>3.初始化方法<br>4.获取到bean对象<br>com.ayu.bean.Order@69b0fd6f<br>5.销毁方法</p></blockquote><h3 id="Bean的后置处理器"><a href="#Bean的后置处理器" class="headerlink" title="Bean的后置处理器:"></a>Bean的后置处理器:</h3><p>使用后置处理器后的生命周期:</p><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>将bean传给后置处理器的postProcessBeforeInitialization方法</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>将bean传给后置处理器的postProcessAfterInitialization方法</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个后置处理器类实现BeanPostProcessor接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中配置BeanPostProcessor:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>初始化之前<br>3.初始化方法<br>初始化之后<br>4.获取到bean对象<br>com.ayu.bean.Order@66d1af89<br>5.销毁方法</p></blockquote><h3 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h3><p>bean标签的autowire属性实现自动装配, autowire有两个常用的值:</p><ul><li><p>byName: 根据属性名称注入, 注入值bean的id值和类属性值名称需一样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType: 根据属性类型注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注: 通过byType自动装配,已配置的bean中有多个该类型的bean时会报错</p></li></ul><h2 id="Bean管理-基于注解"><a href="#Bean管理-基于注解" class="headerlink" title="Bean管理(基于注解)"></a>Bean管理(基于注解)</h2><h3 id="Spring针对bean管理提供的注解"><a href="#Spring针对bean管理提供的注解" class="headerlink" title="Spring针对bean管理提供的注解"></a>Spring针对bean管理提供的注解</h3><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p><ul><li><strong>@Controlle</strong>r: 控制器, 推荐给controller层添加此注解。</li><li><strong>@Service</strong>: 业务逻辑, 推荐给业务逻辑层添加此注解。</li><li><strong>@Repository</strong>: 仓库管理, 推荐给数据访问层添加此注解。</li><li><strong>@Component</strong>: 给不属于以上基层的组件添加此注解。</li></ul><h3 id="基于注解实现对象创建"><a href="#基于注解实现对象创建" class="headerlink" title="基于注解实现对象创建"></a>基于注解实现对象创建</h3><ol><li><p>开启组件扫描:</p><p>如果扫面多个包, 可以用逗号隔开, 或是扫描包的上层目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建类, 在类上添加对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value属性可以不写, 会默认类名首字母小写为value的值</span></span><br><span class="line"><span class="meta">@Repository(value=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="开启组件扫描细节配置"><a href="#开启组件扫描细节配置" class="headerlink" title="开启组件扫描细节配置"></a>开启组件扫描细节配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例一：use-default-filters表示现在不使用默认filter，自己配置filter</span></span><br><span class="line"><span class="comment">content:include-filter 设置扫面那些内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例二：下面配置扫面包所有内容</span></span><br><span class="line"><span class="comment">content:exclude-filter 设置哪些内容不进行扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解实现属性注入"><a href="#基于注解实现属性注入" class="headerlink" title="基于注解实现属性注入"></a>基于注解实现属性注入</h3><ul><li><p><strong>@Autowired</strong>: 根据属性类型进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier</strong>: 根据属性名称进行注入, 通常和@Autowired一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="comment">//区别同一接口下多个实现类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>: 可以根据类型注入，也可以根据名称注入(这个注解是JDK提供的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDaO;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Value</strong>: 注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;service&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类, 代替xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.ayu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此时应使用<strong>AnnotationConfigApplicationContext</strong>这个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnnotationConfigApplicationContext需要将配置类传给它</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">userService.hello();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>IOC容器解析</title>
    <link href="http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-04T06:51:28.000Z</published>
    <updated>2021-12-07T08:10:31.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!</p><h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><h3 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h3><p>​    在了解什么是IOC之前, 我们先来了解一下, IOC为什么出现, 以及我们为什么要使用IOC。</p><p>​    在面向对象设计的程序系统里, 有N多个类, 这些类与类相互依赖, 相互合作, 我们的程序才能完整的运行起来, 但是久而久之就发现一些问题, 如果对一个类结构进行更改, 那么与这个类直接依赖或间接依赖的类也要做出相对应的更改; 就像一块精密的手表, 里面多个独立的齿轮相互啮合在一起, 才能正常工作, 但如果更换其中一个齿轮, 变成其他型号, 那么如果别的齿轮不去更换, 手表就很难再继续运行了; 齿轮之间的啮合就像我们程序系统里的耦合一样, 耦合是不能消除的, 我们只能尽量去降低他, 而IOC的出现就是为了解决这个问题。</p><p><img src="/img/2021-12-04/ioc-1.png"></p><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>​    控制反转（Inversion of Control，缩写为IOC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。(引用自百度百科)</p><p>​    IOC的思想就是借助”第三方”实现依赖关系对象之间的解耦, 如下图所示:</p><p><img src="/img/2021-12-04/ioc-2.png"></p><p>​    由于引进了中间位置的“第三方”, 也就是IOC容器, 使得A、B、C、D这4个对象没有了耦合关系, 齿轮之间的传动全部依靠“第三方”了, 全部对象的控制权全部上缴给“第三方”IOC容器, 所以, IOC容器成了整个系统的关键核心, 它起到了一种类似“粘合剂”的作用, 把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”, 对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p>​    如果我们把IOC这个第三方拿掉, 这个系统就变成了:</p><p><img src="/img/2021-12-04/ioc-3.png"></p><p>​    这时候, A、B、C、D这4个对象之间已经没有了耦合关系, 彼此毫无联系, 这样的话, 当你在实现A的时候, 根本无须再去考虑B、C和D了, 对象之间的依赖关系已经降低到了最低程度。</p><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>​    IOC底层使用xml解析, 工厂模式, 和反射技术。</p><p><img src="/img/2021-12-04/ioc-4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!&lt;/p&gt;
&lt;h2 id=&quot;IOC原理</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四大特性以及事务的隔离级别</title>
    <link href="http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-10-15T08:15:16.000Z</published>
    <updated>2022-04-07T13:40:14.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明事务的隔离级别。</p><h2 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性(ACID)"></a>四大特性(ACID)</h2><p>​    如果一个数据库支持事务操作, 那么该数据库必须具备以下四大特性:</p><ul><li><p><strong>原子性(Atomicity)</strong></p><p>​        一个事务(transaction)中的所有操作, 要么全部完成,要么全部不完成, 不会在中间某个环节结束, 事务在执行过程中发生错误, 会被回滚(Rollback)到事务开始前的状态, 就像这个事务从来没有被执行过一样。</p></li><li><p><strong>一致性(Consistency)</strong></p><p>​        在事务开始之前和结束以后, 数据库的完整性没有被破坏, 这表示写入的资料必须完全符合所有的预设规则, 这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性(Isolation)</strong></p><p>​        数据库允许多个并发事务同时对其数据进行修改和读写的能力, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致, 事务隔离分为不同级别, 这里我们后面会讲到。</p></li><li><p><strong>持久性(Durability)</strong></p><p>​        事务处理结束后, 对数据的修改就是永久的, 即使系统故障也不会丢失。</p></li></ul><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><ul><li><strong>BEGIN</strong> 或 <strong>START TRANSACTION</strong> 开启一个事务</li><li><strong>COMMIT</strong> 提交事务, 并使已对数据库进行的修改成为永久性的</li><li><strong>ROLLBACK</strong> 回滚并结束用户的事务, 撤销正在进行的所有未提交的修改</li><li><strong>ASAVEPIOINT identifier</strong> 在事务中创建一个保存点, 一个事务中可以有多个保存点</li><li><strong>RELEASE SAVEPOINT identifier</strong> 删除一个事务的保存点</li><li><strong>ROLLBACK TO identifier</strong> 把事务回滚到保存点</li></ul><h2 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a>脏读、不可重复读和幻读</h2><p>​    当多个线程都开启事务操作数据库中的数据时, 如果不考虑事务的隔离性, 会发生几种问题:</p><ul><li><p><strong>脏读</strong></p><p>脏读就是当一个事务对数据库中的数据进行了修改, 而这个修改并未提交, 此时, 另一个事务也在访问同一个数据库, 却读到了并未提交的修改后的数据。</p><p>例如:</p><p>事务A中张三向李四转账100元, 但事务并未提交,</p><p>与此同时,</p><p>事务中李四查询余额发现多了100元,</p><p>随后,</p><p>事务A发生了异常, 回滚事务, 转账的操作退回,</p><p>那么,</p><p>事务B读取到多了100元的数据即为脏数据, 我们称事务B做了一次脏读。</p></li><li><p><strong>不可重复读</strong></p><p>不可重复读是指在同一事务内, 多次读取同一数据却返回了不同的数据值, 这是因为在查询的间隔, 数据被另一个事务修改并提交了。</p><p>例如:</p><p>在事务A中, 读取到了张三的工资为5000, 事务还未提交,</p><p>与此同时,</p><p>事务B把张三的工资修改为了8000, 并提交了事务,</p><p>随后,</p><p>事务A再次查询张三的工资变为了8000, 在一个事务中多次读取结果不一致, 我们称发生了不可重复读。</p><p>不可重复读与脏读的区别在于, 脏读是一个事务读取到了另一个事务并未提交的数据, 而不可重复读则是读取到了另一事务提交的数据。</p></li><li><p><strong>幻读(虚读)</strong></p><p>幻读是指当事务不是独立执行时发生的一种现象, 如果一个事务的操作的对象是表的全部数据行, 此时, 另一个事务给表中插入一条新的数据, 那么, 第一个事务操作的用户会发现有一行数据并没有被操作到, 就像发生了幻觉一样。</p><p>例如:</p><p>事务A读取到工资大于5000的人数为10人</p><p>此时,</p><p>事务B插入一条工资为6000的员工数据并提交,</p><p>那么,</p><p>当事务A再次读取工资大于5000的人数就变成了11人, 这就产生了幻读。</p><p>幻读和不可重复读都是读取到了另一事务提交后的数据, 不同的是, 不可重复读强调的是修改, 主要针对同一条数据, 而幻读强调的是新增和删除, 针对的是一批数据的整体。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>Mysql中的四种隔离级别:</p><ul><li><p><strong>Read uncommitted (读未提交)</strong></p><p>最低级别，任何情况都无法保证。</p></li><li><p><strong>Read committed (读已提交)</strong></p><p>是大多数DBMS(如: Oracle, SQLServer)的默认事务隔离级别, 可避免脏读的发生。</p></li><li><p><strong>Repeatable read (可重复读)</strong></p><p>是Mysql的默认事务隔离级别, 可避免脏读、不可重复读的发生。</p></li><li><p><strong>Serializable (串行化)</strong></p><p>事务隔离的最高级别, 可避免脏读、不可重复读、幻读的发生。</p></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted (读未提交)</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Read committed (读已提交)</td><td align="center">-</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Repeatable read (可重复读)</td><td align="center">-</td><td align="center">-</td><td align="center">Yes</td></tr><tr><td align="center">Serializable (串行化)</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>事务级别越高, 执行效率就越低。像Serializable这样的级别, 以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待, 所以平时选用何种隔离级别应该根据实际情况。</p><p>在Mysql数据库中查看当前事务的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><p>在Mysql数据库中设置事物的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation leve 隔离级别名称;</span><br></pre></td></tr></table></figure><p><strong>设置数据库的隔离级别一定要在事务开始之前!</strong></p><h2 id="JDBC中使用事务"><a href="#JDBC中使用事务" class="headerlink" title="JDBC中使用事务"></a>JDBC中使用事务</h2><p>JDBC中事务相关方法</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Method and Description</th></tr></thead><tbody><tr><td align="center"><code>void</code></td><td align="center"><code>setTransactionIsolation(int level)</code>  试图改变这个 <code>Connection</code>对象的事务隔离级别的。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>setAutoCommit(boolean autoCommit)</code>  这个连接的自动提交模式设置为给定的状态。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint()</code>  在当前事务中创建了一个匿名的保存点,并返回新的  <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint(String name)</code>  创建一个保存点与当前事务的名字并返回新的 <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>releaseSavepoint(Savepoint savepoint)</code>  删除指定的 <code>Savepoint</code>从当前事务和随后的  <code>Savepoint</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback()</code>  取消所有更改当前事务和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback(Savepoint savepoint)</code>  取消所有更改了在给定 <code>Savepoint</code>对象集。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>commit()</code>  使得所有的更改,因为之前的提交/回滚永久和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr></tbody></table><p>如果要在JDBC中设置隔离级别, 同样需要在事务开始之前设置, 也就是setAutoCommit(false)之前, 使用setTransactionIsolation(level)方法设置, 其中的level是Connection类中的静态字段:</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Field and Description</th></tr></thead><tbody><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_NONE</code>  一个常数表明不支持事务。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_COMMITTED</code>  一个常数表明脏读预防;不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_UNCOMMITTED</code>  一个常数表明脏读、不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_REPEATABLE_READ</code>  一个常数表明脏读和不可重复读预防;幻读也会出现。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_SERIALIZABLE</code>  一个常数表明脏读、不可重复读和虚读是预防。</td></tr></tbody></table><p>部分代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line">Statement statement = <span class="keyword">null</span>;</span><br><span class="line">String sql1 = <span class="string">&quot;insert into test_table values(Tom, 123)&quot;</span>;</span><br><span class="line">String sql2 = <span class="string">&quot;insert into test_table values(Jerry, 123)&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = dbUtil.getConnection();</span><br><span class="line">    <span class="comment">//设置隔离级别</span></span><br><span class="line">    connection.setTransactionIsolation(TRANSACTION_REPEATABLE_READ);</span><br><span class="line">    <span class="comment">//开始事务</span></span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    statement = connection.createStatement();</span><br><span class="line">    statement.excuteUpdate(sql1);</span><br><span class="line">    statement.excuteUpdate(sql2);</span><br><span class="line">    <span class="comment">//如果不发生错误,提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">    <span class="comment">//如果发生错误,在这里回滚</span></span><br><span class="line">    connection.rollback();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源占用</span></span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示 : 隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言, 一个窗口就相当于一个链接, 当前窗口设置的隔离级别只对当前窗口中的事务有效; 对于JDBC操作数据库来说，一个Connection对象相当于一个链接, 而对于Connection对象设置的隔离级别只对该Connection对象有效, 与其他链接Connection对象无关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明</summary>
      
    
    
    
    
    <category term="JDBC" scheme="http://www.ayu.link/tags/JDBC/"/>
    
    <category term="Mysql" scheme="http://www.ayu.link/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>JDBC五种连接方式</title>
    <link href="http://www.ayu.link/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.ayu.link/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-04T15:11:56.000Z</published>
    <updated>2022-04-07T13:39:17.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC原理图"><a href="#JDBC原理图" class="headerlink" title="JDBC原理图"></a>JDBC原理图</h2><p><img src="/img/2021-10-04/jdbc.png" alt="jdbc"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在项目目录下创建libs文件夹,将连接用的jar包导入</p><p><img src="/img/2021-10-04/10-4-1.png" alt="10-4-1"></p></li><li><p>把导入的jar包加入到项目中,右键点击jar包</p><p><img src="/img/2021-10-04/10-4-2.png" alt="10-4-2"></p></li></ol><h2 id="五种连接方式"><a href="#五种连接方式" class="headerlink" title="五种连接方式"></a>五种连接方式</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>该方式代码中显式出现了第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用反射实例化Driver,不在代码中体现第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用反射加载Driver类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用DriverManager代替Driver进行统一管理,实现数据库的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用DriverManager替代Driver进行统一管理</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><p>不必显式的注册驱动了,因为在DriverManager的源码中已经存在静态代码块,实现了驱动的注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用Class.forName自动完成注册驱动</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式五-推荐"><a href="#方式五-推荐" class="headerlink" title="方式五(推荐)"></a>方式五(推荐)</h3><p>使用配置文件的方式保存配置信息,在代码中加载配置文件<br>使用配置文件的好处:</p><ol><li>实现了代码和数据的分离,如果需要修改配置信息,直接在配置文件中修改,不需要深入代码</li><li>如果修改了配置信息,省去重新编译的过程</li></ol><p>使用方法:</p><p>​    在src目录下创建jdbc.properties文件,添加以下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四个基本要素(记得修改成自己的配置信息)</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/ayu_db2</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关值</span></span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDBC原理图&quot;&gt;&lt;a href=&quot;#JDBC原理图&quot; class=&quot;headerlink&quot; title=&quot;JDBC原理图&quot;&gt;&lt;/a&gt;JDBC原理图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/2021-10-04/jdbc.png&quot; alt=&quot;jdbc&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JDBC" scheme="http://www.ayu.link/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建博客并部署到云服务器</title>
    <link href="http://www.ayu.link/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.ayu.link/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-10-01T09:44:31.000Z</published>
    <updated>2021-12-07T08:01:54.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做基本不会出错,话不多说,下面开始</p><h2 id="本地部署Hexo"><a href="#本地部署Hexo" class="headerlink" title="本地部署Hexo"></a>本地部署Hexo</h2><h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h3><p>nodejs: <a href="https://nodejs.org/zh-cn/">下载</a></p><p>git: <a href="https://git-scm.com/downloads">下载</a></p><h3 id="二-安装本地hexo环境"><a href="#二-安装本地hexo环境" class="headerlink" title="二.安装本地hexo环境"></a>二.安装本地hexo环境</h3><p>nodejs和git的安装只需要无脑下一步即可,安装完成后可以在dos窗口进行检验,输入命令<code>node -v</code>和<code>npm -v</code>查看版本信息</p><p><img src="/img/2021-10-01/10-1-1.png" alt="10-1-1"></p><h3 id="三-安装hexo框架"><a href="#三-安装hexo框架" class="headerlink" title="三.安装hexo框架"></a>三.安装hexo框架</h3><p>在非系统盘下新建一个blog文件夹,进入文件夹后右键Git Bash Here</p><p>输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//第一条   这是安装hexo的基础框架</span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">//第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">//第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">//第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">//第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>安装完成之后可以去浏览器输入localhost:4000进行查看,效果如下:</p><p><img src="/img/2021-10-01/10-1-2.png" alt="img/2021-10-01"></p><h2 id="将Hexo博客部署到服务器上"><a href="#将Hexo博客部署到服务器上" class="headerlink" title="将Hexo博客部署到服务器上"></a>将Hexo博客部署到服务器上</h2><h3 id="一-服务器和域名的购买"><a href="#一-服务器和域名的购买" class="headerlink" title="一.服务器和域名的购买"></a>一.服务器和域名的购买</h3><ul><li>云服务器可以选择阿里云,腾讯云,华为云,这里演示使用的是阿里云的学生机</li><li>域名建议服务器在哪个平台就在哪个平台购买,域名买完一定要第一时间备案,国内的服务器是必须要备案的,如果是香港和外国的服务器则可以不用备案</li></ul><h3 id="二-云服务器操作-阿里云为例"><a href="#二-云服务器操作-阿里云为例" class="headerlink" title="二.云服务器操作(阿里云为例)"></a>二.云服务器操作(阿里云为例)</h3><h4 id="配置安全组规则"><a href="#配置安全组规则" class="headerlink" title="配置安全组规则"></a>配置安全组规则</h4><p>阿里云默认是不授权80端口访问的,这个端口,这个端口跑的是网页服务器的访问,所以要先把它开启,否则后面配置好后也无法访问</p><p>登录控制台-&gt;云服务器ECS-&gt;安全组-&gt;安全组ID-&gt;手动添加</p><p><img src="/img/2021-10-01/10-1-3.png" alt="10-1-3"></p><h4 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h4><h5 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h5><p>远程链接云服务器后,我们需要安装搭载网站的服务器nginx,安装命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx 安装nginx</span><br><span class="line"></span><br><span class="line">systemctl start nginx 开启nginx服务</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx 跟随系统启动</span><br></pre></td></tr></table></figure><p>安装完成之后,使用公网ip访问,如果显示的是nginx或者是centos的欢迎界面的话就代表安装成功</p><h5 id="创建博客目录"><a href="#创建博客目录" class="headerlink" title="创建博客目录"></a>创建博客目录</h5><p><code>cd /home</code></p><p><code>mkdir www</code></p><p><code>cd www</code></p><p><code>mkdir website</code></p><p>我么们在本地上传的blog文件都会存放在这个文件夹中</p><p>回到home目录修改权限</p><p><code>cd /home</code></p><p><code>chmod -R 777 ./www</code></p><p><code>chmod -R 777 ./www/website</code></p><h5 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h5><p>这里先写好配置文件,然后使用include的方式,引入到nginx的配置文件中</p><p>在/etc/nginx/的目录下创建vhost文件夹,在vhost文件夹下编写配置文件</p><p><code>cd /etc/nginx/</code></p><p><code>mkdir vhost</code></p><p><code>cd vhost</code></p><p><code>vim blog.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen    80;</span><br><span class="line">root /home/www/website;</span><br><span class="line">server_name ;这里填你的域名</span><br><span class="line">location /&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps:注释文字要删掉</span><br></pre></td></tr></table></figure><p>然后把这个文件引入到nginx的配置文件中,并修改server中的一些值</p><p><code>vim /etc/nginx/nginx.conf</code></p><p><img src="/img/2021-10-01/10-1-4.png" alt="10-1-4"></p><p><img src="/img/2021-10-01/10-1-5.png" alt="10-1-5"></p><h3 id="三-安装Git和node-js"><a href="#三-安装Git和node-js" class="headerlink" title="三.安装Git和node.js"></a>三.安装Git和node.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//安装Git</span><br><span class="line">yum install git</span><br><span class="line"></span><br><span class="line">// 安装Node</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><p>新建一个git用户并修改权限</p><p><code>adduser git</code></p><p><code>chmod 740 /etc/sudoers</code></p><p><code>vim /etc/sudoers</code></p><p>修改配置文件,如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line"></span><br><span class="line">添加以下内容</span><br><span class="line"></span><br><span class="line">git ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>再将权限修改过来</p><p><code>chmod 400 /etc/sudoers</code></p><h4 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h4><p>在本机桌面,右键GIt Bash Here打开终端,执行如下命令(三次回车)</p><p><code>ssh-keygen -t rsa</code></p><p>在C:\Users\用户名.ssh中找到id_rsa.pub</p><p>回到服务器端执行如下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git  //设置git密码</span><br><span class="line">su git//切换到git用户</span><br><span class="line"><span class="built_in">cd</span> ~//切换目录</span><br><span class="line">mkdir .ssh//新建.ssh文件夹</span><br><span class="line"><span class="built_in">cd</span> .ssh//进入文件夹</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys</span></span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>在本地Git终端测试连接云服务器</p><p><code>ssh -v git@你的公网IP</code></p><p>如果不需要输入密码就可以连接说明配置成功了,如果配置失败也不是什么大问题,只不过以后每次git需要输入密码</p><h3 id="四-创建git仓库"><a href="#四-创建git仓库" class="headerlink" title="四.创建git仓库"></a>四.创建git仓库</h3><p>在服务器端 创建git仓库</p><p><code>cd ~</code></p><p><code>git init --bare blog.git</code></p><p><code>vi ~/blog.git/hooks/post-receive</code></p><p>添加下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>修改权限</p><p><code>chmod +x ~/blog.git/hooks/post-receive</code></p><h3 id="五-完成部署"><a href="#五-完成部署" class="headerlink" title="五.完成部署"></a>五.完成部署</h3><p>修改hexo的配置文件,就是blog文件夹下的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@你的服务器公网IP:/home/git/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> </span><br></pre></td></tr></table></figure><p>之后在git终端执行</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>最后重新运行nginx服务器即可(ps:每次hexo d后都要重启nginx服务器)</p><p><code>nginx -s reload</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://www.ayu.link/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.ayu.link/2021/09/04/hello-world/"/>
    <id>http://www.ayu.link/2021/09/04/hello-world/</id>
    <published>2021-09-04T09:07:46.000Z</published>
    <updated>2021-12-07T07:54:34.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的小破站"><a href="#欢迎来到我的小破站" class="headerlink" title="欢迎来到我的小破站"></a>欢迎来到我的小破站</h2><p>​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过wordpress，halo这些框架，和这些比起来hexo的配置好像更加麻烦，但也更加灵活，而且作为一款静态博客框架，安全性也是更高．</p><h2 id="这个站会发布什么内容"><a href="#这个站会发布什么内容" class="headerlink" title="这个站会发布什么内容"></a>这个站会发布什么内容</h2><p>​        主要是记录我个人的成长，分享一下code方面的经验，或者是一些趣事，anyway，关注一下总是不亏的．</p><h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a>自言自语</h2><p>​        搭建一个属于自己的网站一直是我的一个小心愿，这里可以是我的日记本，也可以是我的树洞，更可以是分享自己的一个平台，在各种短视频文化冲击的现代，如此浮躁的网络，能有一片属于自己的净土还是蛮不错的．</p><p>​        I’m OK！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;欢迎来到我的小破站&quot;&gt;&lt;a href=&quot;#欢迎来到我的小破站&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的小破站&quot;&gt;&lt;/a&gt;欢迎来到我的小破站&lt;/h2&gt;&lt;p&gt;​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过</summary>
      
    
    
    
    
    <category term="日志" scheme="http://www.ayu.link/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
