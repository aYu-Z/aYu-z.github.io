<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aYuのblog</title>
  
  
  <link href="http://www.ayu.link/atom.xml" rel="self"/>
  
  <link href="http://www.ayu.link/"/>
  <updated>2022-06-08T06:46:02.954Z</updated>
  <id>http://www.ayu.link/</id>
  
  <author>
    <name>aYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之内存模型</title>
    <link href="http://www.ayu.link/2022/06/08/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.ayu.link/2022/06/08/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-06-08T06:29:40.000Z</published>
    <updated>2022-06-08T06:46:02.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>很多人将<strong>java 内存结构</strong>与<strong>java 内存模型</strong>傻傻分不清楚, <strong>java 内存模型</strong>是 Java Memory Model (JMM) 的意思。</p><p>关于它的权威解释, 请参考：<a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b964cd2907ea22ca08b">这里&lt;(￣︶￣)↗[GO!]</a></p><p>简单的说, JMM 定义了一套在多线程读写共享数据时(成员变量、数组)时, 对数据的可见性、有序性和原子性的规则和保障</p><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>前题：</strong>原子性在多线程环境经常需要考虑的问题, 下面来个例子简单回顾一下</p><p>问题提出: 两个线程对初始值为 0 的静态变量一个做自增, 一个做自减, 各做 5000 次, 结果是 0 吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增, 自减并不是原子操作。</p><p>例如对于 i++ 而言(i为静态变量), 实际会产生如下的 JVM 字节码指令: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic   i  <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1       <span class="comment">// 准备常量1</span></span><br><span class="line">iadd           <span class="comment">// 加法</span></span><br><span class="line">putstatic   i  <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure><p>而对应 i– 也是类似: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic   i  <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1       <span class="comment">// 准备常量1</span></span><br><span class="line">isub           <span class="comment">// 减法</span></span><br><span class="line">putstatic   i  <span class="comment">// 将修改后的值存入静态变量i </span></span><br></pre></td></tr></table></figure><p>而 Java 的内存模型如下, 完成静态变量的自增, 自减需要在主存和线程内存中进行数据交换：</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="内存模型"></p><p>如果是单线程, 以上8行代码的执行是顺序的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getstatic   i  <span class="comment">// 线程1 - 获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1       <span class="comment">// 线程1 - 准备常量1</span></span><br><span class="line">iadd           <span class="comment">// 线程1 - 自增 线程内i=1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程1 - 将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程1 - 获取静态变量i的值 线程内i=1</span></span><br><span class="line">iconst_1       <span class="comment">// 线程1 - 准备常量1</span></span><br><span class="line">isub           <span class="comment">// 线程1 - 自减 线程内 i=0</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程1 - 将修改后的值存入静态变量i 静态变量i=0</span></span><br></pre></td></tr></table></figure><p>但多线程下这 8 行代码可能交错运行: 线程随机抢占CPU, CPU轮转调度将时间片分配给线程执行, 即线程在执行过程中可能被打断</p><p>出现负数的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程1 - 获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程2 - 获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1       <span class="comment">// 线程1 - 准备常量1</span></span><br><span class="line">iadd           <span class="comment">// 线程1 - 自增 线程内i=1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程1 - 将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">iconst_1       <span class="comment">// 线程2 - 准备常量1</span></span><br><span class="line">isub           <span class="comment">// 线程2 - 自减 线程内i=-1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程2 - 将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure><p>出现正数的情况: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程1 - 获取静态变量 i的值 线程内i=0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程2 - 获取静态变量 i的值 线程内i=0</span></span><br><span class="line">iconst_1       <span class="comment">// 线程1 - 准备常量1</span></span><br><span class="line">iadd           <span class="comment">// 线程1 - 自增 线程内 i=1</span></span><br><span class="line">iconst_1       <span class="comment">// 线程2 - 准备常量1</span></span><br><span class="line">isub           <span class="comment">// 线程2 - 自减 线程内 i=-1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程2 - 将修改后的值存入静态变量i 静态变量i=-1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程1 - 将修改后的值存入静态变量i 静态变量i=1</span></span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原子性问题可通过 <strong>synchronized</strong> (同步关键字) 解决</p><p>语法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    要作为原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 synchronized 解决上面的并发问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大白话如何理解呢: 你可以把 obj 想象成一个房间, 线程t1, t2 想象成两个人。</p><ol><li>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了房间, 并反手锁住了门, 在门内执行 count++ 代码。</li><li>这时候如果 t2 也运行到了 synchronized(obj) 时, 它发现门被锁住了, 只能在门外等候。</li><li>当 t1 执行完 synchronized{} 块内的代码, 这时候才会解开门上的锁, 从obj 房间出来。t2线程这时才可以进入 obj 房间, 反锁住门, 执行它的 count– 代码。 </li></ol><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><p>先来看一个现象, main 线程对 run 变量的修改对于 t 线程不可见, 导致了 t线程无法停止: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 内存模型 —— 可见性问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run  = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="keyword">false</span>; <span class="comment">// 线程t 不会如预想的那样停下来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下:</p><ol><li><p>初始状态, t 线程刚开始从主内存读取了 run 的值到工作内存。</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%8F%AF%E8%A7%81%E6%80%A7-1.png" alt="可见性-1"></p></li><li><p>因为 t 线程要频繁从内存中读取 run 的值, JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中, 减少对主存中 run 的访问, 提高速率。</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%8F%AF%E8%A7%81%E6%80%A7-2.png" alt="可见性-2"></p></li><li><p>1 秒之后, main 线程修改了 run 的值, 并同步至主存, 而 t 是从自己的工作内存中的高速缓存中读取这个变量的值, 结果永远是旧值。</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%8F%AF%E8%A7%81%E6%80%A7-3.png" alt="可见性-3"></p></li></ol><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>volatile</strong> (易变关键字)</p><p>它可以用来修饰成员变量和静态成员变量, 可以避免线程从自己的工作缓存中查找变量的值, 必须到主存中获取它的值, 线程操作 volatile 变量都是直接操作主存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run  = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="keyword">false</span>; <span class="comment">// 线程t正常停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面例子体现的实际就是可见性, 它保证的是在多个线程之间, 一个线程对 volatile 变量的修改对另一个结程可见, 不能保证原子性, 应用场景: <strong>仅用在一个写线程, 多个读线程的情况</strong>, 即内存屏障 <strong>MERS</strong> 消息一致性协议。</p><p>从字节码层面来看: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic      run    <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic      run    <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic      run    <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic      run    <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">putstatic      run    <span class="comment">// 线程 main 修改 run 为 false, 仅此一次</span></span><br><span class="line">getstatic      run    <span class="comment">// 线程 t 获取 run false</span></span><br></pre></td></tr></table></figure><p>比较之前线程安全的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程1 - 获取静态变量 i的值 线程内i=0</span></span><br><span class="line">getstatic   i  <span class="comment">// 线程2 - 获取静态变量 i的值 线程内i=0</span></span><br><span class="line">iconst_1       <span class="comment">// 线程1 - 准备常量1</span></span><br><span class="line">iadd           <span class="comment">// 线程1 - 自增 线程内 i=1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程1 - 将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">iconst_1       <span class="comment">// 线程2 - 准备常量1</span></span><br><span class="line">isub           <span class="comment">// 线程2 - 自减 线程内 i=-1</span></span><br><span class="line">putstatic   i  <span class="comment">// 线程2 - 将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>synchronized 语句块既可以保证代码块的原子性, 也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作, 性能相对更低。但 volatile 保证可见性不保证原子性。</p></blockquote><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><h3 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 内存模型 —— 有序性 问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 线程1 执行此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程2 执行此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I_Result 是一个对象, 有一个属性 r1 用来保存结果, 问: 可能的结果有几种?</p><ul><li>情况1: 线程1先执行, 这时 ready = false, 所以进入 else 分支结果为1</li><li>情况2: 线程2先执行 num = 2, 但没来得及执行 ready = true, 线程1执行, 还是进入 else 分支, 结果为1</li><li>情况3: 线程2执行到 ready = true, 线程1 执行, 这回进入 if 分支, 结果为4 (因为 num 已经执行过了)</li></ul><p>但其实还有另外一种情况, 那就是结果为 0, 这种情况是: 线程 2 先执行 ready = true, 切换到线程 1, 进入 if 分支, 结果为 0, 再回到线程 2, 执行 num = 2。可是这样不是我们的代码顺序啊, 我们的代码明明是先 num = 2, 再 ready = true 啊, 这是为什么呢?</p><p>这种现象叫做指令重排, 是 JIT 编译器在运行时的一些优化, 这个现象需要通过大量测试才能复现: </p><p>我们使用 Java 并发压测工具 <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">Jcstress</a></p><p>添加 maven 依赖: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-samples<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程1 执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程2 执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line">java -jar target/jcstress.jar</span><br></pre></td></tr></table></figure><p>看一下其中的一次测试结果: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61</span> matching test results.</span><br><span class="line">      [OK] com.ayu.Test</span><br><span class="line">    (JVM args: [-XX:-TieredCompilation])</span><br><span class="line">  Observed state   Occurrences              Expectation  Interpretation</span><br><span class="line">               <span class="number">0</span>         <span class="number">3</span>,<span class="number">717</span>   ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">               <span class="number">1</span>    <span class="number">80</span>,<span class="number">005</span>,<span class="number">503</span>               ACCEPTABLE  ok</span><br><span class="line">               <span class="number">4</span>    <span class="number">47</span>,<span class="number">367</span>,<span class="number">011</span>               ACCEPTABLE  ok</span><br><span class="line"></span><br><span class="line">      [OK] com.ayu.Test</span><br><span class="line">    (JVM args: [])</span><br><span class="line">  Observed state   Occurrences              Expectation  Interpretation</span><br><span class="line">               <span class="number">0</span>         <span class="number">3</span>,<span class="number">254</span>   ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">               <span class="number">1</span>    <span class="number">39</span>,<span class="number">597</span>,<span class="number">387</span>               ACCEPTABLE  ok</span><br><span class="line">               <span class="number">4</span>    <span class="number">48</span>,<span class="number">423</span>,<span class="number">550</span>               ACCEPTABLE  ok</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到, 结果为 0 的次数有 3000 多次。</p><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>volatile 修饰的变量, 可以禁用指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程1 执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程2 执行此方法</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests</span><br><span class="line">Some interesting behaviors observed. This is <span class="keyword">for</span> the plain curiosity.</span><br><span class="line"><span class="number">0</span> matching test results.</span><br></pre></td></tr></table></figure><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>同一个线程内, JVM 会在不影响正确性的前提下, 可以调整语句的执行顺序, 思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...; <span class="comment">// 较为耗时的操作</span></span><br><span class="line">j = ...; </span><br></pre></td></tr></table></figure><p>可以看到, 至于是先执行 i 还是先执行 j, 对最终的结果不会产生影响。所以, 上面代码真正执行时, 既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; <span class="comment">// 较为耗时的操作</span></span><br><span class="line">j = ...; </span><br></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = ...; </span><br><span class="line">i = ...; <span class="comment">// 较为耗时的操作</span></span><br></pre></td></tr></table></figure><p>这种特性称之为<strong>指令重排</strong>, 多线程下指令重排会影响<strong>正确性</strong>, 例如著名 double-checked locking 模式实现单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建, 才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例, 所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的实现特点是:</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁, 后续使用时无需加锁</li></ul><p>但在多线程环境下, 上面的代码是有问题的, 因为没有考虑指令重排问题。INSTANCE = new Singleton() 对应的字节码为: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">3</span>  <span class="comment">// class com/jvm/t12_juc/T05_Juc_Singleton</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">4</span>  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: putstatic     #<span class="number">2</span>  <span class="comment">// Field INSTANCE:Lcom/jvm/t12_juc/T05_Juc_Singleton;</span></span><br></pre></td></tr></table></figure><p>其中 4  7 两步的顺序不是固定的, 也许 JVM 会优化为：先将引用地址赋值给 INSTANCE 变量后, 再执行构造方法, 如果两个线程t1, t2 按如下时间序列执行: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间<span class="number">1</span>    t1 线程执行到 INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">时间<span class="number">2</span>    t1 线程分配空间, 为 Singleton 对象生成了引用地址 (<span class="number">0</span>处) </span><br><span class="line">时间<span class="number">3</span>    t1 线程将引用地址赋值给 INSTANCE, 这时 INSTANCE != <span class="keyword">null</span>  (<span class="number">7</span>处) </span><br><span class="line">时间<span class="number">4</span>    t2 线程进入 getInstance() 方法, 发现 INSTANCE != <span class="keyword">null</span> (<span class="keyword">synchronized</span> 块外), 直接返回 INSTANCE</span><br><span class="line">时间<span class="number">5</span>    t1 线程执行Singleton 的构造方法 (<span class="number">4</span>处) </span><br></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕, 如果在构造方法中要执行很多初始化操作, 那么 t2 拿到的是将 是一个未初始化完毕的单例。</p><p>对 INSTANCE 使用 volatile 修饰即可, 可以禁用指令重排, 但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens - before"></a>happens - before</h3><p>happens - before 规定了哪些写操作对其他线程的读操作可见, 它是可见性与有序性的一套规则总结:</p><ul><li><p>线程对 volatile 变量的写, 对接下来其它线程对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程解锁 m 之前对变量的写, 对于接下来对 m 加锁的其它线程对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (m) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程 start 前对变量的写, 对该线程开始后对该变量的读可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程结束前对变量的写, 对其它线程得知它结束后的读可见 (比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"> </span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"> </span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>线程 t1 打断 t2 (interrupt)前对变量的写, 对于其他线程得知 t2 被打断后对变量的读可见 (通过t2.interrupted 或 t2.isInterrupted)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 =  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对变量默认值 (0,  false,  null) 的写, 对其它线程对该变量的读可见</p></li><li><p>具有传递性, 如果x  hb -&gt; y 并且 y  hb -&gt; z 那么有 x hb -&gt; z</p></li></ul><h2 id="4-CAS-与-原子类"><a href="#4-CAS-与-原子类" class="headerlink" title="4. CAS 与 原子类"></a>4. CAS 与 原子类</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 即 Compare and Swap, 它体现的一种乐观锁思想, 比如过个线程要对一个共享的整数变量执行 +1 操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> 旧值 = 共享变量; <span class="comment">// 比如拿到了当前值 0</span></span><br><span class="line">    <span class="keyword">int</span> 结果 = 旧值 + <span class="number">1</span>; <span class="comment">// 在旧值 0 的基础上增加1,  正确结果是 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这时候如果别的线程把共享变量改成了 5, 本线程的正确结果 1 就作废了, 这时候</span></span><br><span class="line"><span class="comment">    compareAndSwap 返回 false, 重新尝试, 直到：</span></span><br><span class="line"><span class="comment">    compareAndSwap 返回 true, 表示我本线程做修改的同时, 别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSwap(旧值, 结果)) &#123;</span><br><span class="line">        <span class="comment">// 成功, 退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取共享变量时, 为了保证该变量的可见性, 需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发, 适用于竞争不激烈、多核 CPU 的场景下。</p><ul><li>因为没有使用 synchronized, 所以线程不会陷入阻塞, 这是效率提升的因素之一</li><li>但如果竞争激烈, 可以想到重试必然频繁发生, 消耗 CPU 运行, 反而效率会受影响</li></ul><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令。</p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li>CAS 是基于乐观锁的思想: 是乐观的估计, 不怕别的线程来修改共享变量, 就算改了也没关系, 我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想: 最悲观的估计, 得防着其他线程来修改共享变量, 我上了锁你们都别想改, 我改完了解开锁, 你们才有机会。</li></ul><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><p>IUC (java.util.concurrent) 中提供了原子操作类, 可以提供线程安全的操作, 例如: <strong>AtomicInteger</strong>、<strong>AtomicBoolean</strong> 等, 它们底层就是采用 CAS 技术 + volatile 来实现的。</p><p>可以使用 AtomicInteger 改写之前的例子: 一个线程自增、一个线程自减, 通过 原子类(cas+volatile)实现原子操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 内存模型 —— CAS 原子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子整数对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndIncrement(); <span class="comment">// 获取并且自增 i++</span></span><br><span class="line">                <span class="comment">// i.incrementAndGet(); // 自增并且获取 ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndDecrement(); <span class="comment">// 获取并且自减 i--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"> </span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-synchronized-优化"><a href="#5-synchronized-优化" class="headerlink" title="5. synchronized 优化"></a>5. synchronized 优化</h2><p>Java HotSpot 虚拟机中, 每个对象都有对象头(包括 class 指针和 MarkWord)。MarkWord 平时存储这个对象的 哈希码、分代年龄, 当加锁时, 这些信息就根据被替换为 标记位、线程锁记录指针、重量级锁指针、线程ID 等内容。</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/synchronized.png" alt="synchronized"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>如果一个对象虽然有多线程访问, 但多线程访问的时间是错开的 (也就是没有竞争) , 那么可以使用轻量级锁来优化, 这就好比：</p><ul><li>学生 (线程A) 用课本占座, 上了半节课, 出门了 (CPU 时间到) , 回来一看, 发现课本没变, 说明没有竞争, 继续上他的课。</li><li>如果这期间有其它学生 (线程B) 来了, 会告知 (线程A) 有并发访问, 线程A 随即升级为重量级锁, 进入重量级锁的流程。</li><li>而重量级锁就不是那么课本占座那么简单了, 可以想象线程A 走之前, 把座位用一个铁栅栏围起来。</li></ul><p>假设有两个方法同步块, 利用同一个对象加锁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程的栈帧都会包含一个锁记录的结构, 内部可以存储锁定对象的 MarkWord</p><table><thead><tr><th>线程 1</th><th>对象 MarkWord</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块 A, 把 Mark 复制到线程1 的锁记录</td><td>01 (无锁)</td><td></td></tr><tr><td>CAS 修改 Mark 为线程1 锁记录地址</td><td>01 (无锁)</td><td></td></tr><tr><td>成功 (加锁)</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>执行同步块 A</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>访问同步块 B, 把 Mark 复制到线程1 的锁记录</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>失败 (发现是自己的锁)</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>锁重入</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>执行同步块 B</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>同步块 B 执行完毕</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>同步块 A 执行完毕</td><td>00 (轻量锁) 线程 1 锁记录地址</td><td></td></tr><tr><td>成功 (解锁)</td><td>01 (无锁)</td><td></td></tr><tr><td></td><td>01 (无锁)</td><td>访问同步块 A, 把 Mark 复制到线程 2 的锁记录</td></tr><tr><td></td><td>01 (无锁)</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td></td><td>00 (轻量锁) 线程 2 锁记录地址</td><td>成功 (加锁)</td></tr></tbody></table><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试轻量级锁的过程中, CAS 操作无法成功, 这时一种情况就是有其它线程为此对象加上轻量级锁 (有竞争), 这时需要进行锁膨胀, 将轻量级变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>线程 1</th><th>对象 MarkWord</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块A, 把 Mark 复制到线程1 的锁记录</td><td>01 (无锁)</td><td></td></tr><tr><td>CAS 修改 Mark 为线程1 锁记录地址</td><td>01 (无锁)</td><td></td></tr><tr><td>成功 (加锁)</td><td>00 (轻量锁) 线程1 锁记录地址</td><td></td></tr><tr><td>执行同步块</td><td>00 (轻量锁) 线程1 锁记录地址</td><td></td></tr><tr><td>执行同步块</td><td>00 (轻量锁) 线程1 锁记录地址</td><td>访问同步块, 把 Mark 复制到线程2</td></tr><tr><td>执行同步块</td><td>00 (轻量锁) 线程1 锁记录地址</td><td>CAS 修改 Mark 为线程2 锁记录地址</td></tr><tr><td>执行同步块</td><td>00 (轻量锁) 线程1 锁记录地址</td><td>失败 (发现别人已经占了锁)</td></tr><tr><td>执行同步块</td><td>00 (轻量锁) 线程1 锁记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10 (重量锁) 重量锁指针</td><td>阻塞中</td></tr><tr><td>失败 (解锁)</td><td>10 (重量锁) 重量锁指针</td><td>阻塞中</td></tr><tr><td>释入重量锁, 唤起阻塞线程竞争</td><td>10 (重量锁)</td><td>阻塞中</td></tr><tr><td></td><td>10 (重量锁)</td><td>竞争重量锁</td></tr><tr><td></td><td>10 (重量锁)</td><td>成功 (加锁)</td></tr></tbody></table><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>重量级锁竞争的时候, 还可以使用自旋来进行优化, 如果当前线程自旋成功 (即这时候持锁线程已经退出了同步块, 释放锁), 这时当前线程就可以避免阻塞。</p><p>在 Java 6 之后自旋锁是自适应的, 比如对象刚刚的一次自旋操作成功过, 那么认为这次自旋成功的可能性会高, 就多自旋几次；反之, 就少自旋甚至不自旋, 总之, 比较智能。</p><ul><li>自旋会占用 CPU 时间, 单核 CPU 自旋就是浪费, 多核 CPU 自旋才能发挥优势。</li><li>好比等红灯时汽车是不是熄火, 不熄火相当于自旋 (等待时间短了划算), 熄火了相当于阻塞 (等待时间长了划算)</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><p>自旋重试成功的情况:</p><table><thead><tr><th>线程 1 (cpu 1 上)</th><th>对象 Mark</th><th>线程 2 (cpu 2 上)</th></tr></thead><tbody><tr><td></td><td>10 (重量锁)</td><td></td></tr><tr><td>访问同步块, 获取 monitor</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>成功 (加锁)</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>访问同步块, 获取 monitor</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>成功 (解锁)</td><td>10 (无锁)</td><td>自旋重试</td></tr><tr><td></td><td>10 (重量锁) 重量锁指针</td><td>成功 (加锁)</td></tr><tr><td></td><td>10 (重量锁) 重量锁指针</td><td>执行同步块</td></tr><tr><td></td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况:</p><table><thead><tr><th>线程 1 (cpu 1 上)</th><th>对象 Mark</th><th>线程 2 (cpu 2 上)</th></tr></thead><tbody><tr><td></td><td>10 (重量锁)</td><td></td></tr><tr><td>访问同步块, 获取 monitor</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>成功 (加锁)</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td></td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>访问同步块, 获取 monitor</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>阻塞</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时 (就自己这个线程), 每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化；只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头, 之后发现这个线程 ID 是自己的就表示没有竞争, 不用重新 CAS</p><ul><li>撤销偏向需要将持锁线程升级为轻量级锁, 这个过程中所有线程需要暂停 (STW)</li><li>访问对象的 hashCode 也会撤销偏向锁</li><li>如果对象虽然被多个线程访问, 但没有竞争, 这时偏向了线程 T1 的对象仍有机会重新偏向 T2, 重偏向会重置对象的 Thread ID</li><li>撤销偏向和重偏向都是批量进行的, 以类为单位</li><li>如果撤销偏向到达某个阈值, 整个类的所有对象都会变为不可偏向的</li><li>可以主动使用 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁  (偏向锁是撤销是一个非常重的操作)</li></ul><p>为什么频繁的偏向锁撤销会导致STW时间增加呢？阅读偏向锁源码可以知道: 偏向锁的撤销需要等待全局安全点 (safe point),暂停持有偏向锁的线程, 检查持有偏向锁的线程状态。首先遍历当前JVM的所有线程, 如果能找到偏向线程, 则说明偏向的线程还存活, 此时检查线程是否在执行同步代码块中的代码, 如果是, 则升级为轻量级锁, 进行CAS竞争锁。可以看出撤销偏向锁的时候会导致stop the word。</p><p>假设有两个方法同步块, 利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A, 检查 Mark 中是否有线程 ID</td><td>101  (无锁可偏向)</td></tr><tr><td>尝试加偏向锁</td><td>101(无锁可偏向) 对象 hashCode</td></tr><tr><td>成功</td><td>101 (无锁可偏向) 线程 ID</td></tr><tr><td>执行同步块 A</td><td>101 (无锁可偏向) 线程 ID</td></tr><tr><td>访问同步块 B. 检查 Mark 中是不有线程 ID</td><td>101 (无锁可偏向) 线程 ID</td></tr><tr><td>是自己的线程 ID. 锁是自己的. 无需做更多操作</td><td>101 (无锁可偏向) 线程 ID</td></tr><tr><td>执行同步块 B</td><td>101 (无锁可偏向) 线程 ID</td></tr><tr><td>执行完毕</td><td>101 (无锁可偏向) 对象 hashCode</td></tr></tbody></table><p>最后以一张表格来总结一下 synchronized 锁的知识:</p><p><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/synchronized%E9%94%81.png" alt="synchronized锁"></p><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="减少上锁时间"><a href="#减少上锁时间" class="headerlink" title="减少上锁时间"></a>减少上锁时间</h4><p>同步代码块中尽量短</p><h4 id="减少锁的粒度"><a href="#减少锁的粒度" class="headerlink" title="减少锁的粒度"></a>减少锁的粒度</h4><p>将一个锁拆分为多个锁提高并发度, 例如：</p><ul><li>ConcurrentHashMap</li><li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候. 会使用 CAS 来累加值到 base. 有并发争用. 会初始化 cells 数组. 数组有多少个 cell. 就允许有多少线程并行修改. 最后将数组中每个 cell 累加. 再加上 base 就是最终的值。</li><li>LinkedBlockingQueue 入队和出队使用不同的锁. 相对于 LinkedBlockingArray 只有一个锁效率最高</li></ul><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>多次循环进入同步块不如同步块内多次循环<br>另外 JVM 可能会做如下优化, 把多次 append 的加锁操作粗化为一次 (因为都是对同一个对象加锁, 没必要重入多次)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>JVM 会进行代码的逃逸分析. 例如某个加锁对象是方法内局部变量. 不会被其它线程所访问到. 这时候就会被即时编译器忽略掉所有同步操作。</p><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>CopyOnWriteArrayList</p><p>CopyOnWriteSet</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-内存模型&quot;&gt;&lt;a href=&quot;#Java-内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型&quot;&gt;&lt;/a&gt;Java 内存模型&lt;/h1&gt;&lt;p&gt;很多人将&lt;strong&gt;java 内存结构&lt;/strong&gt;与&lt;strong&gt;jav</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载</title>
    <link href="http://www.ayu.link/2022/06/08/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://www.ayu.link/2022/06/08/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-06-08T06:29:25.000Z</published>
    <updated>2022-06-08T06:40:25.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类加载阶段"><a href="#1-类加载阶段" class="headerlink" title="1. 类加载阶段"></a>1. 类加载阶段</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>将类的字节码载入方法区(1.8后为元空间, 在本地内存中)中, 内部采用 C++ 的 instanceKlass 描述 java 类, 它的重要 ﬁeld 有: <ul><li>_java_mirror 即 java 的类镜像, 例如对 String 来说, 它的镜像类就是 String.class, 作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载, 先加载父类</li><li>加载和链接可能是交替运行的</li></ul><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%8A%A0%E8%BD%BD.png" alt="加载"></p><ul><li>instanceKlass保存在方法区。JDK 8以后, 方法区位于元空间中, 而元空间又位于本地内存中</li><li>_java_mirror则是保存在堆内存中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass, 从而获取类的各种信息</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><p><strong>验证</strong>: 验证类是否符合JVM规范, 安全性检查<br>用支持二进制的编辑器修改 HelloWorld.class 的魔数(<code>CAFEBABE</code>-&gt;<code>CAFEBABA</code>), 在控制台运行</p><blockquote><p>报错了, 这里说的是通过检查魔数发现这不是一个class文件, 所以不能运行</p><p>Error: A JNI error has occurred, please check your installation and try again<br>Exception in thread “main” java.lang.ClassFormatError: Incompatible magic value 1128351301 in class file HelloWorld</p><pre><code> at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:468) at java.net.URLClassLoader.access$100(URLClassLoader.java:74) at java.net.URLClassLoader$1.run(URLClassLoader.java:369) at java.net.URLClassLoader$1.run(URLClassLoader.java:363) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:362) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</code></pre></blockquote></li><li><p><strong>准备</strong>: 为 static 变量分配空间, 设置默认值</p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾, 从 JDK 7 开始, 存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤, 分配空间在准备阶段完成, 赋值在初始化阶段完成</li><li>如果 static 变量是 final 的基本类型, 以及字符串常量, 那么编译阶段值就确定了, 赋值在准备阶段完成</li><li>如果 static 变量是 final 的, 但属于引用类型, 那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li></ul></li><li><p><strong>解析</strong></p><p>将常量池中的符号引用解析为直接引用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Demo.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; c = classLoader.loadClass(<span class="string">&quot;com.ayu4.C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new C();</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 HSDB 工具可以看到使用 ClassLoader 加载类 C, 类 D 是不会被加载的, 并且在类 C 中, 类 D 还只是一个未被解析的常量符号</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E8%A7%A3%E6%9E%901.png" alt="解析"></p><p> 而使用<code>new C()</code> 的时候则会执行 C 里面的静态代码 <code>D d = new D()</code> , 所以类 C 和 类 D 都会被加载</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E8%A7%A3%E6%9E%902.png" alt="解析"></p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="V-方法"><a href="#V-方法" class="headerlink" title="()V 方法"></a><code><cinit>()V</code> 方法</h4><p>初始化即调用 <code><cinit>()V</code> , 虚拟机会保证这个类的<strong>构造方法</strong>的线程安全</p><h4 id="发生的时机"><a href="#发生的时机" class="headerlink" title="发生的时机"></a>发生的时机</h4><p>概括得说, 类初始化是<strong>懒惰的</strong></p><ul><li>main 方法所在的类, 总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化, 如果父类还没初始化, 会引发</li><li>子类访问父类的静态变量, 只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的 static final 静态常量(基本类型和字符串)不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的 loadClass 方法</li><li>Class.forName的参数 2 为 false时</li></ul><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 静态常量(基本类型和字符串)不会触发初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(B.b);</span></span><br><span class="line">        <span class="comment">// 2. 类对象.class 不会触发初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(B.class);</span></span><br><span class="line">        <span class="comment">// 3. 创建该类的数组不会触发初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(new B[0]);</span></span><br><span class="line">        <span class="comment">// 4. 不会初始化类 B, 但会加载 B、A</span></span><br><span class="line">        <span class="comment">// ClassLoader cl = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line">        <span class="comment">// cl.loadClass(&quot;com.ayu4.B&quot;);</span></span><br><span class="line">        <span class="comment">// 5. 不会初始化类 B, 但会加载 B、A</span></span><br><span class="line">        <span class="comment">// ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;com.ayu4.B&quot;, false, c2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首次访问这个类的静态变量或静态方法时</span></span><br><span class="line">        <span class="comment">// System.out.println(A.a);</span></span><br><span class="line">        <span class="comment">// 2. 子类初始化, 如果父类还没初始化, 会引发</span></span><br><span class="line">        <span class="comment">// System.out.println(B.c);</span></span><br><span class="line">        <span class="comment">// 3. 子类访问父类静态变量, 只触发父类初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(B.a);</span></span><br><span class="line">        <span class="comment">// 4. 会初始化类 B, 并先初始化类 A</span></span><br><span class="line">        <span class="comment">// Class.forName(&quot;com.ayu4.B&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>从字节码分析, 使用 a, b, c 这三个常量是否会导致 E 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(E.a);</span><br><span class="line">        System.out.println(E.b);</span><br><span class="line">        <span class="comment">// 会导致 E 类初始化, 因为 Integer 是包装类</span></span><br><span class="line">        System.out.println(E.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer c = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;E cinit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型应用 - 完成懒惰初始化单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LazyHolder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用getInstance方法, 才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的实现特点是:</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ul><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h2><blockquote><p>类加载器虽然只用于实现类的加载动作, 但它在Java程序中起到的作用却远超类加载阶段<br>对于任意一个类, 都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性, 每一个类加载器, 都拥有一个独立的类名称空间。这句话可以表达得更通俗一些: 比较两个类是否“相等”, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个 Class 文件, 被同一个 Java 虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等！</p></blockquote><p>以 JDK8 为例:</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为 Bootstrap, 显示为 null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>用 Bootstrap 类加载器加载类: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bootstrap F init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.ayu.F&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为需要加参数, 需要在控制台与运行: </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:. com.ayu.Load</span><br><span class="line"></span><br><span class="line">bootstrap F init</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>因为 Bootstrap ClassLoader 是用 C++ 写的, 打印 null 就说明使用了Bootstrap ClassLoader</p><ul><li>-Xbootclasspath 表示设置 bootclasspath </li><li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后 </li><li>可以用这个办法替换核心类 <ul><li><code>java -Xbootclasspath: <new bootclasspath></code></li><li><code>java -Xbootclasspath/a:<追加路径> </code></li><li><code>java -Xbootclasspath/p:<追加路径></code></li></ul></li></ul><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>如果 classpath 和 JAVA_HOME/jre/lib/ext 下有同名类, 加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了, 则不会再次加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;classpath G init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.ayu.G&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath G init</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p>再写一类 G:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ext G init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打个 jar 包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf my.jar com/ayu/G.class</span><br></pre></td></tr></table></figure><p>将 jar 包拷贝到 JAVA_HOME/jre/lib/ext</p><p>重新执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext G init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">29453</span>f44</span><br></pre></td></tr></table></figure><h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>双亲委派模式, 即调用类加载器ClassLoader 的 loadClass 方法时, 查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先查找该类是否已经被该类加载器加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp, 但它显示为null</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 看是否被启动类加载器加载过</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">//捕获异常, 但不做任何处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果还是没有找到, 先让拓展类加载器调用 findClass 方法去找到该类, 如果还是没找到, 就抛出异常</span></span><br><span class="line">                <span class="comment">// 然后让应用类加载器去找 classpath 下找该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录时间</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>我们在使用 JDBC 时, 都需要加载 Driver 驱动, 不知道你注意到没有, 不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure><p>也是可以让 <code>com.mysql.jdbc.Driver</code> 正确加载的, 你知道是怎么做的吗？<br>看一下 DriverManager 的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册驱动的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化驱动</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看一下 DriverManager 的类加载器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure><p>打印 null, 表示它的类加载器是 Bootstrap ClassLoader, 会到 JAVA_HOME/jre/lib 下搜索类, 但  JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包, 这样问题来了, 在 DriverManager 的静态代码块中, 怎么能正确加载 com.mysql.jdbc.Driver 呢？</p><p>继续看 loadInitialDrivers() 方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    drivers = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1)使用 ServiceLoader 机制加载驱动, 即 SPI</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line">    <span class="comment">// 2)使用 jdbc.drivers 定义的驱动名加载驱动</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            <span class="comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器</span></span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">            ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 2)发现它最后是使用 Class.forName 完成类的加载和初始化, 关联的是应用程序类加载器, 因此 可以顺利完成类加载 再看 1)</p><p>它就是大名鼎鼎的 Service Provider Interface (SPI) 约定如下, 在 jar 包的 META-INF/services 包下, 以接口全限定名名为文件, 文件内容是实现类名称</p><p>这样就可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);</span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来得到实现类, 体现的是 <strong>面向接口编程</strong>+<strong>解耦</strong> 的思想, 在下面一些框架中都运用了此思想:  </p><ul><li>JDBC </li><li>Servlet 初始化器 </li><li>Spring 容器 </li><li>Dubbo (对 SPI 进行了扩展) </li></ul><p>接着看 ServiceLoader.load 方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程上下文类加载器</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程上下文类加载器是当前线程使用的类加载器, 默认就是应用程序类加载器, 它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载, 具体代码在 ServiceLoader 的内部类 LazyIterator 中: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">    fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">        <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">        <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(); <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><strong>场景</strong>:</p><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现, 希望解耦时, 常用在框架设计</li><li>这些类希望予以隔离, 不同应用的同名类都可以加载, 不冲突, 常见于 tomcat 容器</li></ul><p><strong>步骤</strong>:</p><ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制, 重写 ﬁndClass 方法<br>不是重写 loadClass 方法, 否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><p><strong>破坏双亲委派模式</strong></p><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法, 在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码, 此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词: 代码热替换(Hot Swap)、模块热部署(Hot Deployment)等</li></ul></li></ul><h2 id="3-运行期优化"><a href="#3-运行期优化" class="headerlink" title="3. 运行期优化"></a>3. 运行期优化</h2><h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次:</p><ul><li>0层: 解释执行, 用解释器将字节码翻译为机器码</li><li>1层: 使用 C1 即时编译器编译执行(不带 proﬁling)</li><li>2层: 使用 C1 即时编译器编译执行(带基本的profiling)</li><li>3层: 使用 C1 即时编译器编译执行(带完全的profiling)</li><li>4层: 使用 C2 即时编译器编译执行</li></ul><blockquote><p><strong>proﬁling</strong> 是指在运行过程中收集一些程序执行状态的数据, 例如<strong>方法的调用次数</strong>, <strong>循环的 回边次数</strong>等</p></blockquote><p>即时编译器(JIT)与解释器的区别:</p><ul><li>解释器<ul><li>将字节码解释为机器码, 下次即使遇到相同的字节码, 仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码编译为机器码, 并存入 Code Cache, 下次遇到相同的代码, 直接执行, 无需再编译</li><li>根据平台类型, 生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码, 我们无需耗费时间将其编译成机器码, 而是采取解释执行的方式运行；另一方面, 对于仅占据小部分的热点代码, 我们则可以将其编译成机器码, 以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2, 总的目标是发现热点代码(hotspot名称的由来), 并优化这些热点代码。</p><p><strong>逃逸分析</strong><br>逃逸分析(Escape Analysis)简单来讲就是, Java Hotspot 虚拟机可以分析新创建对象的使用范围, 并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下: </p><ul><li><p>开启逃逸分析: -XX:+DoEscapeAnalysis</p></li><li><p>关闭逃逸分析: -XX:-DoEscapeAnalysis</p></li><li><p>显示分析结果: -XX:+PrintEscapeAnalysis</p></li><li><p>逃逸分析技术在 Java SE 6u23+ 开始支持, 并默认设置为启用状态, 可以不用额外加这个参数</p></li></ul><p>对象逃逸状态</p><p>全局逃逸(GlobalEscape)</p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程, 有以下几种场景: <ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p>参数逃逸(ArgEscape)</p><ul><li>即一个对象被作为方法参数传递或者被参数引用, 但在调用过程中不会发生全局逃逸, 这个状态是通过被调方法的字节码确定的</li></ul><p>没有逃逸</p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong><br>针对上面第三点, 当一个对象没有逃逸时, 可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong><br>我们知道线程同步锁是非常牺牲性能的, 当编译器确定当前对象只有当前线程使用, 那么就会移除该对象的同步锁<br>例如, StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的, 但大部分情况下, 它们都只是在当前线程中用到, 这样编译器就会优化移除掉这些锁操作<br>锁消除的 JVM 参数如下: </p><ul><li>开启锁消除: -XX:+EliminateLocks</li><li>关闭锁消除: -XX:-EliminateLocks<br>锁消除在 JDK8 中都是默认开启的, 并且锁消除都要建立在逃逸分析的基础上</li></ul><p><strong>标量替换</strong><br>首先要明白标量和聚合量, 基础类型和对象的引用可以理解为标量, 它们不能被进一步分解。而能被进一步分解的量就是聚合量, 比如: 对象<br>对象是聚合量, 它又可以被进一步分解成标量, 将其成员变量分解为分散的变量, 这就叫做标量替换。</p><p>这样, 如果一个对象没有发生逃逸, 那压根就不用创建它, 只会在栈或者寄存器上创建它用到的成员标量, 节省了内存空间, 也提升了应用程序性能<br>标量替换的 JVM 参数如下: </p><ul><li>开启标量替换: -XX:+EliminateAllocations</li><li>关闭标量替换: -XX:-EliminateAllocations</li><li>显示标量替换详情: -XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的, 并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong><br>当对象没有发生逃逸时, 该对象就可以通过标量替换分解成成员标量分配在栈内存中, 和方法的生命周期一致, 随着栈帧出栈时销毁, 减少了 GC 压力, 提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p><strong>内联函数</strong><br>内联函数就是在程序编译时, 编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>如果发现 square 是热点方法, 并且长度不太长时, 会进行内联, 所谓的内联就是把方法内代码拷贝粘贴到调用者的位置: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>还能够进行常量折叠(constant folding)的优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure><h4 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h4><p>创建 maven 工程:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1)</span> <span class="comment">// 预热代码, 让JIT编译器对代码进行充分优化</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1)</span> <span class="comment">// 测试轮数 5 次</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchmarkTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] elements = randomInts(<span class="number">1_000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomInts(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        Random random = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            values[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            doSum(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] local = <span class="keyword">this</span>.elements;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; local.length; i++) &#123;</span><br><span class="line">            doSum(local[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> element : elements) &#123;</span><br><span class="line">            doSum(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CompilerControl(CompilerControl.Mode.INLINE)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(BenchmarkTest.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下(每秒吞吐量, 分数越高的更好): </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark             <span class="built_in">Mode</span>  Cnt        Score        Error  Units</span><br><span class="line">BenchmarkTest.test1  thrpt    <span class="number">5</span>  <span class="number">2267054</span>.<span class="number">312</span> ± <span class="number">418537</span>.<span class="number">351</span>  ops/s</span><br><span class="line">BenchmarkTest.test2  thrpt    <span class="number">5</span>  <span class="number">2285712</span>.<span class="number">531</span> ± <span class="number">172019</span>.<span class="number">809</span>  ops/s</span><br><span class="line">BenchmarkTest.test3  thrpt    <span class="number">5</span>  <span class="number">2327367</span>.<span class="number">824</span> ± <span class="number">238476</span>.<span class="number">579</span>  ops/s</span><br></pre></td></tr></table></figure><p>接下来禁用 doSum 方法内联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span>  <span class="comment">// 控制调用方法时是不是要进行方法内联；不允许内联</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">    sum += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下(得分明显下降):</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark             <span class="built_in">Mode</span>  Cnt       Score       Error  Units</span><br><span class="line">BenchmarkTest.test1  thrpt    <span class="number">5</span>  <span class="number">288147</span>.<span class="number">413</span> ± <span class="number">67562</span>.<span class="number">733</span>  ops/s</span><br><span class="line">BenchmarkTest.test2  thrpt    <span class="number">5</span>  <span class="number">278199</span>.<span class="number">128</span> ± <span class="number">32071</span>.<span class="number">212</span>  ops/s</span><br><span class="line">BenchmarkTest.test3  thrpt    <span class="number">5</span>  <span class="number">301989</span>.<span class="number">359</span> ± <span class="number">23505</span>.<span class="number">462</span>  ops/s</span><br></pre></td></tr></table></figure><p>分析:</p><p>在刚才的示例中, doSum 方法是否内联会影响 elements 成员变量读取的优化</p><p>如果 doSum 方法内联了, 刚才的 test1 方法会被优化成下面的样子(伪代码):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123; <span class="comment">// 后续 999 次 求长度 &lt;- local</span></span><br><span class="line">    sum += elements[i]; <span class="comment">// 1000 次取下标 i 的元素 &lt;- local</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以节省 1999 次 Field 读取操作, 但如果 doSum 方法没有内联, 则不会进行上面的优化</p><blockquote><p>本地变量访问长度、数据时, 不需要去 class 元数据那里找, 在本地变量就可以找到了, 相当于手动优化。但是方法内联是由虚拟机来优化的。所以, test3 方法与test2 方法是等价的, test1 方法是运行期间优化了, test2 方法是手动优化了,  test3 方法的 foreach 是编译期间优化了。</p></blockquote><h3 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h3><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method foo = ReflectTest.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">            foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 (共16) 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// inflationThreshold 膨胀阈值, 默认 15</span></span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; </span><br><span class="line">            !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// 使用 ASM 动态生成的新实现代替本地实现, 速度较本地实现快 20 倍左右</span></span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator())</span><br><span class="line">                .generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), </span><br><span class="line">                                <span class="keyword">this</span>.method.getName(), </span><br><span class="line">                                <span class="keyword">this</span>.method.getParameterTypes(), </span><br><span class="line">                                <span class="keyword">this</span>.method.getReturnType(), </span><br><span class="line">                                <span class="keyword">this</span>.method.getExceptionTypes(), </span><br><span class="line">                                <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地实现</span></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面, 我们从源码的角度来分析反射底层是如何实现优化的: </p><ol><li><p>先在 foo.invoke(null) 处打上断点, debug 模式启动</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/1.png" alt="1"></p></li><li><p>点击进去 invoke() 方法实现, 找到 MethodAccessor 的实现类, 在 invoke() 方法上打上新断点</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/2.png" alt="2"></p></li><li><p>通过 Idea 查看 Evaluate, 来查看反射多次调用后, 由 JVM 动态生成的实现类名 - GeneratedMethodAccessor1, 这个名字在后面需要用的。且此时 this.numInvocations 已经到了 16了</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/3.png" alt="3"></p></li></ol><p>接下来, 我们通过阿里的 <a href="https://github.com/alibaba/arthas/releases">arthas</a> 工具来进行调试:</p><ol><li><p><strong>run</strong> 模式运行代码, 会停在 <code>System.in.read()</code></p></li><li><p>运行 arthas: <code>java -jar arthas-boot.jar</code></p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%90%AF%E5%8A%A8arthas.png" alt="启动arthas"></p></li><li><p>通过 <code>jad sun.reflect.GeneratedMethodAccessor1</code> 将 JVM 对反射优化后的类的字节码反编译出来</p><p><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="反编译"></p></li></ol><blockquote><p>注意：</p><p>通过查看 ReflectionFactory 源码可知</p><ul><li>sun.reflect.noInflation 可以用来禁用膨胀(直接生成 GeneratedMethodAccessor1, 但首次生成比较耗时, 如果仅反射调用一次, 不划算)</li><li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类加载阶段&quot;&gt;&lt;a href=&quot;#1-类加载阶段&quot; class=&quot;headerlink&quot; title=&quot;1. 类加载阶段&quot;&gt;&lt;/a&gt;1. 类加载阶段&lt;/h2&gt;&lt;h3 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之字节码技术</title>
    <link href="http://www.ayu.link/2022/05/03/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.ayu.link/2022/05/03/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/</id>
    <published>2022-05-03T13:35:21.000Z</published>
    <updated>2022-05-03T13:57:51.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节码技术"><a href="#字节码技术" class="headerlink" title="字节码技术"></a>字节码技术</h1><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/JVM%E6%9E%84%E9%80%A0.png" alt="JVM构造"></p><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h2><p>一个简单的HelloWorld.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>javac -parameters -d . HellowWorld.java</code>编译为 HelloWorld.class 后是这个样子的:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000</span> ca fe ba be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">23</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">15</span> <span class="number">09</span> </span><br><span class="line"><span class="number">0000020</span> <span class="number">00</span> <span class="number">16</span> <span class="number">00</span> <span class="number">17</span> <span class="number">08</span> <span class="number">00</span> <span class="number">18</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">19</span> <span class="number">00</span> <span class="number">1</span>a <span class="number">07</span> <span class="number">00</span> <span class="number">1</span>b <span class="number">07</span> </span><br><span class="line"><span class="number">0000040</span> <span class="number">00</span> <span class="number">1</span>c <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> <span class="number">3</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> </span><br><span class="line"><span class="number">0000060</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6</span>f <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>f <span class="number">4</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">65</span> <span class="number">4</span>e </span><br><span class="line"><span class="number">0000100</span> <span class="number">75</span> <span class="number">6</span>d <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">12</span> <span class="number">4</span>c <span class="number">6</span>f <span class="number">63</span> </span><br><span class="line"><span class="number">0000120</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">56</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000140</span> <span class="number">00</span> <span class="number">04</span> <span class="number">74</span> <span class="number">68</span> <span class="number">69</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>d <span class="number">4</span>c <span class="number">63</span> <span class="number">6</span>e <span class="number">2</span>f <span class="number">69</span> <span class="number">74</span> <span class="number">63</span> </span><br><span class="line"><span class="number">0000160</span> <span class="number">61</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2</span>f <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2</span>f <span class="number">74</span> <span class="number">35</span> <span class="number">2</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f </span><br><span class="line"><span class="number">0000200</span> <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">6</span>d <span class="number">61</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">16</span> </span><br><span class="line"><span class="number">0000220</span> <span class="number">28</span> <span class="number">5</span>b <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> </span><br><span class="line"><span class="number">0000240</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">61</span> <span class="number">72</span> <span class="number">67</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> </span><br><span class="line"><span class="number">0000260</span> <span class="number">5</span>b <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">69</span> </span><br><span class="line"><span class="number">0000300</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">4</span>d <span class="number">65</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6</span>f <span class="number">64</span> <span class="number">50</span> <span class="number">61</span> <span class="number">72</span> <span class="number">61</span> </span><br><span class="line"><span class="number">0000320</span> <span class="number">6</span>d <span class="number">65</span> <span class="number">74</span> <span class="number">65</span> <span class="number">72</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">53</span> <span class="number">6</span>f <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> </span><br><span class="line"><span class="number">0000340</span> <span class="number">69</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span></span><br><span class="line"><span class="number">0000360</span> <span class="number">2</span>e <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> <span class="number">07</span> <span class="number">00</span> <span class="number">1</span>d <span class="number">0</span>c <span class="number">00</span> <span class="number">1</span>e </span><br><span class="line"><span class="number">0000400</span> <span class="number">00</span> <span class="number">1</span>f <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>b <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">20</span> <span class="number">77</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> </span><br><span class="line"><span class="number">0000420</span> <span class="number">07</span> <span class="number">00</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">22</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>b <span class="number">63</span> <span class="number">6</span>e <span class="number">2</span>f <span class="number">69</span> <span class="number">74</span> </span><br><span class="line"><span class="number">0000440</span> <span class="number">63</span> <span class="number">61</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2</span>f <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2</span>f <span class="number">74</span> <span class="number">35</span> <span class="number">2</span>f <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c </span><br><span class="line"><span class="number">0000460</span> <span class="number">6</span>f <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> </span><br><span class="line"><span class="number">0000500</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">4</span>f <span class="number">62</span> <span class="number">6</span>a <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> </span><br><span class="line"><span class="number">0000520</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">79</span> <span class="number">73</span> <span class="number">74</span> <span class="number">65</span> <span class="number">6</span>d <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">6</span>f </span><br><span class="line"><span class="number">0000540</span> <span class="number">75</span> <span class="number">74</span> <span class="number">01</span> <span class="number">00</span> <span class="number">15</span> <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">69</span> <span class="number">6</span>f <span class="number">2</span>f <span class="number">50</span> <span class="number">72</span> </span><br><span class="line"><span class="number">0000560</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">6</span>d <span class="number">3</span>b <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> </span><br><span class="line"><span class="number">0000600</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">69</span> <span class="number">6</span>f <span class="number">2</span>f <span class="number">50</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">6</span>d </span><br><span class="line"><span class="number">0000620</span> <span class="number">01</span> <span class="number">00</span> <span class="number">07</span> <span class="number">70</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">74</span> <span class="number">6</span>c <span class="number">6</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">15</span> <span class="number">28</span> <span class="number">4</span>c <span class="number">6</span>a </span><br><span class="line"><span class="number">0000640</span> <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2</span>f <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2</span>f <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3</span>b </span><br><span class="line"><span class="number">0000660</span> <span class="number">29</span> <span class="number">56</span> <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000700</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2</span>f <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> </span><br><span class="line"><span class="number">0000720</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">2</span>a b7 <span class="number">00</span> <span class="number">01</span> b1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> </span><br><span class="line"><span class="number">0000740</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">0</span>b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> </span><br><span class="line"><span class="number">0000760</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">0</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">0</span>e <span class="number">00</span> </span><br><span class="line"><span class="number">0001000</span> <span class="number">0</span>f <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">37</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001020</span> <span class="number">09</span> b2 <span class="number">00</span> <span class="number">02</span> <span class="number">12</span> <span class="number">03</span> b6 <span class="number">00</span> <span class="number">04</span> b1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">0</span>a </span><br><span class="line"><span class="number">0001040</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">0</span>b </span><br><span class="line"><span class="number">0001060</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">09</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001100</span> <span class="number">00</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">13</span> <span class="number">00</span> </span><br><span class="line"><span class="number">0001120</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><p>根据JVM规范, 类文件结构如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4    magic</span><br><span class="line">    u2             minor_version;    </span><br><span class="line">    u2             major_version;    </span><br><span class="line">    u2             constant_pool_count;    </span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];    </span><br><span class="line">    u2             access_flags;    </span><br><span class="line">    u2             this_class;    </span><br><span class="line">    u2             super_class;   </span><br><span class="line">    u2             interfaces_count;    </span><br><span class="line">    u2             interfaces[interfaces_count];   </span><br><span class="line">    u2             fields_count;    </span><br><span class="line">    field_info     fields[fields_count];   </span><br><span class="line">    u2             methods_count;    </span><br><span class="line">    method_info    methods[methods_count];    </span><br><span class="line">    u2             attributes_count;    </span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>u4 magic<br>对应字节码文件的 0~3 个字节, 表示它是否是一个Java的class文件<br>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>u2 minor_version;<br>u2 major_version;<br>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09<br>00 00 00 34 : 34H(16进制) = 52(10进制), 表示是JDK8</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td></tr></tbody></table><p>8-9 字节, 表示常量池长度, 00 23 (35) 表示常量池有 #1-#34项, 注意 #0 项不计入, 也没有值<br>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p><p>第#1项 0a (10) 表示一个 Method 信息, 00 06 (6) 和 00 15 (21) 表示它引用了常量池中 #6 和 #21项来获得这个方法的<strong>所属类</strong>和<strong>方法名</strong><br>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a 00 06 00 15</strong> 09</p><p>第#2项 09 (9) 表示一个 Field 信息, 00 16 (22) 和 00 17 (23) 表示它引用了常量池中 #22 和 # 23 项 来获得这个成员变量的<strong>所属类</strong>和<strong>成员变量名</strong><br>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong><br>0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 1a 07 00 1b 07</p><p>第#3项 08 (8) 表示一个字符串常量名称, 00 18 (24) 表示它引用了常量池中 #24 项<br>0000020 00 16 00 17 <strong>08 00 18</strong> 0a 00 19 00 1a 07 00 1b 07 </p><p>第#4项 0a (10) 表示一个 Method 信息, 00 19 (25) 和 00 1a (26) 表示它引用了常量池中 #25 和 #26 项来获得这个方法的<strong>所属类</strong>和<strong>方法名</strong><br>0000020 00 16 00 17 08 00 18 <strong>0a 00 19 00 1a</strong> 07 00 1b 07 </p><p>第#5项 07 (7) 表示一个 Class 信息, 00 1b (27) 表示它引用了常量池中 #27 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <strong>07 00 1b</strong> 07 </p><p>第#6项 07 (7) 表示一个 Class 信息, 00 1c (28) 表示它引用了常量池中 #28 项<br>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <strong>07</strong><br>0000040 <strong>00 1c</strong> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </p><p>第#7项 01 (1) 表示一个 utf8 串, 00 06 (6) 表示长度, 3c 69 6e 69 74 3e 是<code><init></code><br>0000040 00 1c 01 <strong>00 06 3c 69 6e 69 74 3e</strong> 01 00 03 28 29 </p><p>第#8项 01 (1) 表示一个 utf8 串, 00 03 (3) 表示长度, 28 29 56 是 <code>()V</code> 其实就是表示无参、无返回值<br>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <strong>01 00 03 28 29</strong><br>0000060 <strong>56</strong> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </p><p>第#9项 01 (1) 表示一个 utf8 串, 00 04 (4) 表示长度, 43 6f 64 65 是<strong>Code</strong><br>0000060 56 <strong>01 00 04 43 6f 64 65</strong> 01 00 0f 4c 69 6e 65 4e </p><p>第#10项 01 (1) 表示一个 utf8 串, 00 0f (15) 表示长度, 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是<strong>LineNumberTable</strong>(方法行号表)<br>0000060 56 01 00 04 43 6f 64 65 <strong>01 00 0f 4c 69 6e 65 4e</strong><br>0000100 <strong>75 6d 62 65 72 54 61 62 6c 65</strong> 01 00 12 4c 6f 63 </p><p>第#11项 01 (1) 表示一个 utf8 串, 00 12 (18) 表示长度, 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 是<strong>LocalVariableTable</strong>(本地变量表)<br>0000100 75 6d 62 65 72 54 61 62 6c 65 <strong>01 00 12 4c 6f 63</strong><br>0000120 <strong>61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65</strong> 01 </p><p>第#12项 01 (1) 表示一个 utf8 串, 00 04 (4) 表示长度, 74 68 69 73 是<code>this</code><br>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <strong>01</strong><br>0000140 <strong>00 04 74 68 69 73</strong> 01 00 1d 4c 63 6e 2f 69 74 63 </p><p>第#13项 01(1) 表示一个 utf8 串, 00 1d (29) 表示长度, 是<strong>类型</strong><br>0000140 00 04 74 68 69 73 <strong>01 00 1d 4c 63 6e 2f 69 74 63</strong><br>0000160 <strong>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</strong><br>0000200 <strong>57 6f 72 6c 64 3b</strong> 01 00 04 6d 61 69 6e 01 00 16 </p><p>第#14项 01 (1) 表示一个 utf8 串, 00 04 (4) 表示长度, 74 68 69 73 <code>main</code><br>0000200 57 6f 72 6c 64 3b <strong>01 00 04 6d 61 69 6e</strong> 01 00 16 </p><p>第#15项 01 (1) 表示一个 utf8 串, 00 16 (22) 表示长度, 是<code>([Ljava/lang/String;)V</code>其实就是参数为 字符串数组, 无返回值<br>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e <strong>01 00 16</strong><br>0000220 <strong>28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</strong><br>0000240 <strong>69 6e 67 3b 29 56</strong> 01 00 04 61 72 67 73 01 00 13 </p><p>第#16项 01 (1) 表示一个 utf8 串, 00 04 (4) 表示长度, 是<code>args</code><br>0000240 69 6e 67 3b 29 56 <strong>01 00 04 61 72 67 73</strong> 01 00 13 </p><p>第#17项 01 (1) 表示一个 utf8 串, 00 13 (19) 表示长度, 是<code>[Ljava/lang/String;</code><br>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 <strong>01 00 13</strong><br>0000260 <strong>5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</strong><br>0000300 <strong>6e 67 3b</strong> 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </p><p>第#18项 01 (1) 表示一个 utf8 串, 00 10 (16) 表示长度, 是<strong>MethodParameters</strong><br>0000300 6e 67 3b <strong>01 00 10 4d 65 74 68 6f 64 50 61 72 61</strong><br>0000320 <strong>6d 65 74 65 72 73</strong> 01 00 0a 53 6f 75 72 63 65 46 </p><p>第#19项 01 (1) 表示一个 utf8 串, 00 0a (10) 表示长度, 是<strong>SourceFile</strong><br>0000320 6d 65 74 65 72 73 <strong>01 00 0a 53 6f 75 72 63 65 46</strong><br>0000340 <strong>69 6c 65</strong> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 </p><p>第#20项 01 (1) 表示一个 utf8 串, 00 0f (15) 表示长度, 是<code>HelloWorld.java</code><br>0000340 69 6c 65 <strong>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</strong><br>0000360 <strong>2e 6a 61 76 61</strong> 0c 00 07 00 08 07 00 1d 0c 00 1e </p><p>第#21项 0c 表示一个<strong>名</strong>+<strong>类型</strong>, 00 07 (7) 和 00 08 (8) 引用了常量池中 #7 #8 两项<br>0000360 2e 6a 61 76 61 0c <strong>00 07 00 08</strong> 07 00 1d 0c 00 1e </p><p>第#22项 07 (7) 表示一个 Class 信息, 00 1d (29) 引用了常量池中 #29 项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 <strong>07 00 1d</strong> 0c 00 1e </p><p>第#23项 0c (12) 表示一个<strong>名</strong>+<strong>类型</strong>, 00 1e(30) 和 00 1f (31)引用了常量池中 #30 #31 两项<br>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <strong>0c 00 1e</strong><br>0000400 <strong>00 1f</strong> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </p><p>第#24项 01 (1) 表示一个 utf8 串, 00 0b (11) 表示长度, 是<code>hello world</code><br>0000400 00 1f <strong>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</strong> </p><p>第#25项 07 (7) 表示一个 Class 信息, 00 20 (32) 引用了常量池中 #32 项<br>0000420 <strong>07 00 20</strong> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </p><p>第#26项 0c (12) 表示一个<strong>名</strong>+<strong>类型</strong>, 00 21 (33) 和 00 22 (34)引用了常量池中 #33 #34 两项<br>0000420 07 00 20 <strong>0c 00 21 00 22</strong> 01 00 1b 63 6e 2f 69 74 </p><p>第#27项 01 (1) 表示一个 utf8 串, 00 1b (27) 表示长度, 是<strong>类的权限定名</strong><br>0000420 07 00 20 0c 00 21 00 22 <strong>01 00 1b 63 6e 2f 69 74</strong><br>0000440 <strong>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</strong><br>0000460 <strong>6f 57 6f 72 6c 64</strong> 01 00 10 6a 61 76 61 2f 6c 61 </p><p>第#28项 01 (1) 表示一个 utf8 串, 00 10 (16) 表示长度, 是<code>java.lang.Object</code><br>0000460 6f 57 6f 72 6c 64 01 <strong>00 10 6a 61 76 61 2f 6c 61</strong><br>0000500 <strong>6e 67 2f 4f 62 6a 65 63 74</strong> 01 00 10 6a 61 76 61 </p><p>第#29项 01 (1) 表示一个 utf8 串, 00 10 (16) 表示长度, 是<code>java.lang.System</code><br>0000500 6e 67 2f 4f 62 6a 65 63 74 <strong>01 00 10 6a 61 76 61</strong><br>0000520 <strong>2f 6c 61 6e 67 2f 53 79 73 74 65 6d</strong> 01 00 03 6f </p><p>第#30项 01 (1) 表示一个 utf8 串, 00 03 (3) 表示长度, 是<code>out</code><br>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d <strong>01 00 03 6f</strong><br>0000540 <strong>75 74</strong> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p><p>第#31项 01 (1) 表示一个 utf8 串, 00 15 (21) 表示长度, 是<code>Ljava.io.PrintStream</code><br>0000540 75 74 <strong>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</strong><br>0000560 <strong>69 6e 74 53 74 72 65 61 6d 3b</strong> 01 00 13 6a 61 76 </p><p>第#32项 01 (1) 表示一个 utf8 串, 00 13 (19) 表示长度, 是<code>java.io.PrintStream</code><br>0000560 69 6e 74 53 74 72 65 61 6d 3b <strong>01 00 13 6a 61 76</strong><br>0000600 <strong>61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</strong> </p><p>第#33项 01 (1) 表示一个 utf8 串, 00 07 表示长度, 是<code>println</code><br>0000620 <strong>01 00 07 70 72 69 6e 74 6c 6e</strong> 01 00 15 28 4c 6a </p><p>第#34项 01 (1) 表示一个 utf8 串, 00 15 (21) 表示长度, 是<code>(Ljava/lang/String;)V</code><br>0000620 01 00 07 70 72 69 6e 74 6c 6e <strong>01 00 15 28 4c 6a</strong><br>0000640 <strong>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</strong><br>0000660 <strong>29 56</strong> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h3><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared public ; may be accessed from outside its  package.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared final ; no subclasses allowed.</td></tr><tr><td><code>ACC_SUPER</code></td><td>0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td><code>ACC_INTERFACE</code></td><td>0x0200</td><td>Is an interface, not a class.</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>Declared abstract ; must not be instantiated.</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td><code>ACC_ANNOTATION</code></td><td>0x2000</td><td>Declared as an annotation type.</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>Declared as an enum type.</td></tr></tbody></table><p>00 21 表示该 class 是一个类, 公共的 |<br>0000660 29 56 <strong>00 21</strong> 00 05 00 06 00 00 00 00 00 02 00 01</p><p>00 05 表示根据常量池中 #5 找到本类全限定名<br>0000660 29 56 00 21 <strong>00 05</strong> 00 06 00 00 00 00 00 02 00 01</p><p>00 06 表示根据常量池中 #6 找到父类全限定名<br>0000660 29 56 00 21 00 05 <strong>00 06</strong> 00 00 00 00 00 02 00 01 </p><p>00 00 表示接口的数量, 本类为 0<br>0000660 29 56 00 21 00 05 00 06 <strong>00 00</strong> 00 00 00 02 00 01</p><h3 id="Field-信息"><a href="#Field-信息" class="headerlink" title="Field 信息"></a>Field 信息</h3><table><thead><tr><th>Filed Type</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>LClassName;</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><p>00 00 表示成员变量数量, 本类为 0<br>0000660 29 56 00 21 00 05 00 06 00 00 <strong>00 00</strong> 00 02 00 01</p><h3 id="Method-信息"><a href="#Method-信息" class="headerlink" title="Method 信息"></a>Method 信息</h3><p>00 02 表示方法数量, 本类为 2<br>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <strong>00 02</strong> 00 01</p><p>一个方法由 访问修饰符, 名称, 参数描述, 方法属性数量, 方法属性组成</p><p>具体分析参考文献<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">&lt;(￣︶￣)↗[GO!]</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h2><p>参考文档<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">&lt;(￣︶￣)↗[GO!]</a></p><h3 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h3><p>Java 中提供了 javap 工具来反编译 class 文件</p><p><code>javap -v HelloWorld.class</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JVM/JVM_Study/out/production/JVM_Study/com/ayu3/HelloWorld.class</span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">4</span>-<span class="number">28</span>; size <span class="number">551</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">98</span>a3ae1e037cc97cf9c0a159278e0d47</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class com.ayu3.HelloWorld</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line"><span class="function">  flags: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="function"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="function">   #1 = <span class="title">Methodref</span>          #6.#20         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #2 = <span class="title">Fieldref</span>           #21.#22        // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">   #3 = <span class="title">String</span>             #23            // <span class="title">Hello</span> <span class="title">World</span></span></span><br><span class="line"><span class="function">   #4 = <span class="title">Methodref</span>          #24.#25        // <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">   #5 = <span class="title">Class</span>              #26            // <span class="title">com</span>/<span class="title">ayu3</span>/<span class="title">HelloWorld</span></span></span><br><span class="line"><span class="function">   #6 = <span class="title">Class</span>              #27            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">   #7 = <span class="title">Utf8</span>               &lt;<span class="title">init</span>&gt;</span></span><br><span class="line"><span class="function">   #8 = <span class="title">Utf8</span>               ()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #9 = <span class="title">Utf8</span>               <span class="title">Code</span></span></span><br><span class="line"><span class="function">  #10 = <span class="title">Utf8</span>               <span class="title">LineNumberTable</span></span></span><br><span class="line"><span class="function">  #11 = <span class="title">Utf8</span>               <span class="title">LocalVariableTable</span></span></span><br><span class="line"><span class="function">  #12 = <span class="title">Utf8</span>               <span class="title">this</span></span></span><br><span class="line"><span class="function">  #13 = <span class="title">Utf8</span>               <span class="title">Lcom</span>/<span class="title">ayu3</span>/<span class="title">HelloWorld</span>;</span></span><br><span class="line"><span class="function">  #14 = <span class="title">Utf8</span>               <span class="title">main</span></span></span><br><span class="line"><span class="function">  #15 = <span class="title">Utf8</span>               ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">  #16 = <span class="title">Utf8</span>               <span class="title">args</span></span></span><br><span class="line"><span class="function">  #17 = <span class="title">Utf8</span>               [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">  #18 = <span class="title">Utf8</span>               <span class="title">SourceFile</span></span></span><br><span class="line"><span class="function">  #19 = <span class="title">Utf8</span>               <span class="title">HelloWorld.java</span></span></span><br><span class="line"><span class="function">  #20 = <span class="title">NameAndType</span>        #7:#8          // &quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">  #21 = <span class="title">Class</span>              #28            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System</span></span></span><br><span class="line"><span class="function">  #22 = <span class="title">NameAndType</span>        #29:#30        // <span class="title">out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">  #23 = <span class="title">Utf8</span>               <span class="title">Hello</span> <span class="title">World</span></span></span><br><span class="line"><span class="function">  #24 = <span class="title">Class</span>              #31            // <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream</span></span></span><br><span class="line"><span class="function">  #25 = <span class="title">NameAndType</span>        #32:#33        // <span class="title">println</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">  #26 = <span class="title">Utf8</span>               <span class="title">com</span>/<span class="title">ayu3</span>/<span class="title">HelloWorld</span></span></span><br><span class="line"><span class="function">  #27 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">  #28 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System</span></span></span><br><span class="line"><span class="function">  #29 = <span class="title">Utf8</span>               <span class="title">out</span></span></span><br><span class="line"><span class="function">  #30 = <span class="title">Utf8</span>               <span class="title">Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">  #31 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream</span></span></span><br><span class="line"><span class="function">  #32 = <span class="title">Utf8</span>               <span class="title">println</span></span></span><br><span class="line"><span class="function">  #33 = <span class="title">Utf8</span>               (<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">com.ayu3.HelloWorld</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">         4: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 8: 0</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       5     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">ayu3</span>/<span class="title">HelloWorld</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span>(<span class="title">java.lang.String</span>[]);</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_STATIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=2, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">getstatic</span>     #2                  // <span class="title">Field</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">         3: <span class="title">ldc</span>           #3                  // <span class="title">String</span> <span class="title">Hello</span> <span class="title">World</span></span></span><br><span class="line"><span class="function">         5: <span class="title">invokevirtual</span> #4                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">         8: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 11: 8</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       9     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">SourceFile</span>: &quot;<span class="title">HelloWorld.java</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h3><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译后的字节码文件"><a href="#编译后的字节码文件" class="headerlink" title="编译后的字节码文件"></a>编译后的字节码文件</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JVM/JVM_Study/out/production/JVM_Study/com/ayu3/Demo.class</span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">5</span>-<span class="number">2</span>; size <span class="number">592</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">009</span>af49aba8415c333bdf2ef251bc500</span><br><span class="line">  Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class com.ayu3.Demo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line"><span class="function">  flags: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="function"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="function">   #1 = <span class="title">Methodref</span>          #7.#25         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #2 = <span class="title">Class</span>              #26            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Short</span></span></span><br><span class="line"><span class="function">   #3 = <span class="title">Integer</span>            32768</span></span><br><span class="line"><span class="function">   #4 = <span class="title">Fieldref</span>           #27.#28        // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">   #5 = <span class="title">Methodref</span>          #29.#30        // <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">   #6 = <span class="title">Class</span>              #31            // <span class="title">com</span>/<span class="title">ayu3</span>/<span class="title">Demo</span></span></span><br><span class="line"><span class="function">   #7 = <span class="title">Class</span>              #32            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">   #8 = <span class="title">Utf8</span>               &lt;<span class="title">init</span>&gt;</span></span><br><span class="line"><span class="function">   #9 = <span class="title">Utf8</span>               ()<span class="title">V</span></span></span><br><span class="line"><span class="function">  #10 = <span class="title">Utf8</span>               <span class="title">Code</span></span></span><br><span class="line"><span class="function">  #11 = <span class="title">Utf8</span>               <span class="title">LineNumberTable</span></span></span><br><span class="line"><span class="function">  #12 = <span class="title">Utf8</span>               <span class="title">LocalVariableTable</span></span></span><br><span class="line"><span class="function">  #13 = <span class="title">Utf8</span>               <span class="title">this</span></span></span><br><span class="line"><span class="function">  #14 = <span class="title">Utf8</span>               <span class="title">Lcom</span>/<span class="title">ayu3</span>/<span class="title">Demo</span>;</span></span><br><span class="line"><span class="function">  #15 = <span class="title">Utf8</span>               <span class="title">main</span></span></span><br><span class="line"><span class="function">  #16 = <span class="title">Utf8</span>               ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">  #17 = <span class="title">Utf8</span>               <span class="title">args</span></span></span><br><span class="line"><span class="function">  #18 = <span class="title">Utf8</span>               [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">  #19 = <span class="title">Utf8</span>               <span class="title">a</span></span></span><br><span class="line"><span class="function">  #20 = <span class="title">Utf8</span>               <span class="title">I</span></span></span><br><span class="line"><span class="function">  #21 = <span class="title">Utf8</span>               <span class="title">b</span></span></span><br><span class="line"><span class="function">  #22 = <span class="title">Utf8</span>               <span class="title">c</span></span></span><br><span class="line"><span class="function">  #23 = <span class="title">Utf8</span>               <span class="title">SourceFile</span></span></span><br><span class="line"><span class="function">  #24 = <span class="title">Utf8</span>               <span class="title">Demo.java</span></span></span><br><span class="line"><span class="function">  #25 = <span class="title">NameAndType</span>        #8:#9          // &quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">  #26 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Short</span></span></span><br><span class="line"><span class="function">  #27 = <span class="title">Class</span>              #33            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System</span></span></span><br><span class="line"><span class="function">  #28 = <span class="title">NameAndType</span>        #34:#35        // <span class="title">out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">  #29 = <span class="title">Class</span>              #36            // <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream</span></span></span><br><span class="line"><span class="function">  #30 = <span class="title">NameAndType</span>        #37:#38        // <span class="title">println</span>:(<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">  #31 = <span class="title">Utf8</span>               <span class="title">com</span>/<span class="title">ayu3</span>/<span class="title">Demo</span></span></span><br><span class="line"><span class="function">  #32 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">  #33 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System</span></span></span><br><span class="line"><span class="function">  #34 = <span class="title">Utf8</span>               <span class="title">out</span></span></span><br><span class="line"><span class="function">  #35 = <span class="title">Utf8</span>               <span class="title">Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">  #36 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream</span></span></span><br><span class="line"><span class="function">  #37 = <span class="title">Utf8</span>               <span class="title">println</span></span></span><br><span class="line"><span class="function">  #38 = <span class="title">Utf8</span>               (<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">com.ayu3.Demo</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">         4: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 8: 0</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       5     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">ayu3</span>/<span class="title">Demo</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span>(<span class="title">java.lang.String</span>[]);</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_STATIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=2, <span class="title">locals</span>=4, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">         2: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         3: <span class="title">ldc</span>           #3                  // <span class="title">int</span> 32768</span></span><br><span class="line"><span class="function">         5: <span class="title">istore_2</span></span></span><br><span class="line"><span class="function">         6: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">         7: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">         8: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">         9: <span class="title">istore_3</span></span></span><br><span class="line"><span class="function">        10: <span class="title">getstatic</span>     #4                  // <span class="title">Field</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">        13: <span class="title">iload_3</span></span></span><br><span class="line"><span class="function">        14: <span class="title">invokevirtual</span> #5                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">        17: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 11: 3</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 12: 6</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 13: 10</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 17</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0      18     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">            3      15     1     <span class="title">a</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">            6      12     2     <span class="title">b</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">           10       8     3     <span class="title">c</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">SourceFile</span>: &quot;<span class="title">Demo.java</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="常量池载入运行时常量池"><a href="#常量池载入运行时常量池" class="headerlink" title="常量池载入运行时常量池"></a>常量池载入运行时常量池</h3><p>常量池也属于方法区, 只不过这里单独提出来了</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%BD%BD%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="载入运行时常量池"></p><h3 id="方法字节码载入方法区"><a href="#方法字节码载入方法区" class="headerlink" title="方法字节码载入方法区"></a>方法字节码载入方法区</h3><p>(stack=2, locals=4) 对应操作数栈有 2 个空间(每个空间 4 个字节), 局部变量表中有 4 个槽位</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/%E8%BD%BD%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="载入方法区"></p><h3 id="main-线程开始运行-分配栈帧内存"><a href="#main-线程开始运行-分配栈帧内存" class="headerlink" title="main 线程开始运行, 分配栈帧内存"></a>main 线程开始运行, 分配栈帧内存</h3><p>(stack=2, locals=4)</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E9%85%8D%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98.png" alt="分配栈帧内存"></p><h3 id="执行引擎开始执行字节码"><a href="#执行引擎开始执行字节码" class="headerlink" title="执行引擎开始执行字节码"></a>执行引擎开始执行字节码</h3><p><strong>bipush 10</strong></p><ul><li>将一个 byte 压入操作数栈(其长度会补齐 4 个字节), 类似的指令还有</li><li>sipush 将一个 short 压入操作数栈(其长度会补齐 4 个字节)</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈(分两次压入, 因为 long 是 8 个字节)</li><li>这里小的数字都是和字节码指令存在一起, 超过 short 范围的数字存入了常量池</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/bipush10.png" alt="bipush10"></p><p><strong>istore 1</strong></p><ul><li>将操作数栈栈顶元素弹出, 放入局部变量表的 slot 1 中</li><li>对应代码中的 a = 10</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_1-1.png" alt="istore_1-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_1-2.png" alt="istore_1-2"></p><p><strong>ldc #3</strong></p><ul><li>读取运行时常量池中 #3 , 即 32768 (超过 short 最大值范围的数会被放到运行时常量池中), 将其加载到操作数栈中</li><li>注意: Short.MAX_VALUE 是 32767, 所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/ldc3.png" alt="ldc#3"></p><p><strong>istore 2</strong></p><ul><li>将操作数栈中的元素弹出, 放到局部变量表的 2 号位置</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_2-1.png" alt="istore_2-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_2-2.png" alt="istore_2-2"></p><p><strong>iload1 iload2</strong></p><ul><li>将局部变量表中 1 号位置和 2 号位置的元素放入操作数栈中</li><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iload_1.png" alt="iload_1"><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iload_2.png" alt="iload_2"></p><p><strong>iadd</strong></p><ul><li>将操作数栈中的两个元素弹出栈并相加, 结果在压入操作数栈中</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iadd-1.png" alt="iadd-1"><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iadd-2.png" alt="iadd-2"></p><p><strong>istore 3</strong></p><ul><li>将操作数栈中的元素弹出, 放入局部变量表的3号位置</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_3-1.png" alt="istore_3-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/istore_3-2.png" alt="istore_3-1"></p><p><strong>getstatic #4</strong></p><ul><li><p>在运行时常量池中找到 #4 , 发现是一个对象</p></li><li><p>在堆内存中找到该对象, 并将其引用放入操作数栈中</p></li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/getstatic4-1.png"><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/getstatic4-2.png" alt="getstatic4-2"></p><p><strong>iload 3</strong></p><ul><li>将局部变量表中 3 号位置的元素压入操作数栈中</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iload_3-1.png" alt="iload_3-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/iload_3-2.png" alt="iload_3-1"></p><p><strong>invokevirtual #5</strong></p><ul><li>找到常量池 #5 项</li><li>定位到方法区 java/io/PrintStream.println:(I)V 方法</li><li>生成新的栈帧(分配 locals、stack等)</li><li>传递参数, 执行新栈帧中的字节码</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/invokevirtual5-1.png" alt="invokevirtual5-1"></p><ul><li>执行完毕, 弹出栈帧</li><li>清除 main 操作数栈内容</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/invokevirtual5-2.png" alt="invokevirtual5-2"></p><p><strong>return</strong></p><ul><li>完成 main 方法调用, 弹出 main 栈帧</li><li>程序结束</li></ul><h3 id="分析a"><a href="#分析a" class="headerlink" title="分析a++"></a>分析a++</h3><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.ayu3.Demo();</span><br><span class="line"><span class="function">    descriptor: ()<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>.&quot;&lt;<span class="title">init</span>&gt;&quot;:()<span class="title">V</span></span></span><br><span class="line"><span class="function">         4: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 8: 0</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       5     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">ayu3</span>/<span class="title">Demo</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span>(<span class="title">java.lang.String</span>[]);</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_STATIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=2, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">         2: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         3: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">         4: <span class="title">iinc</span>          1, 1</span></span><br><span class="line"><span class="function">         7: <span class="title">iinc</span>          1, 1</span></span><br><span class="line"><span class="function">        10: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">        11: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">        12: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">        13: <span class="title">iinc</span>          1, -1</span></span><br><span class="line"><span class="function">        16: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">        17: <span class="title">istore_2</span></span></span><br><span class="line"><span class="function">        18: <span class="title">getstatic</span>     #2                  // <span class="title">Field</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">        21: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">        22: <span class="title">invokevirtual</span> #3                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">        25: <span class="title">getstatic</span>     #2                  // <span class="title">Field</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">System.out:Ljava</span>/<span class="title">io</span>/<span class="title">PrintStream</span>;</span></span><br><span class="line"><span class="function">        28: <span class="title">iload_2</span></span></span><br><span class="line"><span class="function">        29: <span class="title">invokevirtual</span> #3                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">io</span>/<span class="title">PrintStream.println</span>:(<span class="title">I</span>)<span class="title">V</span></span></span><br><span class="line"><span class="function">        32: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 11: 3</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 12: 18</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 13: 25</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 32</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0      33     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">            3      30     1     <span class="title">a</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">           18      15     2     <span class="title">b</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>分析: </p><ul><li>注意 iinc 指令是直接在局部变量 slot 上进行运算 </li><li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</li></ul><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-1.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-2.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-3.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-4.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-5.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-6.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-7.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-8.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-9.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-10.png" alt="a++-1"></p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/a++-11.png" alt="a++-1"></p><h3 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h3><table><thead><tr><th>指令</th><th>助记符</th><th>含义</th></tr></thead><tbody><tr><td>0×99</td><td>ifeq</td><td>判断是否 == 0</td></tr><tr><td>0×9a</td><td>ifne</td><td>判断是否 != 0</td></tr><tr><td>0×9b</td><td>iflt</td><td>判断是否 &lt; 0</td></tr><tr><td>0×9c</td><td>ifge</td><td>判断是否 &gt;= 0</td></tr><tr><td>0×9d</td><td>ifgt</td><td>判断是否 &gt; 0</td></tr><tr><td>0×9e</td><td>ifle</td><td>判断是否 &lt;= 0</td></tr><tr><td>0×9f</td><td>if_icmpeq</td><td>两个int是否 ==</td></tr><tr><td>0×a0</td><td>if_icmpne</td><td>两个int是否 !=</td></tr><tr><td>0×a1</td><td>if_icmplt</td><td>两个int是否 &lt;</td></tr><tr><td>0×a2</td><td>if_icmpge</td><td>两个int是否 &gt;=</td></tr><tr><td>0×a3</td><td>if_icmpgt</td><td>两个int是否 &gt;</td></tr><tr><td>0×a4</td><td>if_icmple</td><td>两个int是否 &lt;=</td></tr><tr><td>0×a5</td><td>if_acmpeq</td><td>两个引用是否 ==</td></tr><tr><td>0×a6</td><td>if_acmpne</td><td>两个引用是否 !=</td></tr><tr><td>0×c6</td><td>ifnull</td><td>判断是否 == null</td></tr><tr><td>0×c7</td><td>ifnonnull</td><td>判断是否 != null</td></tr></tbody></table><p>几点说明: </p><ul><li>byte, short, char 都会按 int 比较, 因为操作数栈都是 4 字节 </li><li>goto 用来进行跳转到指定行号的字节码</li></ul><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line"><span class="function">    descriptor: ([<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;)<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_STATIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=2, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         2: <span class="title">iload_1</span></span></span><br><span class="line"><span class="function">         3: <span class="title">ifne</span>          12</span></span><br><span class="line"><span class="function">         6: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">         8: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         9: <span class="title">goto</span>          15</span></span><br><span class="line"><span class="function">        12: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">        14: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        15: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 11: 2</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 12: 6</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 12</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 16: 15</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0      16     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">            2      14     1     <span class="title">a</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function">      <span class="title">StackMapTable</span>: <span class="title">number_of_entries</span> = 2</span></span><br><span class="line"><span class="function">        <span class="title">frame_type</span> = 252 /* <span class="title">append</span> */</span></span><br><span class="line"><span class="function">          <span class="title">offset_delta</span> = 12</span></span><br><span class="line"><span class="function">          <span class="title">locals</span> = [ <span class="title">int</span> ]</span></span><br><span class="line"><span class="function">        <span class="title">frame_type</span> = 2 /* <span class="title">same</span> */</span></span><br></pre></td></tr></table></figure><p>参考文档<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">&lt;(￣︶￣)↗[GO!]</a></p><h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p><strong>while循环</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_0</span><br><span class="line"> <span class="number">1</span>: istore_1</span><br><span class="line"> <span class="number">2</span>: iload_1</span><br><span class="line"> <span class="number">3</span>: bipush <span class="number">10</span></span><br><span class="line"> <span class="number">5</span>: if_icmpge <span class="number">14</span></span><br><span class="line"> <span class="number">8</span>: iinc <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">11</span>: <span class="keyword">goto</span> <span class="number">2</span></span><br><span class="line"><span class="number">14</span>: return</span><br></pre></td></tr></table></figure><p><strong>dowhile循环</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">a++;</span><br><span class="line">&#125; <span class="keyword">while</span> (a &lt; <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_0</span><br><span class="line"> <span class="number">1</span>: istore_1</span><br><span class="line"> <span class="number">2</span>: iinc <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"> <span class="number">5</span>: iload_1</span><br><span class="line"> <span class="number">6</span>: bipush <span class="number">10</span></span><br><span class="line"> <span class="number">8</span>: if_icmplt <span class="number">2</span></span><br><span class="line"><span class="number">11</span>: return</span><br></pre></td></tr></table></figure><p><strong>for循环</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_0</span><br><span class="line"> <span class="number">1</span>: istore_1</span><br><span class="line"> <span class="number">2</span>: iload_1</span><br><span class="line"> <span class="number">3</span>: bipush <span class="number">10</span></span><br><span class="line"> <span class="number">5</span>: if_icmpge <span class="number">14</span></span><br><span class="line"> <span class="number">8</span>: iinc <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">11</span>: <span class="keyword">goto</span> <span class="number">2</span></span><br><span class="line"><span class="number">14</span>: return</span><br></pre></td></tr></table></figure><blockquote><p>可以看到循环的底层也是条件判断指令<br>而且比较while和for的字节码, 可以发现是一摸一样的, 所以再有人问while和for那个快这个问题就显而易见了</p></blockquote><h3 id="通过字节码指令分析问题"><a href="#通过字节码指令分析问题" class="headerlink" title="通过字节码指令分析问题"></a>通过字节码指令分析问题</h3><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过字节码来看为什么结果是0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_0<span class="comment">// 准备一个常数 0</span></span><br><span class="line"> <span class="number">1</span>: istore_1<span class="comment">// 将常数 0 放入局部变量表的 1 号槽位 i = 0</span></span><br><span class="line"> <span class="number">2</span>: iconst_0<span class="comment">// 准备一个常数 0</span></span><br><span class="line"> <span class="number">3</span>: istore_2<span class="comment">// 将常数 0 放入局部变量的 2 号槽位 x = 0</span></span><br><span class="line"> <span class="number">4</span>: iload_1<span class="comment">// 将局部变量表 1 号槽位的数放入操作数栈中</span></span><br><span class="line"> <span class="number">5</span>: bipush        <span class="number">10</span><span class="comment">// 将数字 10 放入操作数栈中, 此时操作数栈中有 2 个数</span></span><br><span class="line"> <span class="number">7</span>: if_icmpge     <span class="number">21</span><span class="comment">// 比较操作数栈中的两个数, 如果下面的数大于上面的数, 就跳转到 21 。这里的比较是将两个数做减法。因为涉及运算操作, 所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span></span><br><span class="line"><span class="number">10</span>: iload_2<span class="comment">// 将局部变量 2 号槽位的数放入操作数栈中, 放入的值是 0 </span></span><br><span class="line"><span class="number">11</span>: iinc          <span class="number">2</span>, <span class="number">1</span><span class="comment">// 将局部变量 2 号槽位的数加 1 , 自增后, 槽位中的值为 1 </span></span><br><span class="line"><span class="number">14</span>: istore_2<span class="comment">//将操作数栈中的数放入到局部变量表的 2 号槽位, 2 号槽位的值又变为了0</span></span><br><span class="line"><span class="number">15</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 1 号槽位的值自增 1 </span></span><br><span class="line"><span class="number">18</span>: goto          <span class="number">4</span> <span class="comment">// 跳转到第4条指令</span></span><br><span class="line"><span class="number">21</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">24</span>: iload_2</span><br><span class="line"><span class="number">25</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line"><span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code><cinit>()V</code></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">i = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">i = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(i); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line"> <span class="number">2</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line"> <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line"> <span class="number">7</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line"><span class="number">10</span>: bipush        <span class="number">30</span></span><br><span class="line"><span class="number">12</span>: putstatic     #<span class="number">3</span>                  // Field i:I</span><br><span class="line"><span class="number">15</span>: return</span><br></pre></td></tr></table></figure><blockquote><p>编译器会按从上至下的顺序, 收集所有 static 静态代码块和静态成员赋值的代码, 合并为一个特殊的方法<code><cinit>()V:</code></p></blockquote><p><code><init>()V</code></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Code_13_InitTest</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Code_13_InitTest d = <span class="keyword">new</span> Code_13_InitTest(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(d.a); <span class="comment">//s3</span></span><br><span class="line">        System.out.println(d.b); <span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: aload_0</span><br><span class="line"> <span class="number">1</span>: invokespecial #<span class="number">1</span> // super.&lt;init&gt;()V</span><br><span class="line"> <span class="number">4</span>: aload_0</span><br><span class="line"> <span class="number">5</span>: ldc #<span class="number">2</span> // &lt;- &quot;s1&quot;</span><br><span class="line"> <span class="number">7</span>: putfield #<span class="number">3</span> // -&gt; this.a</span><br><span class="line"><span class="number">10</span>: aload_0</span><br><span class="line"><span class="number">11</span>: bipush <span class="number">20</span> // &lt;- <span class="number">20</span></span><br><span class="line"><span class="number">13</span>: putfield #<span class="number">4</span> // -&gt; this.b</span><br><span class="line"><span class="number">16</span>: aload_0</span><br><span class="line"><span class="number">17</span>: bipush <span class="number">10</span> // &lt;- <span class="number">10</span></span><br><span class="line"><span class="number">19</span>: putfield #<span class="number">4</span> // -&gt; this.b</span><br><span class="line"><span class="number">22</span>: aload_0</span><br><span class="line"><span class="number">23</span>: ldc #<span class="number">5</span> // &lt;- &quot;s2&quot;</span><br><span class="line"><span class="number">25</span>: putfield #<span class="number">3</span> // -&gt; this.a</span><br><span class="line"><span class="number">28</span>: aload_0 // ------------------------------</span><br><span class="line"><span class="number">29</span>: aload_1 // &lt;- slot <span class="number">1</span>(a) &quot;s3&quot; </span><br><span class="line"><span class="number">30</span>: putfield #<span class="number">3</span> // -&gt; this.a</span><br><span class="line"><span class="number">33</span>: aload_0 </span><br><span class="line"><span class="number">34</span>: iload_2 // &lt;- slot <span class="number">2</span>(b) <span class="number">30</span></span><br><span class="line"><span class="number">35</span>: putfield #<span class="number">4</span> // -&gt; this.b --------------------</span><br><span class="line"><span class="number">38</span>: return</span><br></pre></td></tr></table></figure><blockquote><p>编译器会按从上至下的顺序, 收集所有 {} 代码块和成员变量赋值的代码, 形成新的构造方法, 但原始构造方法内的代码总是在最后</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo3_9</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3_9 d = <span class="keyword">new</span> Demo3_9();</span><br><span class="line">        d.test1();</span><br><span class="line">        d.test2();</span><br><span class="line">        d.test3();</span><br><span class="line">        d.test4();</span><br><span class="line">        Demo3_9.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: new #<span class="number">2</span> </span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: invokespecial #<span class="number">3</span> // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> <span class="number">7</span>: astore_1</span><br><span class="line"> <span class="number">8</span>: aload_1</span><br><span class="line"> <span class="number">9</span>: invokespecial #<span class="number">4</span> // Method test1:()V</span><br><span class="line"><span class="number">12</span>: aload_1</span><br><span class="line"><span class="number">13</span>: invokespecial #<span class="number">5</span> // Method test2:()V</span><br><span class="line"><span class="number">16</span>: aload_1</span><br><span class="line"><span class="number">17</span>: invokevirtual #<span class="number">6</span> // Method test3:()V</span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"><span class="number">21</span>: pop</span><br><span class="line"><span class="number">22</span>: invokestatic #<span class="number">7</span> // Method test4:()V</span><br><span class="line"><span class="number">25</span>: invokestatic #<span class="number">7</span> // Method test4:()V</span><br><span class="line"><span class="number">28</span>: return</span><br></pre></td></tr></table></figure><p>不同方法在调用时, 对应的虚拟机指令有所区别</p><ul><li>私有、构造、被 final 修饰的方法, 在调用时都使用 invokespecial 指令</li><li>普通成员方法在调用时, 使用 invokevirtual 指令。因为编译期间无法确定该方法的内容, 只有在运行期间才能确定</li><li>静态方法在调用时使用 invokestatic 指令</li><li>new 是创建<strong>对象</strong>, 给对象分配堆内存, 执行成功会将<strong>对象引用</strong>压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容, 本例即为<strong>对象引用</strong>, 为什么需要两份引用呢, 一个是要配合 invokespecial 调用该对象的构造方法 <code>“init”: ()V</code> (会消耗掉栈顶一个引用), 另一个要 配合 astore_1 赋值给局部变量</li><li>终方法(ﬁnal), 私有方法(private), 构造方法都是由 invokespecial 指令来调用, 属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用, 属于动态绑定, 即支持多态 成员方法与静态方法调用的另一个区别是, 执行方法前是否需要<strong>对象引用</strong></li></ul><h3 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 演示多态原理, 注意加上下面的 JVM 参数, 禁用指针压缩</span></span><br><span class="line"><span class="comment">  * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        System.out.println(animal.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Cat());</span><br><span class="line">        test(<span class="keyword">new</span> Dog());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是&quot;</span> + <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行代码</strong></p><p>使用jps获取进程id</p><p><strong>运行 HSDB 工具</strong></p><p>进入 JDK 安装目录, 执行<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></p><p>进入图形界面 attach 进程 id , File -&gt; Attach to HoTSpot process</p><p><strong>查找某个对象</strong></p><p>打开 Tools -&gt; Find Object By Query</p><p>输入 <code>select d from com.ayu3.Dog d</code> 点击 Execute 执行</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1.png" alt="查找对象"></p><p><strong>查看对象内存结构</strong></p><p>点击超链接可以看到对象的内存结构, 此对象没有任何属性, 因此只有对象头的 16 字节, 前 8 字节是 MarkWord, 后 8 字节就是对象的 Class 指针, 但目前看不到它的实际地址</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="对象内存结构"></p><p><strong>查看对象 Class 的内存地址</strong></p><p>可以通过 Windows -&gt; Console 进入命令行模式, 执行<code>mem 0x00000000d447ef70 2</code><br>mem 有两个参数, 参数 1 是对象地址, 参数 2 是查看 2 行(即 16 字节)<br>结果中第二行 0x0000000017e641a0 即为 Class 的内存地址</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/Class%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="Class内存地址"></p><p><strong>查看类的 vtable</strong></p><p>Alt+R 进入 Inspector 工具, 输入刚才的 Class 内存地址, 看到如下界面</p><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/Inspector.png" alt="Inspector"></p><p>从 Class 的起始地址开始算, 偏移 0x1b8 就是 vtable 的起始地址, 进行计算得到: </p><blockquote><p>0x0000000017e641a0 + 1b8 = 0x0000000017e64358</p></blockquote><p><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/vtable.png" alt="vtable"></p><p>并且得知Dog Class 的 vtable 长度为 6, 意思就是 Dog 类有 6 个虚方法(多态相关的, final, static 不会列入)</p><p>通过 Windows -&gt; Console 进入命令行模式, 执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mem <span class="number">0</span>x0000000017e64358 <span class="number">6</span></span><br><span class="line"><span class="number">0</span>x0000000017e64358: <span class="number">0</span>x0000000017a61b10 </span><br><span class="line"><span class="number">0</span>x0000000017e64360: <span class="number">0</span>x0000000017a615e8 </span><br><span class="line"><span class="number">0</span>x0000000017e64368: <span class="number">0</span>x0000000017e63758 </span><br><span class="line"><span class="number">0</span>x0000000017e64370: <span class="number">0</span>x0000000017a61540 </span><br><span class="line"><span class="number">0</span>x0000000017e64378: <span class="number">0</span>x0000000017a61678 </span><br><span class="line"><span class="number">0</span>x0000000017e64380: <span class="number">0</span>x0000000017e64148 </span><br></pre></td></tr></table></figure><p>就得到了 6 个虚方法的入口地址</p><p><strong>验证方法地址</strong></p><p>通过 Tools -&gt; Class Browser 查看每个类的方法定义, 比较可知</p><blockquote><p>Dog - public void eat() @0x0000000017e64148</p><p>Animal - public java.lang.String toString() @0x0000000017e63758</p><p>Object - protected void finalize() @0x0000000017a61b10<br>Object - public boolean equals(java.lang.Object) @0x0000000017a615e8<br>Object - public native int hashCode() @0x0000000017a61540<br>Object - protected native java.lang.Object clone() @0x0000000017a61678</p></blockquote><p>对号入座, 发现</p><ul><li>eat() 方法是 Dog 类自己的 </li><li>toString() 方法是继承 String 类的 </li><li>finalize() , equals(), hashCode(), clone() 都是继承 Object 类的</li></ul><p><strong>小结</strong></p><p>当执行 invokevirtual 指令时</p><ol><li>先通过栈帧中的对象引用找到对象 </li><li>分析对象头, 找到对象的实际 Class </li><li>Class 结构中有 vtable, 它在类加载的链接阶段就已经根据方法的重写规则生成好了 </li><li>查表得到方法的具体地址 </li><li>执行方法的字节码</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">         4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         5: <span class="title">goto</span>          12</span></span><br><span class="line"><span class="function">         8: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">         9: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">        11: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        12: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function">         <span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">             2     5     8   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 12: 2</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 15: 5</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 13: 8</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 9</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 16: 12</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            9       3     2     <span class="title">e</span>   <span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Exception</span>;</span></span><br><span class="line"><span class="function">            0      13     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">            2      11     1     <span class="title">i</span>   <span class="title">I</span></span></span><br></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构, [from, to) 是前闭后开(也就是检测 2~4 行)的检测范围, 一旦这个范围内的字节码执行出现异常, 则通过 type 匹配异常类型, 如果一致, 进入 target 所指示行号</li><li>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 2 号位置(为 e )</li></ul><h4 id="多个-single-catch"><a href="#多个-single-catch" class="headerlink" title="多个 single-catch"></a>多个 single-catch</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=3, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">         4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">         5: <span class="title">goto</span>          19</span></span><br><span class="line"><span class="function">         8: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">         9: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">        11: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        12: <span class="title">goto</span>          19</span></span><br><span class="line"><span class="function">        15: <span class="title">astore_2</span></span></span><br><span class="line"><span class="function">        16: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">        18: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        19: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function">         <span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">             2     5     8   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">ArithmeticException</span></span></span><br><span class="line"><span class="function">             2     5    15   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 10: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 12: 2</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 17: 5</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 13: 8</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 9</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 17: 12</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 15: 15</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 16: 16</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 18: 19</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            9       3     2     <span class="title">e</span>   <span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">ArithmeticException</span>;</span></span><br><span class="line"><span class="function">           16       3     2     <span class="title">e</span>   <span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Exception</span>;</span></span><br><span class="line"><span class="function">            0      20     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">            2      18     1     <span class="title">i</span>   <span class="title">I</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><ul><li>因为异常出现时, 只能进入 Exception table 中一个分支, 所以局部变量表 slot 2 位置被共用</li></ul><h4 id="multi-catch-的情况"><a href="#multi-catch-的情况" class="headerlink" title="multi-catch 的情况"></a>multi-catch 的情况</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function">     <span class="title">stack</span>=3, <span class="title">locals</span>=2, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">ldc</span>           #2                  // <span class="title">class</span> <span class="title">com</span>/<span class="title">ayu3</span>/<span class="title">Demo</span></span></span><br><span class="line"><span class="function">         2: <span class="title">ldc</span>           #3                  // <span class="title">String</span> <span class="title">test</span></span></span><br><span class="line"><span class="function">         4: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">         5: <span class="title">anewarray</span>     #4                  // <span class="title">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Class</span></span></span><br><span class="line"><span class="function">         8: <span class="title">invokevirtual</span> #5                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Class.getMethod</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;[<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Class</span>;)<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">reflect</span>/<span class="title">Method</span>;</span></span><br><span class="line"><span class="function">        11: <span class="title">astore_1</span></span></span><br><span class="line"><span class="function">        12: <span class="title">aload_1</span></span></span><br><span class="line"><span class="function">        13: <span class="title">aconst_null</span></span></span><br><span class="line"><span class="function">        14: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">        15: <span class="title">anewarray</span>     #6                  // <span class="title">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">        18: <span class="title">invokevirtual</span> #7                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">reflect</span>/<span class="title">Method.invoke</span>:(<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Object</span>;[<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Object</span>;)<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">Object</span>;</span></span><br><span class="line"><span class="function">        21: <span class="title">pop</span></span></span><br><span class="line"><span class="function">        22: <span class="title">goto</span>          30</span></span><br><span class="line"><span class="function">        25: <span class="title">astore_1</span></span></span><br><span class="line"><span class="function">        26: <span class="title">aload_1</span></span></span><br><span class="line"><span class="function">        27: <span class="title">invokevirtual</span> #11                 // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">ReflectiveOperationException.printStackTrace</span>:()<span class="title">V</span></span></span><br><span class="line"><span class="function">        30: <span class="title">return</span></span></span><br><span class="line"><span class="function">     <span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function">         <span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">             0    22    25   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">NoSuchMethodException</span></span></span><br><span class="line"><span class="function">             0    22    25   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">IllegalAccessException</span></span></span><br><span class="line"><span class="function">             0    22    25   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">reflect</span>/<span class="title">InvocationTargetException</span></span></span><br><span class="line"><span class="function">     <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 14: 0</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 15: 12</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 18: 22</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 16: 25</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 17: 26</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 19: 30</span></span><br><span class="line"><span class="function">     <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">           12      10     1  <span class="title">test</span>   <span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">reflect</span>/<span class="title">Method</span>;</span></span><br><span class="line"><span class="function">           26       4     1     <span class="title">e</span>   <span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">ReflectiveOperationException</span>;</span></span><br><span class="line"><span class="function">            0      31     0  <span class="title">args</span>   [<span class="title">Ljava</span>/<span class="title">lang</span>/<span class="title">String</span>;</span></span><br><span class="line"><span class="function">      <span class="title">StackMapTable</span>: <span class="title">number_of_entries</span> = 2</span></span><br><span class="line"><span class="function">        <span class="title">frame_type</span> = 89 /* <span class="title">same_locals_1_stack_item</span> */</span></span><br><span class="line"><span class="function">          <span class="title">stack</span> = [ <span class="title">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">ReflectiveOperationException</span> ]</span></span><br><span class="line"><span class="function">        <span class="title">frame_type</span> = 4 /* <span class="title">same</span> */</span></span><br></pre></td></tr></table></figure><ul><li>从字节码来看发现也就那么回事, 有异常发生了先在ExceptionTable进行对比, 然后跳转到25行</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function">     <span class="title">stack</span>=1, <span class="title">locals</span>=4, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">        0: <span class="title">iconst_0</span></span></span><br><span class="line"><span class="function">        1: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        // <span class="title">try</span>块</span></span><br><span class="line"><span class="function">        2: <span class="title">bipush</span>        10</span></span><br><span class="line"><span class="function">        4: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        // <span class="title">try</span>块执行完后, 会执行<span class="title">finally</span>    </span></span><br><span class="line"><span class="function">        5: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">        7: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">        8: <span class="title">goto</span>          27</span></span><br><span class="line"><span class="function">       // <span class="title">catch</span>块     </span></span><br><span class="line"><span class="function">       11: <span class="title">astore_2</span> // 异常信息放入局部变量表的2号槽位</span></span><br><span class="line"><span class="function">       12: <span class="title">bipush</span>        20</span></span><br><span class="line"><span class="function">       14: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">       // <span class="title">catch</span>块执行完后, 会执行<span class="title">finally</span>        </span></span><br><span class="line"><span class="function">       15: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">       17: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">       18: <span class="title">goto</span>          27</span></span><br><span class="line"><span class="function">       // 出现异常, 但未被 <span class="title">Exception</span> 捕获, 会抛出其他异常, 这时也需要执行 <span class="title">finally</span> 块中的代码   </span></span><br><span class="line"><span class="function">       21: <span class="title">astore_3</span></span></span><br><span class="line"><span class="function">       22: <span class="title">bipush</span>        30</span></span><br><span class="line"><span class="function">       24: <span class="title">istore_1</span></span></span><br><span class="line"><span class="function">       25: <span class="title">aload_3</span></span></span><br><span class="line"><span class="function">       26: <span class="title">athrow</span>  // 抛出异常</span></span><br><span class="line"><span class="function">       27: <span class="title">return</span></span></span><br><span class="line"><span class="function">     <span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function">        <span class="title">from</span>    <span class="title">to</span>  <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">            2     5    11   <span class="title">Class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Exception</span></span></span><br><span class="line"><span class="function">            2     5    21   <span class="title">any</span></span></span><br><span class="line"><span class="function">           11    15    21   <span class="title">any</span></span></span><br></pre></td></tr></table></figure><ul><li>可以看到 ﬁnally 中的代码被复制了 3 份, 分别放入 try 流程, catch 流程以及 catch 剩余的异常类型流程</li><li>虽然从字节码指令看来, 每个块中都有 finally 块, 但是 finally 块中的代码只会被执行一次</li></ul><h4 id="finally-中的-return"><a href="#finally-中的-return" class="headerlink" title="finally 中的 return"></a>finally 中的 return</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = test();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Code:</span></span><br><span class="line"><span class="function"><span class="title">stack</span>=1, <span class="title">locals</span>=2, <span class="title">args_size</span>=0</span></span><br><span class="line"><span class="function">0: <span class="title">bipush</span> 10 // &lt;- 10 放入栈顶</span></span><br><span class="line"><span class="function">2: <span class="title">istore_0</span> // 10 -&gt; <span class="title">slot</span> 0 (从栈顶移除了)</span></span><br><span class="line"><span class="function">3: <span class="title">bipush</span> 20 // &lt;- 20 放入栈顶</span></span><br><span class="line"><span class="function">5: <span class="title">ireturn</span> // 返回栈顶 <span class="title">int</span>(20)</span></span><br><span class="line"><span class="function">6: <span class="title">astore_1</span> // <span class="title">catch</span> <span class="title">any</span> -&gt; <span class="title">slot</span> 1</span></span><br><span class="line"><span class="function">7: <span class="title">bipush</span> 20 // &lt;- 20 放入栈顶</span></span><br><span class="line"><span class="function">9: <span class="title">ireturn</span> // 返回栈顶 <span class="title">int</span>(20)</span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">table</span>:</span></span><br><span class="line"><span class="function"><span class="title">from</span> <span class="title">to</span> <span class="title">target</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">0 3 6 <span class="title">any</span></span></span><br></pre></td></tr></table></figure><ul><li>由于 finally 中的 ireturn 被插入了所有可能的流程, 因此返回结果肯定以 finally 的为准 </li><li>至于字节码中第 2 行, 似乎没啥用, 且留个伏笔, 看下个例子 </li><li>跟上例中的 finally 相比, 发现没有 athrow 了, 这告诉我们: 如果在 finally 中出现了 return, 会吞掉异常, 可以试一下下面的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现打印结果为 20 , 并未抛出异常</p><h4 id="finally-不带-return"><a href="#finally-不带-return" class="headerlink" title="finally 不带 return"></a>finally 不带 return</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = test();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0 <span class="comment">// 赋值给i 10</span></span><br><span class="line">        <span class="number">3</span>: iload_0<span class="comment">// 加载到操作数栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1 <span class="comment">// 加载到局部变量表的1号位置</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0 <span class="comment">// 赋值给i 20</span></span><br><span class="line">        <span class="number">8</span>: iload_1 <span class="comment">// 加载局部变量表1号位置的数10到操作数栈</span></span><br><span class="line">        <span class="number">9</span>: ireturn <span class="comment">// 返回操作数栈顶元素 10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2 <span class="comment">// 加载异常</span></span><br><span class="line">       <span class="number">15</span>: athrow <span class="comment">// 抛出异常</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">         <span class="number">3</span>: dup <span class="comment">//复制一份栈顶, 然后压入栈中, 用于执行构造方法</span></span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1 <span class="comment">//lock引用赋值给lock对象</span></span><br><span class="line">         <span class="number">8</span>: aload_1 <span class="comment">//将对象加载到操作数栈</span></span><br><span class="line">         <span class="number">9</span>: dup <span class="comment">//将这个对象再复制一份</span></span><br><span class="line">        <span class="number">10</span>: astore_2 <span class="comment">//将复制好的对象存入2号槽位</span></span><br><span class="line">        <span class="number">11</span>: monitorenter <span class="comment">//将栈顶的对象交给monitorenter, 也就是对lock加锁</span></span><br><span class="line">        <span class="number">12</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">15</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ok</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">20</span>: aload_2 <span class="comment">//将2号槽位的lock对象加载到操作数栈</span></span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//使用monitorexit解锁</span></span><br><span class="line">        <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">        <span class="comment">//发生异常</span></span><br><span class="line">        <span class="number">25</span>: astore_3 <span class="comment">//将异常对象存入3号槽位</span></span><br><span class="line">        <span class="number">26</span>: aload_2</span><br><span class="line">        <span class="number">27</span>: monitorexit</span><br><span class="line">        <span class="number">28</span>: aload_3 <span class="comment">//将异常对象加载到操作数栈</span></span><br><span class="line">        <span class="number">29</span>: athrow <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">12</span>    <span class="number">22</span>    <span class="number">25</span>   any</span><br><span class="line">            <span class="number">25</span>    <span class="number">28</span>    <span class="number">25</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">30</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">23</span>     <span class="number">1</span>  lock   Ljava/lang/Object;</span><br></pre></td></tr></table></figure><h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>所谓的<strong>语法糖</strong> , 其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中, 自动生成 和转换的一些代码, 主要是为了减轻程序员的负担, 算是 java 编译器给我们的一个额外福利（给糖吃嘛） </p><p>注意, 以下代码的分析, 借助了 javap 工具, idea 的反编译功能, idea 插件 jclasslib 等工具。另外,  编译器转换的结果直接就是 class 字节码, 只是为了便于阅读, 给出了<strong>几乎等价</strong>的 java 源码方式, 并 不是编译器还会转换出中间的 java 源码, 切记。</p><h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译期优化后:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 即调用父类 Object 的无参构造方法, 即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>这个特性是 JDK 5 开始加入的, 代码片段1: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK 5 之前是无法编译通过的, 必须改写为 代码片段2: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> y = x.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然之前版本的代码太麻烦了, 需要在基本类型和包装类型之间来回转换(尤其是集合类中操作的都是包装类型), 因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即<strong>代码片段1</strong>都会在编 译阶段被转换为<strong>代码片段2</strong></p><h3 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性, 但 java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作, 即泛型信息在编译为字节码之后就丢失了, 实际的类型都当做了 Object 类型来处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line">        Integer x = list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在取值时, 编译器真正生成的字节码中, 还要额外做一个类型转换的操作: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作</span></span><br><span class="line"><span class="keyword">int</span> x = ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure><p>对应字节码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="comment">// 这里进行了泛型擦除java实际调用的是add(Objcet o)</span></span><br><span class="line">      <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      <span class="comment">// 这里也进行了泛型擦除java实际调用的是get(Object o)   </span></span><br><span class="line">      <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// 这里进行了类型转换java将 Object 转换成了 Integer</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>使用反射可以得到, 参数的类型以及泛型类型: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 拿到方法</span></span><br><span class="line">    Method method = Candy.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">    <span class="comment">// 2. 得到泛型参数的类型信息</span></span><br><span class="line">    Type[] types = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(Type type : types) &#123;</span><br><span class="line">        <span class="comment">// 3. 判断参数类型是否, 带泛型的类型。</span></span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 得到原始类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">            <span class="comment">// 5. 拿到泛型类型</span></span><br><span class="line">            Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:</p><blockquote><p>原始类型 - interface java.util.List<br>泛型参数[0] - class java.lang.String<br>原始类型 - interface java.util.Map<br>泛型参数[0] - class java.lang.Integer<br>泛型参数[1] - class java.lang.Object</p></blockquote><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数也是 JDK 5 开始加入的新特性: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数 <code>String... args</code> 其实是一个 <code>String[] args</code> , 从代码中的赋值语句中就可以看出来, 同样 java 编译器会在编译期间将上述代码变换为: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = args; <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> </p><p>如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]&#123;&#125;)</code> , 创建了一个空的数组, 而不会传递 <code>null</code> 进去</p></blockquote><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>仍是 JDK 5 开始引入的语法糖, 数组的循环: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会帮我们转换为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = arr[i];</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是集合使用 foreach: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会帮我们转换为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        Iterator var2 = list.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            Integer x = (Integer)var2.next();</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>集合要使用 foreach , 需要该集合类实现了 <strong>Iterable</strong> 接口, 因为集合的遍历需要用到迭代器 <strong>Iterator</strong></p></blockquote><h3 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h3><p>从 JDK 7 开始, switch 可以作用于字符串和枚举类, 这个功能其实也是语法糖, 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cnady</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器帮我们转换成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 执行了两遍 switch, 第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型, 第二遍才是利用 byte 执行进行比较。</p><p>为什么第一遍时必须既比较 hashCode, 又利用 equals 比较呢？hashCode 是为了提高效率, 减少可能的比较, 而 equals 是为了防止 hashCode 冲突, 例如 <code>BM</code> 和 <code>C.</code> 这两个字符串的hashCode值都是 <code>2123</code> , 如果有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;BM&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;BM&quot;</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C.&quot;</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器帮我们转换成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;BM&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2123</span>:</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;C.&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;BM&quot;</span>)) &#123;</span><br><span class="line">                var3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> </p><p>switch 配合 String 和枚举使用时, 变量不能为null, 原因就是null没有hash值</p></blockquote><h3 id="switch-枚举"><a href="#switch-枚举" class="headerlink" title="switch 枚举"></a>switch 枚举</h3><p>switch 枚举的例子, 原始代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">    MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SEX sex = SEX.MALE;</span><br><span class="line">        <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类(仅 jvm 使用, 对我们不可见)</span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号, 从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0, FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 数组大小即为枚举元素个数, 里面存放了 case 用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">// ordinal 即枚举元素对应所在的位置, MALE 为 0 , FEMALE 为 1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="comment">// 将对应位置枚举元素的值赋给 x , 用于 case 操作</span></span><br><span class="line">      <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>JDK 7 新增了枚举类, 以前面的性别枚举为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">// 对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> &#123;       </span><br><span class="line">    <span class="comment">// 调用构造函数, 传入枚举元素的值及 ordinal</span></span><br><span class="line">    MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中资源对象需要实现 AutoCloseable 接口, 例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable , 使用 try-with- resources 可以不用写 finally 语句块, 编译器会帮助生成关闭资源代码, 例如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./1.txt&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被转换成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./1.txt&quot;</span>);</span><br><span class="line">            Throwable t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(is);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e1) &#123; </span><br><span class="line">                <span class="comment">// t 是我们代码出现的异常 </span></span><br><span class="line">                t = e1; </span><br><span class="line">                <span class="keyword">throw</span> e1; </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 判断了资源不为空 </span></span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            is.close(); </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e2) &#123; </span><br><span class="line">                            <span class="comment">// 如果 close 出现异常, 作为被压制异常添加</span></span><br><span class="line">                            t.addSuppressed(e2); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">// 如果我们代码没有异常, close 出现的异常就是最后 catch 块中的 e </span></span><br><span class="line">                        is.close(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要设计一个 <code>addSuppressed(Throwable e)</code> (添加被压制异常)的方法呢？是为了防止异常信息的丢失(想想 try-with-resources 生成的 fianlly 中如果抛出了异常): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> (MyResource resource = <span class="keyword">new</span> MyResource()) &#123; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123; </span><br><span class="line">    <span class="comment">//关闭时抛出一个异常, 测试是否丢失</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;close 异常&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>java.lang.ArithmeticException: / by zero<br>    at test.Test6.main(Test6.java:7)<br>    Suppressed: java.lang.Exception: close 异常<br>        at test.MyResource.close(Test6.java:18)<br>        at test.Test6.main(Test6.java:6)</p></blockquote><p>如以上代码所示, 两个异常信息都不会丢。</p><h3 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h3><p>我们都知道, 方法重写时对返回值分两种情况: </p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类(见下面例子)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子类, 编译器转换成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此方法才是真正重写了父类 public Number m() 方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> synthetic bridge Number <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="comment">// 调用 public Integer m() </span></span><br><span class="line"><span class="keyword">return</span> m(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中桥接方法比较特殊, 仅对 java 虚拟机可见, 并且与原来的 <code>public Integer m()</code> 没有命名冲突, 可以用下面反射代码来验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><blockquote><p>public java.lang.Integer com.ayu3.B.m()<br>public java.lang.Number com.ayu3.B.m()</p></blockquote><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Candy10$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个额外的类, 实现了 Runnable 接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Candy$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用局部变量的匿名内部类, 源代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类 </span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> val$x; </span><br><span class="line">Candy$<span class="number">1</span>(<span class="keyword">int</span> x) &#123; </span><br><span class="line"><span class="keyword">this</span>.val$x = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="keyword">this</span>.val$x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>匿名内部类将这个局部变量的传入到匿名内部类中, 以成员变量的形式存在, 值传递有构造函数完成, 保存线程安全</p><p>为了避免方法内的变量脱离方法而存在的现象发生, 于是在jdk1.8之前java规定局部内部类不能访问一般的局部变量, 但能访问被final修饰的局部变量。</p><p>而在jdk1.8后就不需要手动添加final修饰局部变量, jvm会自动在底层添加final修饰符, 被称为effectively final</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节码技术&quot;&gt;&lt;a href=&quot;#字节码技术&quot; class=&quot;headerlink&quot; title=&quot;字节码技术&quot;&gt;&lt;/a&gt;字节码技术&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%</summary>
      
    
    
    
    
    <category term="Java,JVM" scheme="http://www.ayu.link/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-04-26T13:34:00.000Z</published>
    <updated>2022-04-26T13:57:15.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>当一个对象被引用时, 该对象的引用值就加1, 当这个对象不再被引用时, 引用值就减1, 当引用值为0时, 就表示该对象可以被垃圾回收器回收。引用计数法有一个弊端, 那就是当两个对象相互引用的时, 两个对象的引用值都为1, 此时这两个对象就算用不到了, 也不会被回收。</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 </li><li>扫描堆中的对象, 看是否能够沿着 GC Root对象 为起点的引用链找到该对象, 找不到, 表示可以回收 </li><li>哪些对象可以作为 GC Root <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI (即一般说的Native方法)引用的对象</li></ul></li></ul><p>我们使用Eclipse Memory Analyzer(内存分析工具)对一下代码进行分析:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    list = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用jps命令找到程序进程</p><blockquote><p>PS D:\JVM\JVM_Study&gt; jps<br>14304 Jps<br>11060 Demo1<br>19532<br>26108 Launcher</p></blockquote></li><li><p>使用jmap命令生成内存快照</p><blockquote><p>PS D:\JVM\JVM_Study&gt; jmap -dump:format=b,live,file=1.bin 11060<br>Dumping heap to D:\JVM\JVM_Study\1.bin …<br>Heap dump file created</p></blockquote><p> 命令解释:</p><ul><li>dump: 转储文件</li><li>format=b: 使用二进制文件存储</li><li>live: 只抓取存活的对象, 并且抓取快照之前会进行垃圾回收</li><li>file=1.bin: 文件名</li><li>11060: 进程的id</li></ul></li><li><p>使用mat打开生成的快照, 选择GC Roots分析</p><p> <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/GC_Root.png" alt="GC_Root"></p></li></ol><p><code>list=null</code>前:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%89%8D.png" alt="null前"></p><p><code>list=null</code>后:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%90%8E.png" alt="null后"></p><p>可以看到, 在第一个快照中找到了ArrayList对象, 并且里面存储的对象也能找到, 第二个快照(也就是<code>list=null</code>后), ArrayList对象找不到了, 说明被回收了。</p><h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="引用类型"></p><ol><li>强引用 <ul><li>只有所有<strong>GC Roots</strong>对象都不通过【强引用】引用该对象, 该对象才能被垃圾回收 </li></ul></li><li>软引用(SoftReference)<ul><li>仅有软引用引用该对象时, 在垃圾回收后, 内存仍不足时会再次出发垃圾回收, 回收软引用对象 </li><li>可以配合引用队列来释放软引用自身 </li></ul></li><li>弱引用(WeakReference)<ul><li>仅有弱引用引用该对象时, 在垃圾回收时, 无论内存是否充足, 都会回收弱引用对象 </li><li>可以配合引用队列来释放弱引用自身 </li></ul></li><li>虚引用(PhantomReference)<ul><li>必须配合引用队列使用, 主要配合<strong>ByteBuffer</strong>使用, 被引用对象回收时, 会将虚引用入队</li><li>由<strong>Reference Handler</strong>线程调用虚引用相关方法(如unsafe.freememory)释放直接内存 </li></ul></li><li>终结器引用(FinalReference)<ul><li>无需手动编码, 但其内部配合引用队列使用, 在垃圾回收时, 终结器引用入队(被引用对象暂时没有被回收)</li><li>再由<strong>Finalizer</strong>线程通过终结器引用找到被引用对象并调用它的<strong>finalize</strong>方法, 第二次 GC 时才能回收被引用对象</li></ul></li></ol><p>软引用演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示软引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束: &quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强引用会直接因为内存不足报错:</p><blockquote><p>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p></blockquote><p>软引用分析:</p><blockquote><p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3</p><p>在第四次循环之前内存已经吃紧了, 所以触发了一次垃圾回收, 这是一次minor gc<br>[GC (Allocation Failure) [PSYoungGen: 1900K-&gt;488K(6144K)] 14188K-&gt;12996K(19968K), 0.0010493 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@1540e19d<br>4</p><p>第五次循环之前内存已经彻底不够用的, 而且此时一个minor gc也释放不了多少内存, 所以触发了一次full fc<br>[GC (Allocation Failure) –[PSYoungGen: 4696K-&gt;4696K(6144K)] 17204K-&gt;17220K(19968K), 0.0005897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4529K(6144K)] [ParOldGen: 12524K-&gt;12477K(13824K)] 17220K-&gt;17006K(19968K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0039704 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[GC (Allocation Failure) –[PSYoungGen: 4529K-&gt;4529K(6144K)] 17006K-&gt;17038K(19968K), 0.0006478 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Allocation Failure) [PSYoungGen: 4529K-&gt;0K(6144K)] [ParOldGen: 12509K-&gt;604K(8704K)] 17038K-&gt;604K(14848K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0052899 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@677327b6<br>5</p><p>可以看到这次full gc将前面的软引用的几个byte数组全部回收, 只留下最后一个byte数组<br>循环结束: 5<br>null<br>null<br>null<br>null<br>[B@677327b6<br>Heap<br>PSYoungGen      total 6144K, used 4263K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda9f70,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 8704K, used 604K [0x00000000fec00000, 0x00000000ff480000, 0x00000000ff980000)<br>object space 8704K, 6% used [0x00000000fec00000,0x00000000fec971a8,0x00000000ff480000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</p><p>Process finished with exit code 0</p></blockquote><p>上面的代码可以看到, 虽然软引用的对象已经被回收了, 但是软引用本身还没有被回收, 虽然软引用只占用很少的内存, 但是也不能留下它, 可以使用引用队列来清理软引用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示软引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列, 当软引用所关联的 byte[] 被回收时, 软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象, 并移除</span></span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3<br>[B@1540e19d<br>4<br>[B@677327b6</p><p>5</p><p>[B@677327b6</p><p>Process finished with exit code 0</p></blockquote><p>可以看到, 软引用本身也被回收了</p><p>弱引用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">        System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;488K(6144K)] 5632K-&gt;4760K(19968K), 0.0041741 secs] [Times: user=0.00 sys=0.03, real=0.02 secs]<br>[B@1b6d3586,<br>[B@1b6d3586,[B@4554617c,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,[B@1540e19d,</p><p>第五次循环前, 触发full gc, 回收弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4951K-&gt;0K(6144K)] [ParOldGen: 12464K-&gt;595K(13824K)] 17415K-&gt;595K(19968K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0052947 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,[B@677327b6,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,[B@6d6f6e28,</p><p>第九次循环前, 内存再次不够触发full gc, 最后只剩下一个弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4207K-&gt;0K(6144K)] [ParOldGen: 12911K-&gt;619K(13824K)] 17118K-&gt;619K(19968K), [Metaspace: 3224K-&gt;3224K(1056768K)], 0.0061594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,null,null,null,null,[B@135fbaa4,</p><p>===========================================<br>[B@135fbaa4,Heap<br>PSYoungGen      total 6144K, used 4247K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda5c78,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 13824K, used 619K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)<br>object space 13824K, 4% used [0x00000000fec00000,0x00000000fec9ae68,0x00000000ff980000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</p><p>Process finished with exit code 0</p></blockquote><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法(Mark Sweep):</p><ul><li>速度较快</li><li>会产生内存碎片</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法(Mark Compact)</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制(Copy)</p><ul><li>不会有内存碎片</li><li>需要占用两倍内存空间</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><ul><li>新创建的对象首先分配在<strong>eden</strong>区</li><li>新生代空间不足时, 触发<strong>minor gc</strong>, <strong>eden</strong>区和<strong>from</strong>区存活的对象使用 copy 复制到 to 中, 存活的对象年龄加一, 然后交换 from 和 to</li><li><strong>minor gc</strong> 会引发 <strong>stop the world</strong>(咋瓦鲁多), 暂停其他线程, 等垃圾回收结束后, 恢复用户线程运行</li><li>当幸存区对象的寿命超过阈值时, 会晋升到老年代, 默认最大的寿命是15(4bit)</li><li>当老年代空间不足时, 会先触发<strong>minor gc</strong>, 如果空间仍然不足, 那么就触发<strong>full gc</strong> , STW的时间更长</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="分代垃圾回收"></p><h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>Full GC前Minor GC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>相关概念:</p><ul><li>并行收集: 指多条垃圾收集线程并行工作, 但此时用户线程仍处于等待状态</li><li>并发收集: 指用户线程与垃圾收集线程同时工作(不一定是并行的可能会交替执行), 用户程序在继续运行, 而垃圾收集程序运行在另一个CPU上</li><li>吞吐量: 即CPU用于运行用户代码的时间与CPU总消耗时间的比值(吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )), 例如, 虚拟机共运行 100 分钟, 垃圾收集器花掉 1 分钟, 那么吞吐量就是 99% </li></ul><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul><li>单线程</li><li>堆内存较少, 适合个人电脑</li></ul><p><code>-XX:+UseSerialGC = Serial + SerialOld</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%B2%E8%A1%8C.png" alt="串行"></p><p><strong>安全点</strong>: 让其他线程都在这个点停下来, 以免垃圾回收时移动对象地址, 使得其他线程找不到被移动的对象<br>因为是串行的, 所以只有一个垃圾回收线程。且在该线程执行回收工作时, 其他线程进入阻塞状态。</p><p><strong>Serial 收集器</strong><br>Serial 收集器是最基本的、发展历史最悠久的收集器<br><strong>特点</strong>: 单线程、简单高效(与其他收集器的单线程相比), 采用复制算法。对于限定单个 CPU 的环境来说, Serial 收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时, 必须暂停其他所有的工作线程, 直到它结束(Stop The World)</p><p><strong>ParNew 收集器</strong><br>ParNew 收集器其实就是 Serial 收集器的多线程版本<br><strong>特点</strong>: 多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同, 在 CPU 非常多的环境中, 可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p><p><strong>Serial Old 收集器</strong><br>Serial Old 是 Serial 收集器的老年代版本<br><strong>特点</strong>: 同样是单线程收集器, 采用标记-整理算法</p><h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大, 多核CPU</li><li>让单位时间内, STW 的时间最短</li></ul><p><code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></p><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p><code>-XX:GCTimeRatio=ratio</code></p><p><code>-XX:MaxGCPauseMillis=ms</code></p><p><code>-XX:ParallelGCThreads=n</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png" alt="吞吐量优先"></p><p><strong>Parallel Scavenge 收集器</strong><br>与吞吐量关系密切, 故也称为吞吐量优先收集器<br><strong>特点</strong>: 属于新生代收集器也是采用复制算法的收集器(用到了新生代的幸存区), 又是并行的多线程收集器(与 ParNew 收集器类似)<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是: GC自适应调节策略(与 ParNew 收集器最重要的一个区别)</p><p>**GC自适应调节策略: **<br>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小(-Xmn)、Eden 与 Survivor 区的比例(-XX:SurvivorRation)、晋升老年代的对象年龄(-XX:PretenureSizeThreshold)等, 虚拟机会根据系统的运行状况收集性能监控信息, 动态设置这些参数以提供最优的停顿时间和最高的吞吐量, 这种调节方式称为 GC 的自适应调节策略。</p><p>Parallel Scavenge 收集器使用两个参数控制吞吐量: </p><ul><li><p>XX:MaxGCPauseMillis=ms 控制最大的垃圾收集停顿时间(默认200ms)</p></li><li><p>XX:GCTimeRatio=rario 直接设置吞吐量的大小(默认值为99, 但是不容易达到, 一般设置为19)</p></li></ul><p><strong>Parallel Old 收集器</strong><br>是 Parallel Scavenge 收集器的老年代版本<br><strong>特点</strong>: 多线程, 采用标记-整理算法(老年代没有幸存区)</p><h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul><li>多线程</li><li>堆内存较大, 多核CPU</li><li>尽可能让 STW 的单次时间最短</li></ul><p><code>-XX:+UseConcMarkSweepGC</code> ~ <code>-XX:+UseParNewGC</code> ~ <code>SerialOld</code><br><code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConcGCThreads=threads</code><br><code>-XX:CMSInitiatingOccupancyFraction=percent</code><br><code>-XX:+CMSScavengeBeforeRemark</code></p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="响应时间优先"></p><p><strong>CMS 收集器</strong><br>Concurrent Mark Sweep, 一种以获取最短回收停顿时间为目标的老年代收集器<br><strong>特点</strong>: 基于标记-清除算法实现。并发收集, 低停顿, 但是会产生内存碎片<br><strong>应用场景</strong>: 适用于注重服务的响应速度, 希望系统停顿时间最短, 给用户带来更好的体验等场景下。如 web 程序、b/s 服务<br><strong>CMS 收集器的运行过程分为下列4步</strong>:<br><strong>初始标记</strong>: 标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。<br><strong>并发标记</strong>: 进行 GC Roots Tracing 的过程, 找出存活对象且用户线程可并发执行。<br><strong>重新标记</strong>: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题<br><strong>并发清除</strong>: 对标记的对象进行清除回收, 清除的过程中, 可能任然会有新的垃圾产生, 这些垃圾就叫浮动垃圾, 如果当用户需要存入一个很大的对象时, 新生代放不下去, 老年代由于浮动垃圾过多, 就会退化为 serial Old 收集器, 将老年代垃圾进行标记-整理, 当然这也是很耗费时间的！</p><p>CMS 收集器的内存回收过程是与用户线程一起并发执行的, 可以搭配 ParNew 收集器(多线程, 新生代, 复制算法)与 Serial Old 收集器(单线程, 老年代, 标记-整理算法)使用。</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>定义</strong>:  Garbage First</p><p><strong>适用场景</strong>: </p><ul><li>同时注重吞吐量和低延迟(响应时间), 默认暂停目标是200ms</li><li>超大堆内存(内存大的), 会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法, 两个区域之间是复制算法</li></ul><p><strong>相关参数</strong>:<br>JDK8 并不是默认开启的, 所需要参数开启<br><code>-XX:+UseG1GC</code><br><code>-XX:G1HeapRegionSize=size</code><br><code>-XX:MaxGCPauseMillis=time</code></p><h4 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h4><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="G1垃圾回收阶段"></p><p>Young Collection: 对新生代垃圾收集<br>Young Collection + Concurrent Mark: 如果老年代内存到达一定的阈值了, 新生代垃圾收集同时会执行一些并发的标记<br>Mixed Collection: 会对新生代 + 老年代 + 幸存区等进行混合收集, 然后收集结束, 会重新进入新生代收集</p><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p><strong>新生代存在 STW</strong>:<br>分代是按对象的生命周期划分, 分区则是将堆空间划分连续几个不同小区间, 每一个小区间独立回收, 可以控制一次回收多少个小区间, 方便控制 GC 产生的停顿时间！<br>E: 伊甸园, S: 幸存区, O: 老年代</p><p>![Young Collection](/img/垃圾回收/Young Collection.gif)</p><h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><ul><li><p>在 Young GC 时会进行 GC Root 的初始标记 </p></li><li><p>老年代占用堆空间比例达到阈值时, 进行并发标记(不会 STW), 由下面的 JVM 参数决定</p><p>  <code>-XX:InitiatingHeapOccupancyPercent=percent</code> (默认45%)</p></li></ul><p>![Young Collection + CM](/img/垃圾回收/Young Collection + CM.png)</p><h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记(Remark), 会 STW </li><li>拷贝存活(Evacuation), 会 STW</li></ul><p> <code>-XX:MaxGCPauseMillis=ms</code> 用于指定最长的停顿时间</p><blockquote><p>为什么有的老年代被拷贝了, 有的没拷贝？<br>因为指定了最大停顿时间, 如果对所有老年代都进行回收, 耗时可能过高, 为了保证时间不超过设定的停顿时间, 会回收最有价值的老年代(回收后, 能够得到更多内存)</p></blockquote><p>![Mixed Collection](/img/垃圾回收/Mixed Collection.png)</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ul><li><strong>SerialGC</strong> <ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足发生的垃圾收集 - full gc </li></ul></li><li><strong>ParallelGC</strong> <ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足发生的垃圾收集 - full gc </li></ul></li><li><strong>CMS</strong><ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足 </li></ul></li><li><strong>G1</strong><ul><li>新生代内存不足发生的垃圾收集 - minor gc </li><li>老年代内存不足</li><li>如果垃圾产生速度慢于垃圾回收速度, 不会触发 Full GC, 还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度, 便会触发 Full GC, 然后退化成 serial Old 收集器串行的收集, 就会导致停顿的时间较长</li></ul></li></ul><h4 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h4><ul><li><p>新生代回收的跨代引用(老年代引用新生代)问题</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" alt="跨代引用"></p></li><li><p>卡表 与 Remembered Set</p><ul><li><p>卡表: O 被划分为多个区域(一个区域512K)</p></li><li><p>脏卡: 如果卡表中有区域引用了新生代对象, 则该区域被称为脏卡</p></li><li><p>Remembered Set 存在于E中, 用于保存新生代对象对应的脏卡</p></li></ul></li><li><p>在引用变更时通过 post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%84%8F%E5%8D%A1.png" alt="脏卡"></p><h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h4><p>pre-write barrier + satb_mark_queue<br>重新标记阶段<br>在垃圾回收时, 收集器处理对象的过程中</p><ul><li>黑色: 已被处理, 需要保留的</li><li>灰色: 正在处理中的</li><li>白色: 还未处理的</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark.png" alt="Remark"></p><p>看一下案例:</p><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-1.png" alt="Remark-1"></p><ul><li><p>在处理B的过程中, B断开了对C的引用, 这样B会变成黑色, C最终会标记为白色</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-2.png" alt="Remark-2"></p></li><li><p>但是此时A又引用了C, 可是C已经被标记为白色, C最终会被回收</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-3.png" alt="Remark-3"></p></li><li><p>这样就有问题了, C还在被A引用, 不该被回收, 这时就要用到<strong>Remark</strong>, 在C的引用改变时, JVM会给加上一个pre-write barrier(写屏障)</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-4.png" alt="Remark-4"></p></li><li><p>当A引用C时, C的引用发生变化, 写屏障指令触发, 将C放入一个队列(satb_mark_queue)中, 并将C的状态修改为处理中状态</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-5.png" alt="Remark-5"></p></li><li><p>在并发标记阶段结束以后, 重新标记阶段会 STW , 然后将放在该队列中的对象重新处理, 发现有A强引用C, 就会处理它, 由灰色变成黑色</p><p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-6.png" alt="Remark-6"></p></li></ul><h4 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h4><p><code>-XX:+UseStringDeduplication</code></p><ul><li>优点: 节省大量内存 </li><li>缺点: 略微多占用了 cpu 时间, 新生代回收时间略微增加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>过程: </p><ul><li>将所有新分配的字符串(底层是 char[])放入一个队列</li><li>当新生代回收时, G1 并发检查是否有重复的字符串</li><li>如果字符串的值一样, 就让他们引用同一个char[]</li><li>注意, 其与 String.intern() 的区别<ul><li>String.intern() 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 JVM 内部, 使用了不同的字符串标</li></ul></li></ul><h4 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后, 就能知道哪些类不再被使用, 当一个类加载器的所有类都不再使用, 则卸载它所加载的所有类<br><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p><h4 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于 region 的一半时, 称之为巨型对象</li><li>G1 不会对巨型对象进行拷贝 </li><li>回收时被优先考虑 </li><li>G1 会跟踪老年代所有 incoming 引用, 这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li></ul><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="回收巨型对象"></p><h4 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成, 否则退化为 Full GC</li><li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code></li><li>JDK 9 可以动态调整<ul><li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><p>查看虚拟机参数命令:</p><blockquote><p>java  -XX:+PrintFlagsFinal -version | findstr “GC”</p></blockquote><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li><li>gc</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><ul><li><strong>低延迟</strong>还是<strong>高吞吐量</strong>, 选择合适的回收器</li><li>CMS, G1, ZGC </li><li>ParallelGC</li><li>Zing(低延迟JVM, 宣称0停顿)</li></ul><h4 id="最快的-GC"><a href="#最快的-GC" class="headerlink" title="最快的 GC"></a>最快的 GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><p>查看 Full GC 前后的内存占用, 考虑以下几个问题</p><ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏<ul><li>static Map map …</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p>新生代的特点</p><ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象的回收代价为零</li><li>大部分对象用过即死</li><li>Minor GC 的时间远低于 Full GC</li></ul><p>新生代内存越大越好吗?</p><blockquote><p>-Xmn </p><p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p>设置新生代（托儿所）堆的初始大小和最大值（字节）。GC在该区域的执行频率高于其他区域。如果新生代的内存太小，则会执行大量Minor GC。如果内存太大，则只执行Full GC，这可能需要很长时间才能完成。Oracle建议将新生代的堆内存大小保持在总堆大小的25%以上，50%以下。</p></blockquote><ul><li><p>新生代能容纳所有【并发量 * (请求-响应)】的数据 </p></li><li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】 </p></li><li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p>  <code>-XX:MaxTenuringThreshold=threshold</code></p><p>  <code>-XX:+PrintTenuringDistribution</code></p>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, new threshold <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例:</p><ul><li><p>CMS 的老年代内存越大越好</p></li><li><p>先尝试不做调优, 如果没有 Full GC, 那么已经OK了, 否则先尝试调优新生代</p></li><li><p>观察发生 Full GC 时老年代内存占用, 将老年代内存预设调大1/4 ~ 1/3</p><p>  <code>-XX:CMSInitiatingOccupancyFraction=percent</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如何判断对象可以回收&quot;&gt;&lt;a href=&quot;#1-如何判断对象可以回收&quot; class=&quot;headerlink&quot; title=&quot;1. 如何判断对象可以回收&quot;&gt;&lt;/a&gt;1. 如何判断对象可以回收&lt;/h2&gt;&lt;h3 id=&quot;引用计数法&quot;&gt;&lt;a href=&quot;#引用计数法&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存结构</title>
    <link href="http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-04-15T11:49:14.000Z</published>
    <updated>2022-04-15T12:09:09.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p><img src="/img/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="程序计数器"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>Program Count Register 程序计数器(寄存器)</p><ul><li>作用: 记住下一条JVM指令的执行地址</li><li>特点:<ul><li>是线程私有的(每一个线程都有自己的程序计数器)</li><li>不会存在内存溢出</li></ul></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制字节码        //JVM指令//Java源代码</span></span><br><span class="line"> <span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out;</span></span><br><span class="line"> <span class="number">3</span>: astore_1 <span class="comment">// --</span></span><br><span class="line"> <span class="number">4</span>: aload_1 <span class="comment">// out.println(1);</span></span><br><span class="line"> <span class="number">5</span>: iconst_1 <span class="comment">// --</span></span><br><span class="line"> <span class="number">6</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"> <span class="number">9</span>: aload_1 <span class="comment">// out.println(2);</span></span><br><span class="line"><span class="number">10</span>: iconst_2<span class="comment">// --</span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">14</span>: aload_1 <span class="comment">// out.println(3);</span></span><br><span class="line"><span class="number">15</span>: iconst_3 <span class="comment">// --</span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">19</span>: aload_1 <span class="comment">// out.println(4);</span></span><br><span class="line"><span class="number">20</span>: iconst_4 <span class="comment">// --</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">24</span>: aload_1 <span class="comment">// out.println(5);</span></span><br><span class="line"><span class="number">25</span>: iconst_5 <span class="comment">// --</span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span> <span class="comment">// --</span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>解释器会解释指令为机器码交给 cpu 执行, 程序计数器会记录下一条指令的地址行号, 这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下, 每一个线程都有自己的程序计数器, 如果两个线程发生了上下文切换, 那么各自程序计数器会记录线程下一行指令的地址行号, 以便于接着往下执行。</li></ul></blockquote><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p><img src="/img/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="虚拟机栈"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h3><p>Java Virtual Machine Stacks (Java虚拟机栈)</p><ul><li>每个线程运行需要的内存空间, 称为虚拟机栈</li><li>每个栈由多个栈帧(Frame)组成, 对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧, 对应着当前正在执行的方法</li></ul><p><img src="/img/JVM/%E6%A0%88%E5%AE%9A%E4%B9%89.png" alt="栈定义"></p><p>看一下代码的实际运行情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debug运行, 查看栈内情况</p><p><img src="/img/JVM/%E6%A0%88%E5%86%85%E8%BF%90%E8%A1%8C.gif" alt="栈内运行"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>垃圾回收是否涉及栈内存?</p><p> 不会, 栈内存是方法调用产生的, 每次方法调用完毕会自动弹出栈(释放内存)</p></li><li><p>栈内存的分配是越大越好么?</p><p> 不是, 栈内存分配越大, 所能运行的线程也就越少, 一般使用默认即可</p></li><li><p>方法内的局部变量是否线程安全?</p><ul><li>如果方法内的局部变量没有逃离方法的作用范围, 它是线程安全的</li><li>如果是局部变量引用了对象, 并逃离了方法的作用范围, 那就要考虑线程安全问题</li></ul></li></ol><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><blockquote><p>-Xss参数用于设置栈内存大小</p><p>java.lang.StackOverflowError(栈溢出错误)</p></blockquote><ul><li><p>栈帧过多导致栈内存溢出(死循环, 死锁等)</p><p>  <img src="/img/JVM/%E6%A0%88%E5%B8%A7%E8%BF%87%E5%A4%9A.png" alt="栈帧过多"></p></li><li><p>栈帧过大导致栈内存溢出</p><p>  <img src="/img/JVM/%E6%A0%88%E5%B8%A7%E8%BF%87%E5%A4%A7.png" alt="栈帧过大"></p></li><li><p>第三方类库操作导致栈内存溢出</p></li></ul><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><p>案例一: cpu 占用过多<br>Linux 环境下运行某些程序的时候, 可能导致 CPU 的占用过高, 这时需要定位占用 CPU 过高的线程:</p><ul><li>top 命令, 查看是哪个进程占用 CPU 过高</li><li>ps H -eo pid, tid(线程id), %cpu | grep 刚才通过 top 查到的进程号, 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</li><li>jstack 进程 id 通过查看进程中的线程的 nid , 刚才通过 ps 命令看到的 tid 来对比定位, 注意 jstack 查找出的线程 id 是 16 进制的, 需要转换</li></ul><p>案例二: 程序运行很长时间没有结果</p><p>解决方法: 使用jstack命令排查死锁</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p><img src="/img/JVM/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.png" alt="本地方法栈"></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义:"></a>定义:</h3><p>Native Method Stacks(本地方法栈), 是JVM调用一些本地方法时, 给这些本地方法提供的内存空间</p><blockquote><p>由于Java的局限性, 一些与本地操作系统进行交互的方法就要用到操作系统的原生API</p></blockquote><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><p><img src="/img/JVM/%E5%A0%86.png" alt="堆"></p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h3><p>Heap(堆)</p><ul><li>通过new关键字创建的对象都会使用堆内存</li><li>它是线程共享的, 堆中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><blockquote><p>-Xmx用于设置堆内存大小</p><p>java.lang.OutofMemoryError ：java heap space 堆内存溢出错误</p></blockquote><p>代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><ol><li><p>jps 工具<br> 查看当前系统中有哪些 java 进程</p></li><li><p>jmap 工具<br> 查看堆内存占用情况 jmap - heap 进程id</p></li><li><p>jconsole 工具<br> 图形界面的, 多功能的监测工具, 可以连续监测</p></li><li><p>jvisualvm 工具</p><p> 同样是一个图形界面的检测工具</p></li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="/img/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="方法区"></p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义:"></a>定义:</h3><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域, 或者类似于操作系统进程中的“文本”段。它存储每个类的结构, 例如运行时常量池、字段和方法数据, 以及方法和构造函数的代码, 包括特殊方法, 用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。</p><p>尽管方法区域在逻辑上是堆的一部分, 但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小, 或者可以根据计算的需要进行扩展, 并且如果不需要更大的方法区域, 则可以收缩。方法区域的内存不需要是连续的！</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成:"></a>组成:</h3><p><img src="/img/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%84%E6%88%90.png" alt="方法区组成"></p><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><blockquote><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul></blockquote><p>代码演示内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先设置元空间内存 -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo4 test = <span class="keyword">new</span> Demo4();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>二进制<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>包含(类的基本信息, 常量池, 类方法定义, 包含了虚拟机的指令)<br>首先看看常量池是什么, 编译如下代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>javap -v HelloWorld.class</code>命令反编译查看结果。</p><p>常量池表: </p><p><img src="/img/JVM/%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="常量池"></p><blockquote><p>每条指令都会对应常量池表中一个地址, 常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p></blockquote><p>类方法定义:</p><p><img src="/img/JVM/%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.png" alt="类方法"></p><blockquote><p><strong>常量池</strong>:<br>就是一张表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>:<br>常量池是 *.class 文件中的, 当该类被加载以后, 它的常量池信息就会放入运行时常量池, 并把里面的符号地址变为真实地址</p></blockquote><h3 id="StringTable-字符串池"><a href="#StringTable-字符串池" class="headerlink" title="StringTable(字符串池)"></a>StringTable(字符串池)</h3><p>先看下面几段代码, 你能知道运行结果么:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s6 = s4.intern();</span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line">System.out.println(s3 == s6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">String x1 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2);</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>常量池中的字符串仅是符号, 只有在被用到时才会转化为对象</li><li>利用串池的机制, 来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法, 主动将串池中还没有的字符串对象放入串池中</li></ul><h4 id="intern方法-JDK1-8"><a href="#intern方法-JDK1-8" class="headerlink" title="intern方法(JDK1.8)"></a>intern方法(JDK1.8)</h4><p>调用字符串对象的 intern 方法, 会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象, 则放入成功</li><li>如果有该字符串对象, 则放入失败</li><li>无论放入是否成功, 都会返回串池中的字符串对象</li></ul><blockquote><p>注意: </p><p>JDK1.8中, 此时如果调用 intern 方法成功, 堆内存与串池中的字符串对象是同一个对象; 如果失败, 则不是同一个对象</p><p>而在JDK1.6中, 将这个字符串对象尝试放入串池, 如果有则并不会放入, 如果没有会把此对象复制一份, 放入串池, 会把串池中的对象返回</p></blockquote><p>例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span></span><br><span class="line">String st2 = str.intern();</span><br><span class="line"><span class="comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br></pre></td></tr></table></figure><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span></span><br><span class="line">String str2 = str.intern();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str == str2);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str == str3);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(str2 == str3);</span><br></pre></td></tr></table></figure><p>知道了这些再来看看上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s4 = s1 + s2; <span class="comment">//底层使用StringBulider的append方法进行拼接, 存入堆内存</span></span><br><span class="line">String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">//编译时会对常量字符串进行优化, &quot;a&quot; + &quot;b&quot; 直接被优化为 &quot;ab&quot;</span></span><br><span class="line">String s6 = s4.intern(); <span class="comment">//取到串池中的&quot;ab&quot;</span></span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"></span><br><span class="line">String x2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">String x1 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern(); <span class="comment">//尝试入池失败</span></span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2); </span><br><span class="line"><span class="comment">//如果先入池, x2入池成功, x1直接从常量池中取, 所以结果为true</span></span><br><span class="line"><span class="comment">//如果是JDK1.6, 入池intern不会将对象直接入池, 而是复制一份, 所以结果为false</span></span><br></pre></td></tr></table></figure><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><img src="/img/JVM/%E4%B8%B2%E6%B1%A0%E4%BD%8D%E7%BD%AE.png" alt="串池位置"></p><blockquote><p>在JDK1.6, StringTable是在永久代中的, 由于在永久代中对于GC不太方便, 在JDK1.7开始就把StringTable放在了堆中, 方便进行内存回收</p></blockquote><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>先看一个示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * 虚拟机参数设置如下</span></span><br><span class="line"><span class="comment"> * -Xmx10m 设置堆内存大小</span></span><br><span class="line"><span class="comment"> * -XX:+PrintStringTableStatistics 打印字符串常量池信息</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails -verbose:gc 打印GC的次数, 耗时等信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123; <span class="comment">// j = 100, j = 10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//垃圾回收信息</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;624K(9728K), <span class="number">0.0036565</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">10000</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 569K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">4</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd147c0</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">95</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7a020</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 136K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">1</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff622000</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3216K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 348<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">//符号表</span></span><br><span class="line"><span class="class"><span class="title">SymbolTable</span> <span class="title">statistics</span>:</span></span><br><span class="line"><span class="class"><span class="title">Number</span> <span class="title">of</span> <span class="title">buckets</span>       :     20011 </span>=    <span class="number">160088</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :     <span class="number">13269</span> =    <span class="number">318456</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :     <span class="number">13269</span> =    <span class="number">567376</span> bytes, avg  <span class="number">42.760</span></span><br><span class="line">Total footprint         :           =   <span class="number">1045920</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.663</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.663</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.814</span></span><br><span class="line">Maximum bucket size     :         <span class="number">6</span></span><br><span class="line"><span class="comment">//StringTable底层实现是HashTable</span></span><br><span class="line">StringTable statistics:</span><br><span class="line"><span class="comment">//桶的个数</span></span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line"><span class="comment">//字符串个数</span></span><br><span class="line">Number of entries       :      <span class="number">2559</span> =     <span class="number">61416</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :      <span class="number">2559</span> =    <span class="number">196144</span> bytes, avg  <span class="number">76.649</span></span><br><span class="line"><span class="comment">//总占用空间</span></span><br><span class="line">Total footprint         :           =    <span class="number">737664</span> bytes</span><br><span class="line">Average bucket size     :     <span class="number">0.043</span></span><br><span class="line">Variance of bucket size :     <span class="number">0.043</span></span><br><span class="line">Std. dev. of bucket size:     <span class="number">0.207</span></span><br><span class="line">Maximum bucket size     :         <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><ul><li><p>因为StringTable是由HashTable实现的, 所以可以适当增加HashTable桶的个数, 来减少字符串放入串池所需要的时间</p><blockquote><p>-XX:StringTableSize=桶个数(最少设置为1009 )</p></blockquote></li><li><p>考虑是否需要将字符串对象入池<br>  可以通过 intern 方法减少重复入池</p></li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义:"></a>定义:</h3><p>Direct Meory(直接内存)</p><ul><li>常见于NIO操作时, 用于数据缓冲区</li><li>分配回收成本较高, 但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h3><p>读写文件对比案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String FROM = <span class="string">&quot;D:\\video\\moive.mp4&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String TO = <span class="string">&quot;D:\\a.mp4&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1Mb = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    io(); <span class="comment">// io 用时: 17.5304 14.2835 10.1162</span></span><br><span class="line">    directBuffer(); <span class="comment">// directBuffer 用时: 9.9542 7.9202 6.5641</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(FROM).getChannel();</span><br><span class="line">         FileChannel to = <span class="keyword">new</span> FileOutputStream(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = from.read(bb);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bb.flip();</span><br><span class="line">            to.write(bb);</span><br><span class="line">            bb.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream from = <span class="keyword">new</span> FileInputStream(FROM);</span><br><span class="line">         FileOutputStream to = <span class="keyword">new</span> FileOutputStream(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[_1Mb];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = from.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现使用directBuffer的总是要快一点, 为什么呢, 看一下读取过程</p><p>文件读写过程(使用普通IO):</p><p><img src="/img/JVM/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B.png" alt="文件读写过程"></p><p>因为 Java 不能直接操作文件管理, 需要切换到内核态, 使用本地方法进行操作, 然后读取磁盘文件, 会在系统内存中创建一个缓冲区, 将数据读到系统缓冲区,  然后在将系统缓冲区数据, 复制到 Java 堆内存中。缺点是数据存储了两份, 在系统内存中有一份, Java 堆中有一份, 造成了不必要的复制。</p><p>使用DirectBuffer的读写过程: </p><p><img src="/img/JVM/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png" alt="直接内存"></p><p>直接内存是操作系统和 Java 代码都可以访问的一块区域, 无需将代码从系统内存复制到 Java 堆内存, 从而提高了效率。</p><h3 id="直接内存释放原理"><a href="#直接内存释放原理" class="headerlink" title="直接内存释放原理"></a>直接内存释放原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">    System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">    System.gc(); <span class="comment">// 手动 gc</span></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接内存不由JVM进行管理, 所以要通过任务管理器查看</p><ol><li><p>分配完毕</p><p> <img src="/img/JVM/%E5%88%86%E9%85%8D%E5%AE%8C%E6%AF%95.png" alt="分配完毕"></p></li><li><p>开始释放</p><p> <img src="/img/JVM/%E5%BC%80%E5%A7%8B%E9%87%8A%E6%94%BE.png" alt="开始释放"></p></li></ol><p>但其实直接内存不是由JVM的垃圾回收释放的, 而是通过<code>unsafe.freeMemory</code>来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException </span>&#123;</span><br><span class="line">    Unsafe unsafe = getUnsafe();</span><br><span class="line">    <span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">long</span> base = unsafe.allocateMemory(_1GB); </span><br><span class="line">    unsafe.setMemory(base,_1GB, (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    unsafe.freeMemory(base); </span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (Unsafe) field.get(Unsafe.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>分配内存:</p><p> <img src="/img/JVM/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" alt="分配内存"></p></li><li><p>释放内存</p><p> <img src="/img/JVM/%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98.png" alt="释放内存"></p></li></ol><h3 id="ByteBuffer底层源码"><a href="#ByteBuffer底层源码" class="headerlink" title="ByteBuffer底层源码"></a>ByteBuffer底层源码</h3><p>allocateDirect方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 这里是给我们返回了一个DirectByteBuffer, 我们接着往下看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显看到底层就是使用unsafe来分配内存的, 而且里面还调用了一个<code>Cleaner.create</code>方法, 使用了 Cleaner(虚引用)来监测 ByteBuffer 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : add(<span class="keyword">new</span> Cleaner(var0, var1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一旦 ByteBuffer 对象被垃圾回收, 那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用<code>unsafe.freeMemory</code>来释放直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>一般用 jvm 调优时, 会加上下面的参数：</p><blockquote><p>-XX:+DisableExplicitGC  // 静止显示的 GC</p></blockquote><p>意思就是禁止我们手动的 GC, 比如手动 System.gc() 无效, 它是一种 full gc, 会回收新生代、老年代, 会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-程序计数器&quot;&gt;&lt;a href=&quot;#1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;1. 程序计数器&quot;&gt;&lt;/a&gt;1. 程序计数器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之初识JVM</title>
    <link href="http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%88%9D%E8%AF%86JVM/"/>
    <id>http://www.ayu.link/2022/04/15/JVM%E4%B9%8B%E5%88%9D%E8%AF%86JVM/</id>
    <published>2022-04-15T11:49:03.000Z</published>
    <updated>2022-04-15T12:07:34.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><p>定义:</p><p>Java Virtual Machine - Java程序的运行环境(Java二进制字节码的运行环境)</p><p>好处:</p><ul><li>一次编写, 到处运行</li><li>自动内存管理, 垃圾回收机制</li><li>数组下标越界检查</li><li>实现多态</li></ul><p>比较:</p><p>JVM, JRE, JDK各种关系如下</p><p><img src="/img/JVM/%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="相关概念"></p><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><p>JVM是一种规范, 很多厂商都有自己定制的JVM, 下面是一些常见的JVM, 我们学习的主要是原厂的HotSpot</p><p><img src="/img/JVM/%E5%B8%B8%E8%A7%81JVM.png" alt="常见JVM"></p><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="/img/JVM/JVM%E6%9E%84%E9%80%A0.png" alt="JVM构造"></p><p>ClassLoader: Java 代码编译成二进制后, 会经过类加载器, 这样才能加载到 JVM 中运行。<br>Method Area: 类是放在方法区中。<br>Heap: 类的实例对象。<br>当类调用方法时, 会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行, 方法中的热点代码频繁调用的方法, 由 JIT 编译器优化后执行, GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是JVM&quot;&gt;&lt;a href=&quot;#什么是JVM&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM?&quot;&gt;&lt;/a&gt;什么是JVM?&lt;/h2&gt;&lt;p&gt;定义:&lt;/p&gt;
&lt;p&gt;Java Virtual Machine - Java程序的运行环境(Java二进</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.ayu.link/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC之ForkJoin框架</title>
    <link href="http://www.ayu.link/2022/04/10/JUC%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.ayu.link/2022/04/10/JUC%E4%B9%8BForkJoin%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-10T06:18:53.000Z</published>
    <updated>2022-04-10T07:33:56.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是由JDK1.7后提供多线并发处理框架, ForkJoin的框架的基本思想是分而治之。使用ForkJoin将相同的计算任务通过多线程的进行执行, 从而能提高数据的计算速度。在google的中的大数据处理框架mapreduce就通过类似ForkJoin的思想, 通过多线程提高大数据的处理。</p><p>使用ForkJoin框架, 需要创建一个ForkJoin的任务。因为ForkJoin框架为我们提供了RecursiveAction和RecursiveTask。我们只需要继承ForkJoin为我们提供的抽象类的其中一个并且实现compute方法。</p><ul><li>RecursiveTask在进行exec之后会使用一个result的变量进行接受返回的结果。</li><li>而RecursiveAction在exec后是不会保存返回结果。</li></ul><blockquote><p>分而治之就是将一个复杂的计算, 按照设定的阈值进行分解成多个计算, 然后将各个计算结果进行汇总。相应的ForkJoin将复杂的计算当做一个任务, 而分解的多个计算则是当做一个子任务。</p></blockquote><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>Task要通过ForkJoinPool来执行, 的子任务也会添加到当前工作线程的双端队列中, 进入队列的头部。当一个工作线程中没有任务时, 会从其他工作线程的队列尾部获取一个任务(工作窃取)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//创建MyTask对象</span></span><br><span class="line">    MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//创建分支合并池对象</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//获取合并之后非结果</span></span><br><span class="line">    ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(myTask);</span><br><span class="line">    Integer result = submit.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="comment">//关闭线程池对象</span></span><br><span class="line">    forkJoinPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>工作窃取</strong>(work-stealing)</p><p>任务进行分解成多个子任务的时候，每个子任务的处理时间都不一样。</p><p>例如分别有子任务A和B。如果子任务A的1ms的时候已经执行，子任务B还在执行。那么如果子任务A的线程等待子任务B完毕后在进行汇总，那么子任务A线程就会在浪费执行时间，最终的执行时间就以最耗时的子任务为准。</p><p>而如果子任务A执行完毕后，处理子任务B的任务，并且执行完毕后将任务归还给子任务B。这样就可以提高执行效率，这就是工作窃取。</p></blockquote><h2 id="案例1-1-100的和"><a href="#案例1-1-100的和" class="headerlink" title="案例1: 1-100的和"></a>案例1: 1-100的和</h2><p>使用二分法将100不断拆分, 直到每个线程的任务都相对轻松为止, 直接看代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写这段代码的人肯定没听说过高斯的故事</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyTask对象</span></span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建分支合并池对象</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//获取合并之后非结果</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(myTask);</span><br><span class="line">        Integer result = submit.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//关闭线程池对象</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分值不能超过10, 防止线程过度创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - begin) &lt;= VALUE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            MyTask myTask1 = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">            MyTask myTask2 = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            myTask1.fork();</span><br><span class="line">            myTask2.fork();</span><br><span class="line">            result = result + myTask1.join() + myTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例2-八皇后问题"><a href="#案例2-八皇后问题" class="headerlink" title="案例2: 八皇后问题"></a>案例2: 八皇后问题</h2><blockquote><p>八皇后问题是一个古老而又著名的问题, 是学习回溯算法的一个经典案例。</p><p>在8×8格的国际象棋上摆放八个皇后, 使其不能互相攻击, 即任意两个皇后都不能处于同一行、同一列或同一斜线上, 问一共有多少种摆法。</p><p>我们这里使用Fork Join框架并行解决问题, 加快处理速度。</p></blockquote><p>上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0为棋盘, 8为皇后, 1为皇后攻击位</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> EightQueen(<span class="number">0</span>, chessboard));</span><br><span class="line">        <span class="comment">//等待任务完成</span></span><br><span class="line">        forkJoinPool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EightQueen</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span>[][] chessboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EightQueen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[][] chessboard)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.chessboard = chessboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印棋盘, 这里一定要加把锁, 不然打印会乱套</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----第&quot;</span> + (++count) + <span class="string">&quot;种解法----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; chessboard.length; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessboard[row][col] == <span class="number">1</span>) chessboard[row][col] = <span class="number">0</span>;<span class="comment">//将被判定为攻击位的地方重新初始化为*</span></span><br><span class="line">                System.out.print(chessboard[row][col]);</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把攻击位设置为1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putAttack</span><span class="params">(<span class="keyword">int</span> nowRow, <span class="keyword">int</span> nowCol, <span class="keyword">int</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; chessboard.length; row++) &#123;</span><br><span class="line">            chessboard[row][nowCol] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">                chessboard[nowRow][col] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (row + col == nowRow + nowCol) chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (row - col == nowRow - nowCol) chessboard[row][col] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chessboard[nowRow][nowCol] = <span class="number">8</span>;<span class="comment">//上面的方法会把皇后位修改成攻击位，这里需要复原成皇后位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == chessboard.length) &#123;<span class="comment">//如果行数等于length，说明最后一行放置完毕，打印棋盘并退出方法</span></span><br><span class="line">            printChessboard(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chessboard[row].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//创建备份, 等待分支结束后数组复原</span></span><br><span class="line">                <span class="keyword">int</span>[][] backup = <span class="keyword">new</span> <span class="keyword">int</span>[chessboard.length][chessboard.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessboard.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessboard[i].length; j++) &#123;</span><br><span class="line">                        backup[i][j] = chessboard[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chessboard[row][col] = <span class="number">8</span>;</span><br><span class="line">                putAttack(row, col, chessboard);</span><br><span class="line">                <span class="comment">//开启分支, 进入下一行</span></span><br><span class="line">                EightQueen eightQueen = <span class="keyword">new</span> EightQueen(row + <span class="number">1</span>, chessboard);</span><br><span class="line">                eightQueen.fork();</span><br><span class="line">                <span class="comment">//分支结束, 数组复原</span></span><br><span class="line">                chessboard = backup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h2><ul><li>使用这种多线程带来的数据共享问题, 在处理结果的合并的时候如果涉及到数据共享的问题, 我们尽可能使用JDK为我们提供的并发容器。</li><li>在使用JVM的时候我们要考虑OOM的问题, 如果我们的任务处理时间非常耗时, 并且处理的数据非常大的时候会造成OOM。</li><li>ForkJoin也是通过多线程的方式进行处理任务。, 那么我们不得不考虑是否应该使用ForkJoin。因为当数据量不是特别大的时候, 我们没有必要使用ForkJoin, 多线程会涉及到上下文的切换, 所以数据量不大的时候使用串行比使用多线程快。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ForkJoin&quot;&gt;&lt;a href=&quot;#ForkJoin&quot; class=&quot;headerlink&quot; title=&quot;ForkJoin&quot;&gt;&lt;/a&gt;ForkJoin&lt;/h2&gt;&lt;p&gt;ForkJoin是由JDK1.7后提供多线并发处理框架, ForkJoin的框架的基本思想是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池</title>
    <link href="http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-04-09T08:20:09.000Z</published>
    <updated>2022-04-09T13:31:01.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销, 进而影响缓存局部性和整体性能。而线程池维护着多个线程, 等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用, 还能防止过分调度。</p><p>特点:</p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时, 任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源, 如果无限制的创建 ,不仅会销耗系统资源 ,还会降低系统的稳定性 ,使用线程池可以进行统一的分配, 调优和监控。</li></ul><p>架构:</p><p>Java中的线程池是通过Executor框架实现的,该框架中用到了Executor, Executors, ExecutorService, ThreadPoolExecutor这几个类</p><p><img src="/img/2022-04-09/01.png"></p><h2 id="三种线程池"><a href="#三种线程池" class="headerlink" title="三种线程池"></a>三种线程池</h2><ol><li>Executors.newFixedThreadPool(int) : 一池定线程<ul><li>创建一个定长的线程池, 可控制线程的最大并发量, 超出的线程会在阻塞队列(<strong>LinkedBlockingQueue</strong>)中等待</li><li>线程池的<strong>corePoolSize</strong>和<strong>MaxmumPoolSize</strong>是相等的</li></ul></li><li>Executors.newSingleThreadExecutor( ) : 一池一线程<ul><li>创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, 超出的线程会在阻塞队列(<strong>LinkedBlockingQueue</strong>)中等待, 保证所有的任务都按照指定顺序执行</li><li>线程池的<strong>corePoolSize</strong>和<strong>MaxmumPoolSize</strong>都为1</li></ul></li><li>Executors.newCachedThreadPool( ) : 一池N线程<ul><li>创建一个可缓存线程池, 如果线程池长度超过处理需要, 可灵活会后空闲线程, 若无可回收, 则创建新线程</li><li>线程池的<strong>corePoolSize</strong>设置为0, <strong>MaxmumPoolSize</strong>设置为<code>Integer.MAX_VALUE</code></li><li>阻塞队列使用的是<strong>SynchronousQueue</strong>, 也就是说来了任务就创建线程运行, 如果线程空闲超过60秒, 就销毁该线程</li></ul></li></ol><p>具体代码使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一池多线程</span></span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newFixedThreadPool(5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可扩容线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//十个请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种线程池其实是并不常用的, 我们在写业务的时候会遇到各种各样的情况, 这三种线程池很难满足各式各样的需求, 就需要用到自定义线程池, 想要定制化线程池, 就需要了解创建线程池的七大参数。</p><h2 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h2><ul><li><strong>int corePoolSize</strong>, 常驻线程数量(核心)</li><li><strong>int maximumPoolSize</strong>, 最大线程数量, 就是线程池扩容的最大值</li><li><strong>long keepAliveTime</strong>, 额外扩容线程的存活时间</li><li><strong>TimeUnit unit</strong>, 存活时间单位</li><li><strong>BlockingQueue workQueue</strong>, 阻塞队列, 常驻线程数量都在被使用, 新的请求会被阻塞</li><li><strong>ThreadFactory threadFactory</strong>,  线程工厂, 用来创建线程</li><li><strong>RejetedExecutionHandler handler</strong>,  拒绝策略, 表示当线程队列满了并且工作线程大于等于线程池的最大值(maxnumPoolSize)时如何来拒绝</li></ul><p>下面用一个简单的银行场景来解释一下这几个参数</p><p><img src="/img/2022-04-09/02.png"></p><p>在上面的场景中:</p><ul><li>bank银行就是我们的线程池</li><li>椭圆的窗口一共有5个, 但是实线的在开放的只有2个, 这里一直使用的窗口就是corePoolSize, 而窗口总数量就是maximumPoolSize</li><li>候客区就是workQueue, 可以看到候客区只有5个位置, 说明最多只能有5个等待线程</li><li>当候客区超了, 这时经理(threadFactory)就带着超出来的人去把闲置的窗口打开使用, 也就是扩容线程池, 创建新线程, 但是线程总数不能超过5</li><li>当人少的时候, 多开出来的窗口一直空闲, 超过了keepAliveTime就会被关闭</li><li>保安就是拒绝策略handler, 当五个窗口都开放了, 候客区还超标的话, 这时候保安就得做点什么, 比如让人出去, 或者把在窗口前墨迹的人赶出去, 这些就需要了解拒绝策略到底有哪几种了</li></ul><p>底层运行流程:</p><p><img src="/img/2022-04-09/03.png"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>JDK内置了四种拒绝策略:</p><ul><li><strong>AbortPolicy</strong>(默认), 这种拒绝策略在拒绝任务时, 会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException, 让你感知到任务被拒绝了, 于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</li><li><strong>DiscardPolicy</strong>, 这种拒绝策略正如它的名字所描述的一样, 当新任务被提交后直接被丢弃掉, 也不会给你任何的通知, 相对而言存在一定的风险, 因为我们提交的时候根本不知道这个任务会被丢弃, 可能造成数据丢失。</li><li><strong>DiscardOldestPolicy</strong>, 如果线程池没被关闭且没有能力执行, 则会丢弃任务队列中的头结点, 通常是存活时间最长的任务, 这种策略与第二种不同之处在于它丢弃的不是最新提交的, 而是队列中存活时间最长的, 这样就可以腾出空间给新提交的任务, 但同理它也存在一定的数据丢失风险。明明是我等的最久, 却让我走, 表示很难受。</li><li><strong>CallerRunsPolicy</strong>, 相对而言它就比较完善了, 当有新任务提交后, 如果线程池没被关闭且没有能力执行, 则把这个任务交于提交任务的线程执行, 也就是谁提交任务, 谁就负责执行任务。这样做主要有两点好处: <ol><li>新提交的任务不会被丢弃, 这样也就不会造成业务损失。</li><li>由于谁提交任务谁就要负责执行任务, 这样提交任务的线程就得负责执行任务, 而执行任务又是比较耗时的, 在这段期间, 提交任务的线程被占用, 也就不会再提交新的任务, 减缓了任务提交的速度, 相当于是一个负反馈。在此期间, 线程池中的线程也可以充分利用这段时间来执行掉一部分任务, 腾出一定的空间, 相当于是给了线程池一定的缓冲期。</li></ol></li></ul><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>下面就尝试自己创建一个线程池, 使用<code> new ThreadPoolExecutor()</code>方法, 需求是常驻线程数为2, 最大线程数为5, 等待队列长度为3, 其余使用默认即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义线程</span></span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//十个请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h2&gt;&lt;p&gt;线程池（thread pool）：一种线程使用模式。线程过多会带来调度开销, 进而影响缓存局部性和整体性能。</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之阻塞队列</title>
    <link href="http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://www.ayu.link/2022/04/09/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2022-04-09T07:19:57.000Z</published>
    <updated>2022-04-09T08:18:15.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是: 在队列为空时, 获取元素的线程会等待队列变为非空。当队列满时, 存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景, 生产者是往队列里添加元素的线程, 消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器, 而消费者也只从容器里拿元素。</p><ul><li>当队列是空的, 从队列中获取元素的操作将会被阻塞</li><li>当队列是满的, 从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞, 直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞, 直到其他线程从队列中移除一个或多个元素或者完全清空, 使队列变得空闲起来并后续新增</li></ul><h2 id="阻塞队列种类"><a href="#阻塞队列种类" class="headerlink" title="阻塞队列种类"></a>阻塞队列种类</h2><ol><li><p><strong>ArrayBlockingQueue</strong></p><ul><li>基于数组构成的有界阻塞队列</li><li>在生产者插入数据和消费者获取数据时用的是同一把锁, 无法并行</li></ul></li><li><p><strong>LinkedBlockingQueue</strong></p><ul><li>基于链表构成的有界(默认值为<code>Integer.MAX_VALUE</code>)阻塞队列</li><li>插入数据和获取数据分别采用了独立的锁, 有较好的并发性能</li></ul></li><li><p><strong>DelayQueue</strong></p><ul><li>基于优先级队列实现的延迟无界阻塞队列</li><li>DelayQueue 中的元素只有当其指定的延迟时间到了, 才能够从队列中获取到该元素。</li><li>DelayQueue 是一个没有大小限制的队列, 因此往队列中插入数据的操作永远不会被阻塞, 只有获取数据的操作才会被阻塞</li></ul></li><li><p><strong>PriorityBlockingQueue</strong></p><ul><li>基于优先级队列实现的无界阻塞队列</li><li>支持优先级排序</li><li>不会阻塞生产者, 当队列中没有数据时, 会阻塞消费者</li></ul></li><li><p><strong>SynchronousQueue</strong></p><ul><li>一种无缓冲的等待队列</li><li>相对于有缓冲的BlockingQueue来说, 少了一个中间环节(缓冲区)</li><li>不存储元素, 是一个单个元素的队列</li></ul><blockquote><p><strong>SynchronousQueue</strong>公平模式与非公平模式的区别</p><ul><li><strong>公平模式</strong>: SynchronousQueue 会采用公平锁, 并配合一个 FIFO 队列来阻塞多余的生产者和消费者, 从而体系整体的公平策略</li><li><strong>非公平模式</strong>(默认)：SynchronousQueue 采用非公平锁, 同时配合一个 LIFO 队列来管理多余的生产者和消费者, 再高并发的情况下容易出现线程饥饿</li></ul></blockquote></li><li><p><strong>LinkedTransferQueue</strong></p><ul><li>基于链表结构实现的无界TransferQueue队列</li><li><strong>预占模式</strong>: 意思就是消费者线程取元素时, 如果队列不为空, 则直接取走数据, 若队列为空, 生成一个节点(元素为 null)入队, 消费者线程被等待在这个节点上, 生产者线程入队时发现有一个元素为 null 的节点, 生产者线程就不入队了, 直接就将元素填充到该节点, 并唤醒该节点等待的线程, 被唤醒的消费者线程取走元素, 从调用的方法返回</li></ul></li><li><p><strong>LinkedBlockingDeque</strong></p><ul><li>基于链表实现的双向有界阻塞队列</li><li>可以从队列的两端插入和移除元素, 双向队列因为多了一个操作队列的入口, 在多线程同时入队时, 也就减少了一半的竞争</li><li>插入元素时: 如果当前队列已满将会进入阻塞状态, 一直等到队列有空的位置时再该元素插入, 该操作可以通过设置超时参数, 超时后返回 false 表示操作失败, 也可以不设置超时参数一直阻塞, 中断后抛出 InterruptedException异常</li><li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素, 同样可以通过设置超时参数</li></ul></li></ol><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>NA</td><td>NA</td></tr></tbody></table><p>各种方法类型的具体效果</p><table><thead><tr><th align="left">方法类型</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">抛出异常</td><td align="left">当阻塞队列满时, 再往队列里add插入元素会抛出IllegalStateException:Queue full<br/>当阻塞队列空时, 再对队列remove移除元素会抛出NoSuchElementException</td></tr><tr><td align="left">特殊值</td><td align="left">插入方法, 成功返回true, 失败返回false<br />移出方法, 成功返回取出的元素, 失败返回null</td></tr><tr><td align="left">阻塞</td><td align="left">当阻塞队列满时, 生产者线程继续往队列里put元素, 队列就会一直阻塞生产者知道put数据成功或中断退出<br />当阻塞队列空时, 消费者线程试图从队列里take元素, 队列就会一直阻塞消费者线程知道队列里有数据</td></tr><tr><td align="left">超时</td><td align="left">当阻塞队列满时, 队列会阻塞生产者线程, 超过等待时限后生产者线程会退出<br />当阻塞队列空时, 队列会阻塞消费者线程, 超过等待时限后消费者线程会退出</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是阻塞队列&quot;&gt;&lt;a href=&quot;#什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;什么是阻塞队列&quot;&gt;&lt;/a&gt;什么是阻塞队列&lt;/h2&gt;&lt;p&gt;阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是: 在队列为空</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之辅助类</title>
    <link href="http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <id>http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/</id>
    <published>2022-04-07T11:19:53.000Z</published>
    <updated>2022-04-07T13:26:39.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch(闭锁)"></a>CountDownLatch(闭锁)</h2><h3 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h3><p>CountDownLatch是一个同步工具类, 用来协调多个线程之间的同步, 或者说起到线程之间的通信(而不是用作互斥的作用)。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后, 再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后, 计数器的值就会减一, 当计数器的值为0时, 表示所有的线程都已经完成一些任务, 然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a>CountDownLatch的用法</h3><ul><li>当一个或多个线程调用await方法时, 这些线程会阻塞</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</li><li>计数器的值变为0时, 因await方法阻塞的线程会被唤醒, 继续执行</li></ul><p>案例: 秦始皇灭掉六国, 一统天下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举类创建六个国家</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">    one(<span class="number">1</span>, <span class="string">&quot;齐&quot;</span>), two(<span class="number">2</span>, <span class="string">&quot;楚&quot;</span>), three(<span class="number">3</span>, <span class="string">&quot;燕&quot;</span>),</span><br><span class="line">    four(<span class="number">4</span>, <span class="string">&quot;赵&quot;</span>), five(<span class="number">5</span>, <span class="string">&quot;魏&quot;</span>), six(<span class="number">6</span>, <span class="string">&quot;韩&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer retCode;</span><br><span class="line">    <span class="keyword">private</span> String retMessage;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountryEnum</span><span class="params">(Integer retCode, String retMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">        <span class="keyword">this</span>.retMessage = retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">getCountryEnum</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        CountryEnum[] countryEnums = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum countryEnum : countryEnums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countryEnum.getRetCode().equals(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> countryEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRetCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRetMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;国, 被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.getCountryEnum(i).getRetMessage()).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;秦国一统天下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/01.png"></p><p>额, 好像没有按照历史顺序来, 不过无伤大雅</p><h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p>CountDownLatch是一次性的, 计数器的值只能在构造方法中初始化一次, 之后没有任何机制再次对其设置值, 当CountDownLatch使用完毕后, 它不能再次被使用。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h2><h3 id="CyclicBarrier是什么"><a href="#CyclicBarrier是什么" class="headerlink" title="CyclicBarrier是什么"></a>CyclicBarrier是什么</h3><p>CyclicBarrier是一个同步辅助类, 它允许一组线程相互等待直到所有线程都到达一个公共的屏障点。<br>在程序中有固定数量的线程, 这些线程有时候必须等待彼此, 意思就是每个线程都得执行到等待点进行等待, 直到所有线程都执行到等待点, 才会继续往下执行。这种情况下, 使用CyclicBarrier很有帮助。这个屏障之所以用循环修饰, 是因为在所有的线程释放彼此之后, 这个屏障是可以重新使用的。</p><h3 id="CyclicBarrier的用法"><a href="#CyclicBarrier的用法" class="headerlink" title="CyclicBarrier的用法"></a>CyclicBarrier的用法</h3><p>构造方法:</p><ul><li><p>CyclicBarrier(int parties), 当等待线程数量达到parties时, 放行所有线程</p></li><li><p>CyclicBarrier(int parties，Runnable barrierAction), 当等待线程数量达到parties时, 放行所有线程, 并由最后一个线程执行barrierAction</p></li></ul><p>案例: 收集七龙珠召唤神龙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/02.png"></p><h3 id="CyclicBarrier与CountDownLatch的区别"><a href="#CyclicBarrier与CountDownLatch的区别" class="headerlink" title="CyclicBarrier与CountDownLatch的区别"></a>CyclicBarrier与CountDownLatch的区别</h3><ul><li>CyclicBarrier是对计数器做加法</li><li>CountDownLatch是对计数器做减法</li><li>CountdownLatch是一次性的</li><li>CycliBarrier是可以重复使用的, 使用<code>reset()</code>方法即可重置计数器</li></ul><h2 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore(信号灯)"></a>Semaphore(信号灯)</h2><h3 id="Semaphore是什么"><a href="#Semaphore是什么" class="headerlink" title="Semaphore是什么"></a>Semaphore是什么</h3><p>Semaphore是计数信号量。Semaphore管理一系列许可。每个acquire方法阻塞, 直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可, 这可能会释放一个阻塞的acquire方法。然而, 其实并没有实际的许可这个对象, Semaphore只是维持了一个可获得许可证的数量。</p><h3 id="Semaphore的用法"><a href="#Semaphore的用法" class="headerlink" title="Semaphore的用法"></a>Semaphore的用法</h3><ul><li>acquire(获取)当一个线程调用acquire操作时, 它要么通过成功获取信号量(信号量减1), 要么一直等下去, 直到有线程释放信号量, 或超时。</li><li>release(释放)实际上会将信号量的值加1, 然后唤醒等待的线程。</li><li>信号量主要用于两个目的, 一个是用于多个共享资源的互斥使用, 另一个用于并发线程数的控制。</li></ul><p>案例: 停车场抢车位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore, 设置许可量, 模拟三个车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟六辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车抢到车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/03.png"></p><p>可以看到, 如果有三个线程得到了许可, 那么剩下的线程就会被阻塞, 知道有线程释放许可, 才会随机释放一个被阻塞的线程获得许可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CountDownLatch-闭锁&quot;&gt;&lt;a href=&quot;#CountDownLatch-闭锁&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch(闭锁)&quot;&gt;&lt;/a&gt;CountDownLatch(闭锁)&lt;/h2&gt;&lt;h3 id=&quot;什么是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Callable接口</title>
    <link href="http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-04-06T08:56:46.000Z</published>
    <updated>2022-04-07T08:22:23.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>创建线程有四种方式:</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Callable接口</li><li>线程池</li></ul><p>前两种前面说过了, Runnable接口是比较常用的, 因为在Java中继承是很重要的, 不能随便使用, 但是Runnable接口有一个缺点, run()方法没有返回值, 也就是当线程结束时, 不能返回结果, 为了能返回结果, 在JDK1.5以后出现了Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Callable接口中的call()方法可以用来处理任务并返回一个结果, 如果无法处理, 则会抛出异常。</p></blockquote><p>Runnable和Callable的区别:</p><ul><li>Callable规定的方法是call(), Runnable规定的方法是run()</li><li>Callable的任务执行后可返回值, 而Runnable的任务是不能返回值</li><li>call()方法可以抛出异常, run()方法不能</li></ul><p>下面就写一个简单的类实现Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个10以内的随机数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当我们想要去创建这样一个线程去测试的时候发现, Thread的构造方法里没有一个是需要传入Callable接口的, 只能传入Runnable接口, 那么有什么方法可以让Callable接口转成Runnable接口呢?</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>先来看一下FutureTask的继承结构</p><p><img src="/img/2022-04-06/01.png"></p><p>FutureTask是Runnable的一个实现类, 再来看一下FutureTask的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要传入一个Callable接口, 那么使用FutureTask就可以将Callable接口转成Runnable接口了</p></blockquote><p>再来看一下FutureTask的另一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Runnable&#125;, and arrange that &#123;<span class="doctag">@code</span> get&#125; will return the</span></span><br><span class="line"><span class="comment"> * given result on successful completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result to return on successful completion. If</span></span><br><span class="line"><span class="comment"> * you don&#x27;t need a particular result, consider using</span></span><br><span class="line"><span class="comment"> * constructions of the form:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个FutureTask将在运行, 执行给定Runnable, 安排get()将返回给定的成功完成。 </p></blockquote><p>最后看一下FutureTask的常用方法</p><ul><li><code>get()</code>, 如果有必要等待计算完成, 然后获取它的结果</li><li><code>isDone()</code>, 如果正常终止, 或是发生异常, 或是手动取消, 返回true</li></ul><p>使用FutureTask来完成我们的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//普通创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> GetNumber());</span><br><span class="line">        <span class="comment">//Lambda表达式创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">            <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask1, <span class="string">&quot;tom&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask2, <span class="string">&quot;jerry&quot;</span>).start();</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom get &quot;</span> + integerFutureTask1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;jerry get &quot;</span> + integerFutureTask2.get());</span><br><span class="line">        <span class="comment">//主线程结束</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">        <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行结果:</p><p><img src="/img/2022-04-06/02.png"></p><p>运行成功!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;创建线程有四种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;实现R</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之各种锁</title>
    <link href="http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/</id>
    <published>2022-04-05T05:06:01.000Z</published>
    <updated>2022-04-05T10:43:45.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>回头看一下之前的一个多线程买票案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/01.png"></p><p>CC线程几乎卖出了一多半的票, 而BB线程只卖出了2张票, 这是因为在线程抢占的过程中, CC总能抢到锁, 这样就容易导致其他线程饥饿, 那么为什么会这样呢? 来看一下ReentrantLock的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字面意思上也能看出来, ReentrantLock在创建的时候如果不传入任何参数, 默认创建的是一个非公平锁, 当传入一个布尔值为<strong>true</strong>时, 创建的则是一个公平锁, 使用公平锁修改上面的案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/02.png"></p><p>可以看到, 当三个线程都创建完成后, 遵循的就是一个线程卖一张票的的规则, 很公平, 但是公平锁也有缺点, 那就是效率低下, 所以使用的时候还是要视情况而定。</p><blockquote><p>注意: synchronized 和 ReentrantLock 默认是非公平锁</p></blockquote><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>什么是可重入锁?</p><ul><li>可重入锁又称递归锁, 是指在同一个线程在外层方法获取锁的时候, 再进入该线程的内层方法会自动获取锁(前提,锁对象得是同一个对象), 不会因为之前已经获取过还没有释放而阻塞</li><li>Java中synchronized和ReentrantLock都是可重入锁, 可重入锁的存在就是为了在一定程度上避免<strong>死锁</strong></li></ul><p>只看概念不太能理解可重入锁这个东西, 来通过代码演示一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外中内三层代码块上的都是同一把锁o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入中层&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/03.png"></p><p>可以看到因为三层代码块用的是同一把锁, 所以不用等到上一层得到锁的代码块释放锁就能进入, 接着看一下ReentrantLock版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock演示可重入锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/04.png"></p><p>依旧是不用等到上一层代码块的锁释放就可以得到锁进入代码块</p><blockquote><p>注意: lock的lock()和unlock()方法要一一对应, 否则会对其他线程造成影响</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>什么是死锁?</p><ul><li><p>死锁是指两个或两个以上的线程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力干涉那它们都将无法推进下去, 如果资源充足, 进程的资源请求都能够得到满足, 死锁出现的可能性就很低, 否则就会因争夺有限的资源而陷入死锁</p></li><li><p>如果有两个线程各自持有一把锁, 却同时想获取对方的锁而双发都未释放锁, 这时就产生了死锁</p><p>  <img src="/img/2022-04-05/05.png"></p></li></ul><p>来看一下代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁a, 等待锁b释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁b, 等待锁a释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/06.png"></p><p>两个线程都在等待对方的锁释放, 然而如果它们获取不到对方的锁就不会释放自己的锁, 这就产生了死锁, 如果我们不人为去干预, 会一直卡在这里占用系统资源, 但是很多时候思索地产生是因为资源分配不当导致的, 我们很难这么清晰的观察到, 那么就需要通过命令的方式排查死锁并人为关闭死锁线程</p><blockquote><p>在终端输入jps排查进程</p><p>PS D:\JUC\JUC_study\one&gt; jps<br>16640 Jps<br>28472 Launcher<br>17164<br>7692 DeadLock</p><p>发现除正常线程以外, 还有一个一直在的进程7692, 使用堆栈跟踪工具jstack查看此进程</p><p>PS D:\JUC\JUC_study\one&gt; jstack 7692<br>2022-04-05 15:47:56</p><p>Found one Java-level deadlock:</p><p>“B”:<br>  waiting to lock monitor 0x0000000017a206f8 (object 0x00000000d6046488, a java.lang.Object),<br>  which is held by “A”<br>“A”:<br>  waiting to lock monitor 0x0000000017a23038 (object 0x00000000d6046498, a java.lang.Object),<br>  which is held by “B”</p><p>Java stack information for the threads listed above:</p><p>“B”:<br>        at com.ayu.sync.DeadLock.lambda$main$1(DeadLock.java:39)</p><pre><code>    - waiting to lock &lt;0x00000000d6046488&gt; (a java.lang.Object)    - locked &lt;0x00000000d6046498&gt; (a java.lang.Object)            at com.ayu.sync.DeadLock$$Lambda$2/990368553.run(Unknown Source)            at java.lang.Thread.run(Thread.java:748)</code></pre><p>“A”:<br>                at com.ayu.sync.DeadLock.lambda$main$0(DeadLock.java:25)<br>        - waiting to lock &lt;0x00000000d6046498&gt; (a java.lang.Object)<br>        - locked &lt;0x00000000d6046488&gt; (a java.lang.Object)<br>                at com.ayu.sync.DeadLock$$Lambda$1/2003749087.run(Unknown Source)<br>                at java.lang.Thread.run(Thread.java:748)</p><p>Found 1 deadlock.</p><p>果然发现了一个死锁进程, 可以通过重新分配资源的方式解决, 也可以直接杀掉此进程(前提是此进程不重要)</p><p>PS D:\JUC\JUC_study\one&gt; kill 7692</p></blockquote><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁:</p><ul><li>认为自己在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确保数据不会被别的线程修改</li><li>适合写操作多的场景, 先加锁可以保证写操作时数据正确(写操作包括增删改), 显式的锁定之后再操作同步资源</li><li>synchronized关键字和Lock的实现类都是悲观锁</li></ul><p><img src="/img/2022-04-05/07.png"></p><p>乐观锁:</p><ul><li>乐观锁认为自己在使用数据时不会有别的线程修改数据, 所以不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据, 如果这个数据没有被更新, 当前线程将自己修改的数据成功写入, 如果数据已经被其他线程更新, 则根据不同的实现方式执行不同的操作</li><li>适合读操作多的场景, 不加锁的特点能够使其读操作的性能大幅度提升</li><li>乐观锁一般有两种实现方式(采用版本号机制、CAS算法实现)</li><li>乐观锁在Java中通过使用无锁编程来实现, 最常采用的时CAS算法, Java原子类中的递增操作就通过CAS自旋实现的</li></ul><p><img src="/img/2022-04-05/08.png"></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在多线程对同一资源进行操作的时候肯定是要加锁的, 对于写操作(增删改)来说, 肯定是要考虑并发场景下的操作原子性的, 所以写操作必须是独占锁, 但是对于读操作来说, 多线程同时读一个资源并没有任何问题, 为了满足并发情况下的效率, 读操作应为共享锁。为了满足这种需求就出现了<strong>读写锁</strong>。</p><p>读写锁特点:</p><ul><li>读-读可以共享</li><li>读-写互斥</li><li>写-写互斥</li></ul><blockquote><p>Java中读写锁为<code>ReentrantReadWriteLock</code></p><p>读锁为<code>ReentrantReadWriteLock.ReadLock</code>, 使用<code>readLock()</code>方法获得</p><p>写锁为<code>ReentrantReadWriteLock.WriteLock</code>, 使用<code>writeLock()</code>方法获得</p></blockquote><p>用一个小案例来演示一下读写锁的使用: 多个线程对Map进行写入和读取操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">//创建写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.put(number + <span class="string">&quot;&quot;</span>, number + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.get(<span class="string">&quot;&quot;</span> + number);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁, 独占锁啊</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行写操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写操作结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加读锁, 共享锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读操作结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/09.png"></p><p>可以看到, 写操作未结束时, 不会有其他的线程进行操作, 但是读操作未结束时, 其他读操作线程也可以进行操作, 这就说明写锁是独占的, 读锁是共享的。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>如果我们在做完写操作之后又想进行读操作, 但是由于写锁是独占锁, 这时候进行读操作很浪费资源, 这时候就可以将写锁降级为读锁, 这样读取的时候其他线程也能共享读取</p><p>具体步骤:</p><p>获取写锁-&gt;进行写操作-&gt;获取读锁-&gt;释放写锁-&gt;进行读操作-&gt;释放读锁</p><p>代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写锁上锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁降级, 先读锁上锁再释放写锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        <span class="comment">//进行读操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放读锁, 操作完成</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/10.png"></p><p>成功从写锁降级成读锁</p><p>写锁可以降级为读锁, 那么读锁可不可以升级为写锁呢, 把上面的代码改一下试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读锁上锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁升级, 先写锁上锁再释放读锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放写锁</span></span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-04-05/11.png"></p><p>卡在这里了, 说明不能将读锁升级为写锁!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;p&gt;回头看一下之前的一个多线程买票案例&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之锁的八种情况</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/</id>
    <published>2022-03-27T07:30:47.000Z</published>
    <updated>2022-03-27T08:23:20.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据我们以下八种情况来进行调用"><a href="#根据我们以下八种情况来进行调用" class="headerlink" title="根据我们以下八种情况来进行调用"></a>根据我们以下八种情况来进行调用</h2><ol><li><p>标准访问, 两个线程, 各自访问一个方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote></li><li><p>在sendSMS方法中停留4秒, 其余与第一种情况一样</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//停留4秒</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote><p> 1-2情况说明:</p><ul><li>一个对象里面如果有多个synchronized方法, 某一个时刻内, 只要一个线程去调用其中的一个synchronized方法了, 其它的线程都只能等待, 换句话说,某一个时刻内, 只能有唯一的一个线程去访问这些synchronized方法</li></ul><ul><li> 锁的是当前对象this, 被锁定后, 其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul></li><li><p>新增普通方法hello(), 第一个线程调用sendSMS(), 第二个线程调用hello()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源类中增加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主类中修改</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    phone.hello();</span><br><span class="line">&#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——hello<br>——sendSMS</p></blockquote></li><li><p>创建两个Phone实例, 一个调用sendSMS, 一个调用sendEmail</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 3-4情况说明:</p><ul><li>普通方法与锁无关, 不会被阻塞</li><li>两个实例对象不是同一把锁</li></ul></li><li><p>将sendSMS()和sendEmail()变成静态方法, 一个实例对象去调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote></li><li><p>两个实例对象调用静态方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote><p> 5-6情况说明:</p><ul><li>对于普通方法来说, 锁的对象是this, 也就是当前实例对象</li><li>对于静态方法来说, 锁的对象就是当前类的Class对象, 也就是说这个类的所有实例对象公用同一把锁</li></ul></li><li><p>一个静态方法, 一个普通方法, 一个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote></li><li><p>一个静态方法, 一个普通方法, 两个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 7-8情况说明:</p><ul><li>不管是一个实例对象还是多个实例对象, 普通同步方法与静态同步方法的锁都不是同一把</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之集合线程安全</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-03-27T05:43:59.000Z</published>
    <updated>2022-03-27T07:01:47.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合演示"><a href="#List集合演示" class="headerlink" title="List集合演示"></a>List集合演示</h2><p>先来看下面一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//多线程并发访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个ArrayList集合, 下面十个线程每个都往里放一条数据并读取这个集合, 看一下运行结果</p><p><img src="/img/2022-03-27/01.png" alt="image-20220327140910524"></p><p>报了java.util.ConcurrentModificationException这么一个错误, 这个错误是并发修改异常, 看一下ArrayList的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add()这个方法没有加synchronized关键字也没有Lock接口, 说明这是一个线程不安全的类。</p><p>想要线程安全有以下三种解决方法</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector也是List的子类, 并且Vector的方法有synchronized关键字修饰, 所以Vector是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们只需要将ArrayList改为Vector就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但是Vector在高并发情况下的性能堪忧, 所以不推荐使用</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>使用Collections工具类返回一个线程同步列表, 方法是<code>Collections.synchronizedList(List<T> list)</code></p><p>改一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>但是这种方法也比较过时了, 不推荐使用</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList底层使用<strong>写时复制技术</strong>, 每次往列表里写入的时候会复制整个列表到新的列表, 读的时候读原来的那个旧的, 当写操作进行完之后再将新老列表合并覆盖, 我们推荐使用写时复制列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><p>同理, 来看一下另外两个常用的集合类, <code>HashSet</code>和 <code>HashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的add方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看的出来, 这两个类都是线程不安全的。</p><ul><li><p>Set想要实现线程安全, 推荐使用<code>CopyOnWriteArraySet</code>, 底层同样是写时复制技术</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>Map推荐使用<code>ConcurrentHashMap</code>, 底层使用自旋锁CAS实现线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List集合演示&quot;&gt;&lt;a href=&quot;#List集合演示&quot; class=&quot;headerlink&quot; title=&quot;List集合演示&quot;&gt;&lt;/a&gt;List集合演示&lt;/h2&gt;&lt;p&gt;先来看下面一段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程间通信</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2022-03-26T13:21:25.000Z</published>
    <updated>2022-03-26T15:09:43.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>谈到线程间通信就不得不说一个经典的生产者-消费者模型, 我们假定这样一个场景:</p><ol><li>一个小小的饮品店, 桌子太小了每次只能放一杯饮品</li><li>桌子上没有饮品的时候顾客就会等待</li><li>桌子上有饮品的时候店长就不做了(很佛系)</li></ol><p>我们尝试用代码实现以下这个场景:</p><ol><li><p>把饮品店, 饮品, 做饮品, 取饮品给抽象出来</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的具体实现, 考虑多线程操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>来个main()方法调用一下</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行一下:</p><p> <img src="/img/2022-03-26/11.png"></p><p> 发现非常和睦, produce1做一杯, consume1买一杯。</p></li></ol><p>这时我们需求升级了, 多来个做饮品的, 买饮品的也多排了一队, 但是桌子还是那么大, 简单, 我们再来两个线程就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建生产线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce2&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/12.png"></p><p>出大问题, 不是说好的桌子上只能放一杯么, 为什么会出现这种问题呢, 那是因为在程序中发生了虚假唤醒:</p><p>之前说过, wait()这个方法是在哪里停下就在那里开始, 回头看一眼代码两个方法中进行判断的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用while循环替代if, 这样每次醒过来就会重新进行判断, 改完之后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次看一下运行结果: </p><p><img src="/img/2022-03-26/13.png"></p><p>又和睦起来了!</p><h3 id="多线程编程步骤"><a href="#多线程编程步骤" class="headerlink" title="多线程编程步骤"></a>多线程编程步骤</h3><p>经过上面的那个案例, 可以总结一下四个步骤:</p><ol><li>创建资源类, 在资源类中创建共享属性和操作方法</li><li>在资源类操作方法: 判断、操作、通知</li><li>创建多个线程, 调用资源类的操作方法</li><li>防止虚拟唤醒问题</li></ol><h3 id="Lock接口版"><a href="#Lock接口版" class="headerlink" title="Lock接口版"></a>Lock接口版</h3><p>既然synchronized可以实现上面的案例, 那么Lock接口肯定也可以实现, 使用Condition的两个方法实现线程等待和唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//获得condition实例</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有咱就做一杯</span></span><br><span class="line">            water++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有就取走</span></span><br><span class="line">            water--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉店家该做了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/14.png"></p><p>完美复刻!</p><h3 id="线程定制化通信"><a href="#线程定制化通信" class="headerlink" title="线程定制化通信"></a>线程定制化通信</h3><p>上面案例的结果都有一个特点, 两个生产者和两个消费者出现的很乱, 有没有可能让线程间按照我们想要的顺序运行呢?</p><p>来看一个简单案例, 要求是</p><ul><li>AA, BB, CC三个线程, 每个线程调用一个方法</li><li>执行顺序是AA-&gt;BB-&gt;CC</li><li>循环执行10轮</li></ul><p>看一下思路</p><p><img src="/img/2022-03-26/15.png"></p><p>根据这个思路, 来编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    Condition cA = lock.newCondition();</span><br><span class="line">    Condition cB = lock.newCondition();</span><br><span class="line">    Condition cC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//A方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                cA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodA : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为2</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//cB唤醒</span></span><br><span class="line">            cB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                cB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodB : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为3</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//cC唤醒</span></span><br><span class="line">            cC.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                cC.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodC : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cA唤醒</span></span><br><span class="line">            cA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个主类测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下运行结果</p><p><img src="/img/2022-03-26/16.png"></p><p>按照我们的需求完美运行, 这就是线程定制化通信!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识锁</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/</id>
    <published>2022-03-26T07:14:57.000Z</published>
    <updated>2022-03-26T15:10:28.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先来看一段代码"><a href="#先来看一段代码" class="headerlink" title="先来看一段代码"></a>先来看一段代码</h2><p>使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下运行结果:</p><p><img src="/img/2022-03-26/01.png"> </p><p>我们发现一个很奇怪的事情, 买票的顺序不是从19到0, 是一个很混乱的顺序, 这是为什么呢? 因为我们在多个线程进行操作的时候难免会发生线程抢占, 明明我这个线程进来做完操作了准备打印结果, 但这时又被另一个线程抢了过去运行权, 它先打印了结果, 我这好不容易再次抢了回来, 可这时已经晚了, 打印出了原本的结果, 可这个结果却是过时错误的结果, 那么怎样避免这样的事发生呢, 我们就需要给买票操作加把锁。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>synchronized是Java中的关键字, 中文意思是同步, 也称之为”同步锁”。</p><p>作用主要有三个:</p><ul><li>原子性: 确保线程互斥地访问同步代码</li><li>可见性: 保证共享变量的修改能够及时可见, 其实是通过Java内存模型中的”对一个变量unlock操作之前, 必须要同步到主内存中; 如果对一个变量进行lock操作, 则将会清空工作内存中此变量的值, 在执行引擎使用此变量前, 需要重新从主内存中load操作或assign操作初始化变量值 “来保证的</li><li>有序性: 有效解决重排序问题, 即”一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</li></ul></blockquote><p>synchronized的3种使用方式:</p><ul><li><p>修饰实例方法: 作用于当前实例加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意: </p><ul><li>在定义接口方法时不能使用synchronized关键字。</li><li>构造方法不能使用synchronized关键字, 但可以使用synchronized代码块来进行同步。 </li></ul></li><li><p>修饰静态方法: 作用于当前类对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  与上一个不同的是, 被synchronized修饰的静态方法是对于这个类的所有实例对象都起作用的, 也就是说所有这个类的实例对象用的是同一把锁。</p></li><li><p>修饰代码块: 指定加锁对象, 对给定对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给这个类的某一代码块加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给这个对象加锁</span></span><br><span class="line">Object obj;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在我们就可以使用synchronized帮我们上边的例子进行加锁操作, 很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一看运行结果:</p><p><img src="/img/2022-03-26/02.png"> </p><p>很明显, 票按照正常的顺序出售了。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><blockquote><p>Lock是java.util.concurrent.locks包下常用的接口</p><p>代表实现类是ReentrantLock(可重入锁)</p></blockquote><p>常用方法:</p><ul><li>lock(): 获取锁, 也就是给下面操作上锁</li><li>unlock(): 释放锁</li></ul><p>被lock()上锁后即使发生异常也不会释放锁, 所以我们通常在lock()方法后紧跟try…catch…块, 并将unlock()释放锁方法放在finally块中, 以此来保证锁的释放, 防止死锁的产生。</p><p>下面我们使用Lock接口对上面的例子进行修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//lock()方法一定紧跟try块</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有余票</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/03.png"> </p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>synchronized与Lock的异同：</p><ul><li>synchronized是java关键字, 内置, 而lock不是内置, 是一个接口, 可以实现同步访问且比synchronized中的方法更加丰富</li><li>synchronized不用手动释放锁, 而lock需手动释放锁(不解锁会出现死锁, 需要在 finally 块中释放锁)</li><li>Lock等待锁的线程会响应中断, 而synchronized不会响应，只会一直等待</li><li>通过 Lock 可以知道有没有成功获取锁, 而 synchronized 却无法办到</li><li>Lock 可以提高多个线程进行读操作的效率(当多个线程竞争的时候)</li></ul><h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>在synchronized中, 如果要对线程进行一些操作可以使用Object类自带的这些方法:</p><ul><li>wait(): 让当前线程进入等待, 并且遵循在哪里停下, 被唤醒时就在哪里开始的原则</li><li>notify(): JVM随机唤醒一个线程</li><li>notifyAll(): 唤醒所有线程</li></ul><p>而Lock锁可以使用newCondition()方法返回一个Condition对象, Condition类中有下面几个方法:</p><ul><li>await(): 使当前线程进入等待, 并且释放锁, 当被其他线程调用signal()唤醒时会重新获得锁</li><li>signal(): 唤醒被这个Condition实例等待的线程</li><li>signalAll(): 唤醒所有线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;先来看一段代码&quot;&gt;&lt;a href=&quot;#先来看一段代码&quot; class=&quot;headerlink&quot; title=&quot;先来看一段代码&quot;&gt;&lt;/a&gt;先来看一段代码&lt;/h2&gt;&lt;p&gt;使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识线程</title>
    <link href="http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-25T08:01:21.000Z</published>
    <updated>2022-03-26T10:02:57.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:</p><blockquote><p>进程（Process）</p><ul><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>进程是线程的容器</li><li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li><li>系统进行资源分配和调度的基本单位，是操作系统结构的基础</li></ul><p>线程（thread）</p><ul><li>操作系统能够进行运算调度的最小单位</li><li>被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流</li></ul></blockquote><p>如果没有操作系统知识的话有点难理解上面的话, 我用一个简单的比喻来解释一下, 把一个进程比作一辆正在运行的火车, 那么线程就是火车中的一个车厢, 每个车厢里都在干着自己的事, 车厢与车厢之间可以相互连通的。听不懂也没有关系, 抽象的概念往往是难以理解的, 会在后面的学习中不断领悟。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>我们平常写的程序只有一个main()方法入口, 这就是一个典型的单线程程序, 为了后面的学习我们先来认识一下<strong>Thread</strong>这个类和这个类中一些常用的方法:</p><blockquote><p>public class Thread extends Object<br>                                    implements Runnable</p><p>线程是一个线程的执行程序。Java虚拟机允许应用程序同时运行多个线程的执行。 </p></blockquote><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody><tr><td><code>start()</code></td><td>开始执行这个线程;Java虚拟机调用 <code>run</code>这个线程的方法。</td></tr><tr><td><code>sleep(long millis)</code></td><td>线程睡眠(暂时停止执行)指定的毫秒数。</td></tr><tr><td><code>currentThread()</code></td><td>返回当前线程的引用。</td></tr><tr><td><code>getName()</code></td><td>返回当前线程的名称。</td></tr><tr><td><code>setDaemon(boolean on)</code></td><td>将线程设置为守护线程或用户线程。</td></tr><tr><td><code>isDaemon()</code></td><td>这个线程是否为一个守护线程。</td></tr></tbody></table><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>通过线程枚举类的状态我么可以得知有以下六种状态:</p><ul><li><strong>NEW</strong>, 创建线程</li><li><strong>RUNNABLE</strong>, 线程准备就绪</li><li><strong>BLOCKED</strong>, 线程阻塞</li><li><strong>WAITING</strong>, 线程等待(会一直等待)</li><li><strong>TIMED_WAITING</strong>, 线程等待(超时会取消等待状态)</li><li><strong>TERMINATED</strong>, 线程终结(消亡)</li></ul><p>线程状态之间的相互转换:</p><p><img src="/img/2022-03-25/02.jpg"></p><h3 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h3><ul><li><p>通过继承Thread类(不推荐)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为在Java中继承是很宝贵的, 每个类只能继承一个类, 所以我们通常不使用这种方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过实现Runnable接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用匿名内部类实现Runnable接口传入Thread(常用)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Runnable接口是一个函数式接口, 所以我们可以使用Lambda表达式简化开发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Callable接口</p></li><li><p>使用线程池创建</p></li></ul><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><ul><li>用户线程是自定义的线程</li><li>守护线程是后台的特殊线程, 依赖于创建它的线程, 比如JVM的垃圾回收</li><li>主线程如果结束了用户线程还在执行, JVM还会存活</li><li>没有用户线程后，剩下都是守护线程, JVM就会结束</li></ul><p>我们写个小Demo来演示以下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/03.png"></p><p>发现程序打印完并未结束, 是因为我们自己创建的线程是用户线程, 而用户线程不结束, JVM是不会结束的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    aa.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    aa.start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/04.png"></p><p>程序直接结束了, 这是因为我们将自己创建的线程设置为了守护线程, 当只剩下守护线程, JVM就会结束。</p><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><blockquote><p>不同点:</p><ul><li>wait()是Object 的方法, 会释放锁, 调用它的前提是当前线程占有锁(即代码要在 synchronized 中)</li><li>sleep()是Thread 的静态方法, 任何对象实例都能调用, 不会释放锁, 也不需要占用锁</li></ul><p>相同点:</p><ul><li>都可以被interrupted()方法中断</li></ul></blockquote><h3 id="串行、并行和并发"><a href="#串行、并行和并发" class="headerlink" title="串行、并行和并发"></a>串行、并行和并发</h3><ul><li><p><strong>串行</strong>表示程序所有任务都按先后顺序进行</p></li><li><p><strong>并行</strong>表示程序同时执行多个任务</p></li><li><p><strong>并发</strong>(concurrent)：同一时刻多个线程访问统一资源</p></li></ul><p><img src="/img/2022-03-25/05.png"></p><blockquote><p>实际上, 对于单核 CPU 来说, 同一时刻只能运行一个线程, 所以, 这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象, 这是并行的概念, 而是提供一种功能让用户看来多个程序同时运行起来了, 但实际上这些程序中的进程不是一直霸占 CPU 的, 而是执行一会停一会。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h2&gt;&lt;p&gt;在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:&lt;/p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC配置与使用</title>
    <link href="http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-07T08:03:00.000Z</published>
    <updated>2021-12-08T14:50:34.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件和注解, 我们都会一一讲到。</p><h2 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h2><p>IOC容器的底层就是对象工厂</p><p>Spring提供了IOC容器的两种实现方式(两个接口):</p><ul><li><p>BeanFactory: IOC容器基本实现, 是Spring内部使用的接口, 不提供给开发人员使用, <strong>加载文件的时候不会船舰对象, 在获取对象的时候才会创建对象</strong>。</p></li><li><p>ApplicationContext: BeanFactory接口的子接口, 提供更多更强大的功能, <strong>加载配置文件的时候就会把在配置文件中配置好的对象进行创建</strong>。</p><p>ApplicationContext的四个常用实现类:</p><ul><li><strong>FileSystemXmlApplicationContext：</strong>加载配置文件的时候采用的是项目的路径, 也就是绝对路径。</li><li><strong>ClassPathXmlApplicationContext：</strong>加载配置文件的时候根据ClassPath位置, 也就是项目相对路径。</li><li><strong>XmlWebApplicationContext：</strong>在Web环境下初始化监听器的时候会加载该类。</li><li><strong>AnnotationConfigApplicationContext：</strong>根据注解的方式启动Spring 容器。</li></ul></li></ul><h2 id="SpringDI的方式"><a href="#SpringDI的方式" class="headerlink" title="SpringDI的方式"></a>SpringDI的方式</h2><p>​    Spring提供了三种方式来依赖注入,有构造方法注入, setter方法注入以及接口注入。其中Spring以往推荐使用Setter的方法现在改成推荐构造方法注入。使用构造方法注入需要注意的一点就是要避免循环依赖。所谓的循环依赖指的就是在A对象的构造方法中Spring要注入B，而在B对象中Spring要注入A。这个时候会形成一个闭环因为Spring不知道该先注入哪一个接着会抛出异常。而Spring建议的处理方式是说如果遇到这种情况的话就改用Setter方式注入。</p><h2 id="Bean管理-基于xml"><a href="#Bean管理-基于xml" class="headerlink" title="Bean管理(基于xml)"></a>Bean管理(基于xml)</h2><h3 id="基于xml创建对象"><a href="#基于xml创建对象" class="headerlink" title="基于xml创建对象:"></a>基于xml创建对象:</h3><ul><li>在Spring配置文件中, 使用bean标签创建对象</li><li>在bean标签中有多个属性, 常用的有:<ul><li>id: 唯一标识, 用于获取对象</li><li>class: 类的全路径</li></ul></li><li>创建对象的时候, 默认的是执行无参构造方法完成对象创建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性:"></a>基于xml方式注入属性:</h3><ul><li><p>使用set方法进行注入</p><p>在bean标签内使用property标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用set方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用有参构造器进行注入</p><p>在bean标签内使用constructor-arg标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用有参构造方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jerry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入其他属性"><a href="#xml注入其他属性" class="headerlink" title="xml注入其他属性:"></a>xml注入其他属性:</h3><ul><li><p>字面量</p><ul><li><p>null值</p><p>使用<code><null/></code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊符号</p><p>使用CDATA</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特殊字符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[&lt;&lt;时生&gt;&gt;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注入外部bean</p><p>使用ref属性注入外部创建好的bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--外部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注入内部bean</p><p>直接在property标签里创建bean标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;101&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联赋值</p><p>对属性里的bean对象的属性进行赋值操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;102&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入集合属性"><a href="#xml注入集合属性" class="headerlink" title="xml注入集合属性:"></a>xml注入集合属性:</h3><ul><li>array标签对数组进行赋值</li><li>list标签对List集合进行赋值</li><li>set标签对Set集合进行赋值</li><li>map标签对Map集合进行赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>go<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java&quot;</span> <span class="attr">value</span>=<span class="string">&quot;88&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;c++&quot;</span> <span class="attr">value</span>=<span class="string">&quot;78&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>SQLServer<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SpringMVC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用util标签共享bean"><a href="#使用util标签共享bean" class="headerlink" title="使用util标签共享bean:"></a>使用util标签共享bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                    http://www.springframework.org/schema/util</span><br><span class="line">                    http://www.springframework.org/schema/util/spring-util-2.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用util标签来配置共享的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>大话数据结构<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>程序是怎样跑起来的<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>操作系统导论<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用p命名空间配置bean"><a href="#使用p命名空间配置bean" class="headerlink" title="使用p命名空间配置bean:"></a>使用p命名空间配置bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用p命名空间来配置bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域:"></a>Bean作用域:</h3><p>Spring中可以使用scope属性来配置bean的作用域：</p><ul><li>singleton: 单例, 在初始化配置文件时生成单例bean对象(<strong>默认</strong>)</li><li>prototype: 原型的, 在初始化配置文件时不生成bean对象, 使用时返回不同的bean对象</li><li>request: web环境下每一个request请求都会返回一个不同的bean, 只在本次请求中有效</li><li>session: web环境下每一个request请求都会返回一个不同的bean, 在session中有效</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置scope属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期:"></a>Bean生命周期:</h3><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个测试用的Order类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.set方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">        Order order = context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;4.获取到bean对象&quot;</span>);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Order&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>3.初始化方法<br>4.获取到bean对象<br>com.ayu.bean.Order@69b0fd6f<br>5.销毁方法</p></blockquote><h3 id="Bean的后置处理器"><a href="#Bean的后置处理器" class="headerlink" title="Bean的后置处理器:"></a>Bean的后置处理器:</h3><p>使用后置处理器后的生命周期:</p><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>将bean传给后置处理器的postProcessBeforeInitialization方法</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>将bean传给后置处理器的postProcessAfterInitialization方法</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个后置处理器类实现BeanPostProcessor接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中配置BeanPostProcessor:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>初始化之前<br>3.初始化方法<br>初始化之后<br>4.获取到bean对象<br>com.ayu.bean.Order@66d1af89<br>5.销毁方法</p></blockquote><h3 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h3><p>bean标签的autowire属性实现自动装配, autowire有两个常用的值:</p><ul><li><p>byName: 根据属性名称注入, 注入值bean的id值和类属性值名称需一样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType: 根据属性类型注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注: 通过byType自动装配,已配置的bean中有多个该类型的bean时会报错</p></li></ul><h2 id="Bean管理-基于注解"><a href="#Bean管理-基于注解" class="headerlink" title="Bean管理(基于注解)"></a>Bean管理(基于注解)</h2><h3 id="Spring针对bean管理提供的注解"><a href="#Spring针对bean管理提供的注解" class="headerlink" title="Spring针对bean管理提供的注解"></a>Spring针对bean管理提供的注解</h3><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p><ul><li><strong>@Controlle</strong>r: 控制器, 推荐给controller层添加此注解。</li><li><strong>@Service</strong>: 业务逻辑, 推荐给业务逻辑层添加此注解。</li><li><strong>@Repository</strong>: 仓库管理, 推荐给数据访问层添加此注解。</li><li><strong>@Component</strong>: 给不属于以上基层的组件添加此注解。</li></ul><h3 id="基于注解实现对象创建"><a href="#基于注解实现对象创建" class="headerlink" title="基于注解实现对象创建"></a>基于注解实现对象创建</h3><ol><li><p>开启组件扫描:</p><p>如果扫面多个包, 可以用逗号隔开, 或是扫描包的上层目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建类, 在类上添加对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value属性可以不写, 会默认类名首字母小写为value的值</span></span><br><span class="line"><span class="meta">@Repository(value=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="开启组件扫描细节配置"><a href="#开启组件扫描细节配置" class="headerlink" title="开启组件扫描细节配置"></a>开启组件扫描细节配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例一：use-default-filters表示现在不使用默认filter，自己配置filter</span></span><br><span class="line"><span class="comment">content:include-filter 设置扫面那些内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例二：下面配置扫面包所有内容</span></span><br><span class="line"><span class="comment">content:exclude-filter 设置哪些内容不进行扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解实现属性注入"><a href="#基于注解实现属性注入" class="headerlink" title="基于注解实现属性注入"></a>基于注解实现属性注入</h3><ul><li><p><strong>@Autowired</strong>: 根据属性类型进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier</strong>: 根据属性名称进行注入, 通常和@Autowired一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="comment">//区别同一接口下多个实现类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>: 可以根据类型注入，也可以根据名称注入(这个注解是JDK提供的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDaO;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Value</strong>: 注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;service&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类, 代替xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.ayu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此时应使用<strong>AnnotationConfigApplicationContext</strong>这个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnnotationConfigApplicationContext需要将配置类传给它</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">userService.hello();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>IOC容器解析</title>
    <link href="http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-04T06:51:28.000Z</published>
    <updated>2021-12-07T08:10:31.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!</p><h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><h3 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h3><p>​    在了解什么是IOC之前, 我们先来了解一下, IOC为什么出现, 以及我们为什么要使用IOC。</p><p>​    在面向对象设计的程序系统里, 有N多个类, 这些类与类相互依赖, 相互合作, 我们的程序才能完整的运行起来, 但是久而久之就发现一些问题, 如果对一个类结构进行更改, 那么与这个类直接依赖或间接依赖的类也要做出相对应的更改; 就像一块精密的手表, 里面多个独立的齿轮相互啮合在一起, 才能正常工作, 但如果更换其中一个齿轮, 变成其他型号, 那么如果别的齿轮不去更换, 手表就很难再继续运行了; 齿轮之间的啮合就像我们程序系统里的耦合一样, 耦合是不能消除的, 我们只能尽量去降低他, 而IOC的出现就是为了解决这个问题。</p><p><img src="/img/2021-12-04/ioc-1.png"></p><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>​    控制反转（Inversion of Control，缩写为IOC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。(引用自百度百科)</p><p>​    IOC的思想就是借助”第三方”实现依赖关系对象之间的解耦, 如下图所示:</p><p><img src="/img/2021-12-04/ioc-2.png"></p><p>​    由于引进了中间位置的“第三方”, 也就是IOC容器, 使得A、B、C、D这4个对象没有了耦合关系, 齿轮之间的传动全部依靠“第三方”了, 全部对象的控制权全部上缴给“第三方”IOC容器, 所以, IOC容器成了整个系统的关键核心, 它起到了一种类似“粘合剂”的作用, 把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”, 对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p>​    如果我们把IOC这个第三方拿掉, 这个系统就变成了:</p><p><img src="/img/2021-12-04/ioc-3.png"></p><p>​    这时候, A、B、C、D这4个对象之间已经没有了耦合关系, 彼此毫无联系, 这样的话, 当你在实现A的时候, 根本无须再去考虑B、C和D了, 对象之间的依赖关系已经降低到了最低程度。</p><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>​    IOC底层使用xml解析, 工厂模式, 和反射技术。</p><p><img src="/img/2021-12-04/ioc-4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!&lt;/p&gt;
&lt;h2 id=&quot;IOC原理</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四大特性以及事务的隔离级别</title>
    <link href="http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-10-15T08:15:16.000Z</published>
    <updated>2022-04-07T13:40:14.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明事务的隔离级别。</p><h2 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性(ACID)"></a>四大特性(ACID)</h2><p>​    如果一个数据库支持事务操作, 那么该数据库必须具备以下四大特性:</p><ul><li><p><strong>原子性(Atomicity)</strong></p><p>​        一个事务(transaction)中的所有操作, 要么全部完成,要么全部不完成, 不会在中间某个环节结束, 事务在执行过程中发生错误, 会被回滚(Rollback)到事务开始前的状态, 就像这个事务从来没有被执行过一样。</p></li><li><p><strong>一致性(Consistency)</strong></p><p>​        在事务开始之前和结束以后, 数据库的完整性没有被破坏, 这表示写入的资料必须完全符合所有的预设规则, 这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性(Isolation)</strong></p><p>​        数据库允许多个并发事务同时对其数据进行修改和读写的能力, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致, 事务隔离分为不同级别, 这里我们后面会讲到。</p></li><li><p><strong>持久性(Durability)</strong></p><p>​        事务处理结束后, 对数据的修改就是永久的, 即使系统故障也不会丢失。</p></li></ul><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><ul><li><strong>BEGIN</strong> 或 <strong>START TRANSACTION</strong> 开启一个事务</li><li><strong>COMMIT</strong> 提交事务, 并使已对数据库进行的修改成为永久性的</li><li><strong>ROLLBACK</strong> 回滚并结束用户的事务, 撤销正在进行的所有未提交的修改</li><li><strong>ASAVEPIOINT identifier</strong> 在事务中创建一个保存点, 一个事务中可以有多个保存点</li><li><strong>RELEASE SAVEPOINT identifier</strong> 删除一个事务的保存点</li><li><strong>ROLLBACK TO identifier</strong> 把事务回滚到保存点</li></ul><h2 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a>脏读、不可重复读和幻读</h2><p>​    当多个线程都开启事务操作数据库中的数据时, 如果不考虑事务的隔离性, 会发生几种问题:</p><ul><li><p><strong>脏读</strong></p><p>脏读就是当一个事务对数据库中的数据进行了修改, 而这个修改并未提交, 此时, 另一个事务也在访问同一个数据库, 却读到了并未提交的修改后的数据。</p><p>例如:</p><p>事务A中张三向李四转账100元, 但事务并未提交,</p><p>与此同时,</p><p>事务中李四查询余额发现多了100元,</p><p>随后,</p><p>事务A发生了异常, 回滚事务, 转账的操作退回,</p><p>那么,</p><p>事务B读取到多了100元的数据即为脏数据, 我们称事务B做了一次脏读。</p></li><li><p><strong>不可重复读</strong></p><p>不可重复读是指在同一事务内, 多次读取同一数据却返回了不同的数据值, 这是因为在查询的间隔, 数据被另一个事务修改并提交了。</p><p>例如:</p><p>在事务A中, 读取到了张三的工资为5000, 事务还未提交,</p><p>与此同时,</p><p>事务B把张三的工资修改为了8000, 并提交了事务,</p><p>随后,</p><p>事务A再次查询张三的工资变为了8000, 在一个事务中多次读取结果不一致, 我们称发生了不可重复读。</p><p>不可重复读与脏读的区别在于, 脏读是一个事务读取到了另一个事务并未提交的数据, 而不可重复读则是读取到了另一事务提交的数据。</p></li><li><p><strong>幻读(虚读)</strong></p><p>幻读是指当事务不是独立执行时发生的一种现象, 如果一个事务的操作的对象是表的全部数据行, 此时, 另一个事务给表中插入一条新的数据, 那么, 第一个事务操作的用户会发现有一行数据并没有被操作到, 就像发生了幻觉一样。</p><p>例如:</p><p>事务A读取到工资大于5000的人数为10人</p><p>此时,</p><p>事务B插入一条工资为6000的员工数据并提交,</p><p>那么,</p><p>当事务A再次读取工资大于5000的人数就变成了11人, 这就产生了幻读。</p><p>幻读和不可重复读都是读取到了另一事务提交后的数据, 不同的是, 不可重复读强调的是修改, 主要针对同一条数据, 而幻读强调的是新增和删除, 针对的是一批数据的整体。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>Mysql中的四种隔离级别:</p><ul><li><p><strong>Read uncommitted (读未提交)</strong></p><p>最低级别，任何情况都无法保证。</p></li><li><p><strong>Read committed (读已提交)</strong></p><p>是大多数DBMS(如: Oracle, SQLServer)的默认事务隔离级别, 可避免脏读的发生。</p></li><li><p><strong>Repeatable read (可重复读)</strong></p><p>是Mysql的默认事务隔离级别, 可避免脏读、不可重复读的发生。</p></li><li><p><strong>Serializable (串行化)</strong></p><p>事务隔离的最高级别, 可避免脏读、不可重复读、幻读的发生。</p></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted (读未提交)</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Read committed (读已提交)</td><td align="center">-</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Repeatable read (可重复读)</td><td align="center">-</td><td align="center">-</td><td align="center">Yes</td></tr><tr><td align="center">Serializable (串行化)</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>事务级别越高, 执行效率就越低。像Serializable这样的级别, 以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待, 所以平时选用何种隔离级别应该根据实际情况。</p><p>在Mysql数据库中查看当前事务的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><p>在Mysql数据库中设置事物的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation leve 隔离级别名称;</span><br></pre></td></tr></table></figure><p><strong>设置数据库的隔离级别一定要在事务开始之前!</strong></p><h2 id="JDBC中使用事务"><a href="#JDBC中使用事务" class="headerlink" title="JDBC中使用事务"></a>JDBC中使用事务</h2><p>JDBC中事务相关方法</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Method and Description</th></tr></thead><tbody><tr><td align="center"><code>void</code></td><td align="center"><code>setTransactionIsolation(int level)</code>  试图改变这个 <code>Connection</code>对象的事务隔离级别的。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>setAutoCommit(boolean autoCommit)</code>  这个连接的自动提交模式设置为给定的状态。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint()</code>  在当前事务中创建了一个匿名的保存点,并返回新的  <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint(String name)</code>  创建一个保存点与当前事务的名字并返回新的 <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>releaseSavepoint(Savepoint savepoint)</code>  删除指定的 <code>Savepoint</code>从当前事务和随后的  <code>Savepoint</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback()</code>  取消所有更改当前事务和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback(Savepoint savepoint)</code>  取消所有更改了在给定 <code>Savepoint</code>对象集。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>commit()</code>  使得所有的更改,因为之前的提交/回滚永久和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr></tbody></table><p>如果要在JDBC中设置隔离级别, 同样需要在事务开始之前设置, 也就是setAutoCommit(false)之前, 使用setTransactionIsolation(level)方法设置, 其中的level是Connection类中的静态字段:</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Field and Description</th></tr></thead><tbody><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_NONE</code>  一个常数表明不支持事务。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_COMMITTED</code>  一个常数表明脏读预防;不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_UNCOMMITTED</code>  一个常数表明脏读、不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_REPEATABLE_READ</code>  一个常数表明脏读和不可重复读预防;幻读也会出现。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_SERIALIZABLE</code>  一个常数表明脏读、不可重复读和虚读是预防。</td></tr></tbody></table><p>部分代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line">Statement statement = <span class="keyword">null</span>;</span><br><span class="line">String sql1 = <span class="string">&quot;insert into test_table values(Tom, 123)&quot;</span>;</span><br><span class="line">String sql2 = <span class="string">&quot;insert into test_table values(Jerry, 123)&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = dbUtil.getConnection();</span><br><span class="line">    <span class="comment">//设置隔离级别</span></span><br><span class="line">    connection.setTransactionIsolation(TRANSACTION_REPEATABLE_READ);</span><br><span class="line">    <span class="comment">//开始事务</span></span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    statement = connection.createStatement();</span><br><span class="line">    statement.excuteUpdate(sql1);</span><br><span class="line">    statement.excuteUpdate(sql2);</span><br><span class="line">    <span class="comment">//如果不发生错误,提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">    <span class="comment">//如果发生错误,在这里回滚</span></span><br><span class="line">    connection.rollback();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源占用</span></span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示 : 隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言, 一个窗口就相当于一个链接, 当前窗口设置的隔离级别只对当前窗口中的事务有效; 对于JDBC操作数据库来说，一个Connection对象相当于一个链接, 而对于Connection对象设置的隔离级别只对该Connection对象有效, 与其他链接Connection对象无关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明</summary>
      
    
    
    
    
    <category term="JDBC" scheme="http://www.ayu.link/tags/JDBC/"/>
    
    <category term="Mysql" scheme="http://www.ayu.link/tags/Mysql/"/>
    
  </entry>
  
</feed>
