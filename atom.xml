<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aYuのblog</title>
  
  
  <link href="http://www.ayu.link/atom.xml" rel="self"/>
  
  <link href="http://www.ayu.link/"/>
  <updated>2022-04-07T13:26:39.400Z</updated>
  <id>http://www.ayu.link/</id>
  
  <author>
    <name>aYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JUC之辅助类</title>
    <link href="http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <id>http://www.ayu.link/2022/04/07/JUC%E4%B9%8B%E8%BE%85%E5%8A%A9%E7%B1%BB/</id>
    <published>2022-04-07T11:19:53.000Z</published>
    <updated>2022-04-07T13:26:39.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch(闭锁)"></a>CountDownLatch(闭锁)</h2><h3 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h3><p>CountDownLatch是一个同步工具类, 用来协调多个线程之间的同步, 或者说起到线程之间的通信(而不是用作互斥的作用)。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后, 再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后, 计数器的值就会减一, 当计数器的值为0时, 表示所有的线程都已经完成一些任务, 然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a>CountDownLatch的用法</h3><ul><li>当一个或多个线程调用await方法时, 这些线程会阻塞</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</li><li>计数器的值变为0时, 因await方法阻塞的线程会被唤醒, 继续执行</li></ul><p>案例: 秦始皇灭掉六国, 一统天下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举类创建六个国家</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">    one(<span class="number">1</span>, <span class="string">&quot;齐&quot;</span>), two(<span class="number">2</span>, <span class="string">&quot;楚&quot;</span>), three(<span class="number">3</span>, <span class="string">&quot;燕&quot;</span>),</span><br><span class="line">    four(<span class="number">4</span>, <span class="string">&quot;赵&quot;</span>), five(<span class="number">5</span>, <span class="string">&quot;魏&quot;</span>), six(<span class="number">6</span>, <span class="string">&quot;韩&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer retCode;</span><br><span class="line">    <span class="keyword">private</span> String retMessage;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountryEnum</span><span class="params">(Integer retCode, String retMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">        <span class="keyword">this</span>.retMessage = retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">getCountryEnum</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        CountryEnum[] countryEnums = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum countryEnum : countryEnums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countryEnum.getRetCode().equals(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> countryEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRetCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRetMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;国, 被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.getCountryEnum(i).getRetMessage()).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;秦国一统天下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/01.png"></p><p>额, 好像没有按照历史顺序来, 不过无伤大雅</p><h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p>CountDownLatch是一次性的, 计数器的值只能在构造方法中初始化一次, 之后没有任何机制再次对其设置值, 当CountDownLatch使用完毕后, 它不能再次被使用。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h2><h3 id="CyclicBarrier是什么"><a href="#CyclicBarrier是什么" class="headerlink" title="CyclicBarrier是什么"></a>CyclicBarrier是什么</h3><p>CyclicBarrier是一个同步辅助类, 它允许一组线程相互等待直到所有线程都到达一个公共的屏障点。<br>在程序中有固定数量的线程, 这些线程有时候必须等待彼此, 意思就是每个线程都得执行到等待点进行等待, 直到所有线程都执行到等待点, 才会继续往下执行。这种情况下, 使用CyclicBarrier很有帮助。这个屏障之所以用循环修饰, 是因为在所有的线程释放彼此之后, 这个屏障是可以重新使用的。</p><h3 id="CyclicBarrier的用法"><a href="#CyclicBarrier的用法" class="headerlink" title="CyclicBarrier的用法"></a>CyclicBarrier的用法</h3><p>构造方法:</p><ul><li><p>CyclicBarrier(int parties), 当等待线程数量达到parties时, 放行所有线程</p></li><li><p>CyclicBarrier(int parties，Runnable barrierAction), 当等待线程数量达到parties时, 放行所有线程, 并由最后一个线程执行barrierAction</p></li></ul><p>案例: 收集七龙珠召唤神龙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/02.png"></p><h3 id="CyclicBarrier与CountDownLatch的区别"><a href="#CyclicBarrier与CountDownLatch的区别" class="headerlink" title="CyclicBarrier与CountDownLatch的区别"></a>CyclicBarrier与CountDownLatch的区别</h3><ul><li>CyclicBarrier是对计数器做加法</li><li>CountDownLatch是对计数器做减法</li><li>CountdownLatch是一次性的</li><li>CycliBarrier是可以重复使用的, 使用<code>reset()</code>方法即可重置计数器</li></ul><h2 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore(信号灯)"></a>Semaphore(信号灯)</h2><h3 id="Semaphore是什么"><a href="#Semaphore是什么" class="headerlink" title="Semaphore是什么"></a>Semaphore是什么</h3><p>Semaphore是计数信号量。Semaphore管理一系列许可。每个acquire方法阻塞, 直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可, 这可能会释放一个阻塞的acquire方法。然而, 其实并没有实际的许可这个对象, Semaphore只是维持了一个可获得许可证的数量。</p><h3 id="Semaphore的用法"><a href="#Semaphore的用法" class="headerlink" title="Semaphore的用法"></a>Semaphore的用法</h3><ul><li>acquire(获取)当一个线程调用acquire操作时, 它要么通过成功获取信号量(信号量减1), 要么一直等下去, 直到有线程释放信号量, 或超时。</li><li>release(释放)实际上会将信号量的值加1, 然后唤醒等待的线程。</li><li>信号量主要用于两个目的, 一个是用于多个共享资源的互斥使用, 另一个用于并发线程数的控制。</li></ul><p>案例: 停车场抢车位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore, 设置许可量, 模拟三个车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟六辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车抢到车位&quot;</span>);</span><br><span class="line">                    <span class="comment">//设置随机停车时间</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号车离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-07/03.png"></p><p>可以看到, 如果有三个线程得到了许可, 那么剩下的线程就会被阻塞, 知道有线程释放许可, 才会随机释放一个被阻塞的线程获得许可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CountDownLatch-闭锁&quot;&gt;&lt;a href=&quot;#CountDownLatch-闭锁&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch(闭锁)&quot;&gt;&lt;/a&gt;CountDownLatch(闭锁)&lt;/h2&gt;&lt;h3 id=&quot;什么是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Callable接口</title>
    <link href="http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.ayu.link/2022/04/06/JUC%E4%B9%8BCallable%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-04-06T08:56:46.000Z</published>
    <updated>2022-04-07T08:22:23.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>创建线程有四种方式:</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Callable接口</li><li>线程池</li></ul><p>前两种前面说过了, Runnable接口是比较常用的, 因为在Java中继承是很重要的, 不能随便使用, 但是Runnable接口有一个缺点, run()方法没有返回值, 也就是当线程结束时, 不能返回结果, 为了能返回结果, 在JDK1.5以后出现了Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Callable接口中的call()方法可以用来处理任务并返回一个结果, 如果无法处理, 则会抛出异常。</p></blockquote><p>Runnable和Callable的区别:</p><ul><li>Callable规定的方法是call(), Runnable规定的方法是run()</li><li>Callable的任务执行后可返回值, 而Runnable的任务是不能返回值</li><li>call()方法可以抛出异常, run()方法不能</li></ul><p>下面就写一个简单的类实现Callable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个10以内的随机数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当我们想要去创建这样一个线程去测试的时候发现, Thread的构造方法里没有一个是需要传入Callable接口的, 只能传入Runnable接口, 那么有什么方法可以让Callable接口转成Runnable接口呢?</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>先来看一下FutureTask的继承结构</p><p><img src="/img/2022-04-06/01.png"></p><p>FutureTask是Runnable的一个实现类, 再来看一下FutureTask的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要传入一个Callable接口, 那么使用FutureTask就可以将Callable接口转成Runnable接口了</p></blockquote><p>再来看一下FutureTask的另一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment"> * given &#123;<span class="doctag">@code</span> Runnable&#125;, and arrange that &#123;<span class="doctag">@code</span> get&#125; will return the</span></span><br><span class="line"><span class="comment"> * given result on successful completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result to return on successful completion. If</span></span><br><span class="line"><span class="comment"> * you don&#x27;t need a particular result, consider using</span></span><br><span class="line"><span class="comment"> * constructions of the form:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个FutureTask将在运行, 执行给定Runnable, 安排get()将返回给定的成功完成。 </p></blockquote><p>最后看一下FutureTask的常用方法</p><ul><li><code>get()</code>, 如果有必要等待计算完成, 然后获取它的结果</li><li><code>isDone()</code>, 如果正常终止, 或是发生异常, 或是手动取消, 返回true</li></ul><p>使用FutureTask来完成我们的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//普通创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> GetNumber());</span><br><span class="line">        <span class="comment">//Lambda表达式创建</span></span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">            <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask1, <span class="string">&quot;tom&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(integerFutureTask2, <span class="string">&quot;jerry&quot;</span>).start();</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom get &quot;</span> + integerFutureTask1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;jerry get &quot;</span> + integerFutureTask2.get());</span><br><span class="line">        <span class="comment">//主线程结束</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetNumber</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in callable!&quot;</span>);</span><br><span class="line">        <span class="comment">//返回一个10以内的随机数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行结果:</p><p><img src="/img/2022-04-06/02.png"></p><p>运行成功!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;创建线程有四种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;实现R</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之各种锁</title>
    <link href="http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>http://www.ayu.link/2022/04/05/JUC%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/</id>
    <published>2022-04-05T05:06:01.000Z</published>
    <updated>2022-04-05T10:43:45.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>回头看一下之前的一个多线程买票案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/01.png"></p><p>CC线程几乎卖出了一多半的票, 而BB线程只卖出了2张票, 这是因为在线程抢占的过程中, CC总能抢到锁, 这样就容易导致其他线程饥饿, 那么为什么会这样呢? 来看一下ReentrantLock的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字面意思上也能看出来, ReentrantLock在创建的时候如果不传入任何参数, 默认创建的是一个非公平锁, 当传入一个布尔值为<strong>true</strong>时, 创建的则是一个公平锁, 使用公平锁修改上面的案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTicket lockTicket = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                lockTicket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/02.png"></p><p>可以看到, 当三个线程都创建完成后, 遵循的就是一个线程卖一张票的的规则, 很公平, 但是公平锁也有缺点, 那就是效率低下, 所以使用的时候还是要视情况而定。</p><blockquote><p>注意: synchronized 和 ReentrantLock 默认是非公平锁</p></blockquote><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>什么是可重入锁?</p><ul><li>可重入锁又称递归锁, 是指在同一个线程在外层方法获取锁的时候, 再进入该线程的内层方法会自动获取锁(前提,锁对象得是同一个对象), 不会因为之前已经获取过还没有释放而阻塞</li><li>Java中synchronized和ReentrantLock都是可重入锁, 可重入锁的存在就是为了在一定程度上避免<strong>死锁</strong></li></ul><p>只看概念不太能理解可重入锁这个东西, 来通过代码演示一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外中内三层代码块上的都是同一把锁o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入中层&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/03.png"></p><p>可以看到因为三层代码块用的是同一把锁, 所以不用等到上一层得到锁的代码块释放锁就能进入, 接着看一下ReentrantLock版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock演示可重入锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入外层&quot;</span>);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入内层&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/04.png"></p><p>依旧是不用等到上一层代码块的锁释放就可以得到锁进入代码块</p><blockquote><p>注意: lock的lock()和unlock()方法要一一对应, 否则会对其他线程造成影响</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>什么是死锁?</p><ul><li><p>死锁是指两个或两个以上的线程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力干涉那它们都将无法推进下去, 如果资源充足, 进程的资源请求都能够得到满足, 死锁出现的可能性就很低, 否则就会因争夺有限的资源而陷入死锁</p></li><li><p>如果有两个线程各自持有一把锁, 却同时想获取对方的锁而双发都未释放锁, 这时就产生了死锁</p><p>  <img src="/img/2022-04-05/05.png"></p></li></ul><p>来看一下代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁a, 等待锁b释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁b, 等待锁a释放&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/06.png"></p><p>两个线程都在等待对方的锁释放, 然而如果它们获取不到对方的锁就不会释放自己的锁, 这就产生了死锁, 如果我们不人为去干预, 会一直卡在这里占用系统资源, 但是很多时候思索地产生是因为资源分配不当导致的, 我们很难这么清晰的观察到, 那么就需要通过命令的方式排查死锁并人为关闭死锁线程</p><blockquote><p>在终端输入jps排查进程</p><p>PS D:\JUC\JUC_study\one&gt; jps<br>16640 Jps<br>28472 Launcher<br>17164<br>7692 DeadLock</p><p>发现除正常线程以外, 还有一个一直在的进程7692, 使用堆栈跟踪工具jstack查看此进程</p><p>PS D:\JUC\JUC_study\one&gt; jstack 7692<br>2022-04-05 15:47:56</p><p>Found one Java-level deadlock:</p><p>“B”:<br>  waiting to lock monitor 0x0000000017a206f8 (object 0x00000000d6046488, a java.lang.Object),<br>  which is held by “A”<br>“A”:<br>  waiting to lock monitor 0x0000000017a23038 (object 0x00000000d6046498, a java.lang.Object),<br>  which is held by “B”</p><p>Java stack information for the threads listed above:</p><p>“B”:<br>        at com.ayu.sync.DeadLock.lambda$main$1(DeadLock.java:39)</p><pre><code>    - waiting to lock &lt;0x00000000d6046488&gt; (a java.lang.Object)    - locked &lt;0x00000000d6046498&gt; (a java.lang.Object)            at com.ayu.sync.DeadLock$$Lambda$2/990368553.run(Unknown Source)            at java.lang.Thread.run(Thread.java:748)</code></pre><p>“A”:<br>                at com.ayu.sync.DeadLock.lambda$main$0(DeadLock.java:25)<br>        - waiting to lock &lt;0x00000000d6046498&gt; (a java.lang.Object)<br>        - locked &lt;0x00000000d6046488&gt; (a java.lang.Object)<br>                at com.ayu.sync.DeadLock$$Lambda$1/2003749087.run(Unknown Source)<br>                at java.lang.Thread.run(Thread.java:748)</p><p>Found 1 deadlock.</p><p>果然发现了一个死锁进程, 可以通过重新分配资源的方式解决, 也可以直接杀掉此进程(前提是此进程不重要)</p><p>PS D:\JUC\JUC_study\one&gt; kill 7692</p></blockquote><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁:</p><ul><li>认为自己在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确保数据不会被别的线程修改</li><li>适合写操作多的场景, 先加锁可以保证写操作时数据正确(写操作包括增删改), 显式的锁定之后再操作同步资源</li><li>synchronized关键字和Lock的实现类都是悲观锁</li></ul><p><img src="/img/2022-04-05/07.png"></p><p>乐观锁:</p><ul><li>乐观锁认为自己在使用数据时不会有别的线程修改数据, 所以不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据, 如果这个数据没有被更新, 当前线程将自己修改的数据成功写入, 如果数据已经被其他线程更新, 则根据不同的实现方式执行不同的操作</li><li>适合读操作多的场景, 不加锁的特点能够使其读操作的性能大幅度提升</li><li>乐观锁一般有两种实现方式(采用版本号机制、CAS算法实现)</li><li>乐观锁在Java中通过使用无锁编程来实现, 最常采用的时CAS算法, Java原子类中的递增操作就通过CAS自旋实现的</li></ul><p><img src="/img/2022-04-05/08.png"></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>在多线程对同一资源进行操作的时候肯定是要加锁的, 对于写操作(增删改)来说, 肯定是要考虑并发场景下的操作原子性的, 所以写操作必须是独占锁, 但是对于读操作来说, 多线程同时读一个资源并没有任何问题, 为了满足并发情况下的效率, 读操作应为共享锁。为了满足这种需求就出现了<strong>读写锁</strong>。</p><p>读写锁特点:</p><ul><li>读-读可以共享</li><li>读-写互斥</li><li>写-写互斥</li></ul><blockquote><p>Java中读写锁为<code>ReentrantReadWriteLock</code></p><p>读锁为<code>ReentrantReadWriteLock.ReadLock</code>, 使用<code>readLock()</code>方法获得</p><p>写锁为<code>ReentrantReadWriteLock.WriteLock</code>, 使用<code>writeLock()</code>方法获得</p></blockquote><p>用一个小案例来演示一下读写锁的使用: 多个线程对Map进行写入和读取操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">//创建写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.put(number + <span class="string">&quot;&quot;</span>, number + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    myCache.get(<span class="string">&quot;&quot;</span> + number);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁, 独占锁啊</span></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行写操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写操作结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//添加读锁, 共享锁</span></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读操作结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/09.png"></p><p>可以看到, 写操作未结束时, 不会有其他的线程进行操作, 但是读操作未结束时, 其他读操作线程也可以进行操作, 这就说明写锁是独占的, 读锁是共享的。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>如果我们在做完写操作之后又想进行读操作, 但是由于写锁是独占锁, 这时候进行读操作很浪费资源, 这时候就可以将写锁降级为读锁, 这样读取的时候其他线程也能共享读取</p><p>具体步骤:</p><p>获取写锁-&gt;进行写操作-&gt;获取读锁-&gt;释放写锁-&gt;进行读操作-&gt;释放读锁</p><p>代码演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写锁上锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁降级, 先读锁上锁再释放写锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        <span class="comment">//进行读操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放读锁, 操作完成</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/2022-04-05/10.png"></p><p>成功从写锁降级成读锁</p><p>写锁可以降级为读锁, 那么读锁可不可以升级为写锁呢, 把上面的代码改一下试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读锁上锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行读操作&quot;</span>);</span><br><span class="line">        <span class="comment">//锁升级, 先写锁上锁再释放读锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">//进行写操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;进行写操作&quot;</span>);</span><br><span class="line">        <span class="comment">//释放写锁</span></span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-04-05/11.png"></p><p>卡在这里了, 说明不能将读锁升级为写锁!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;p&gt;回头看一下之前的一个多线程买票案例&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之锁的八种情况</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%94%81%E7%9A%84%E5%85%AB%E7%A7%8D%E6%83%85%E5%86%B5/</id>
    <published>2022-03-27T07:30:47.000Z</published>
    <updated>2022-03-27T08:23:20.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据我们以下八种情况来进行调用"><a href="#根据我们以下八种情况来进行调用" class="headerlink" title="根据我们以下八种情况来进行调用"></a>根据我们以下八种情况来进行调用</h2><ol><li><p>标准访问, 两个线程, 各自访问一个方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote></li><li><p>在sendSMS方法中停留4秒, 其余与第一种情况一样</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//停留4秒</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS<br>——sendEmail</p></blockquote><p> 1-2情况说明:</p><ul><li>一个对象里面如果有多个synchronized方法, 某一个时刻内, 只要一个线程去调用其中的一个synchronized方法了, 其它的线程都只能等待, 换句话说,某一个时刻内, 只能有唯一的一个线程去访问这些synchronized方法</li></ul><ul><li> 锁的是当前对象this, 被锁定后, 其它的线程都不能进入到当前对象的其它的synchronized方法</li></ul></li><li><p>新增普通方法hello(), 第一个线程调用sendSMS(), 第二个线程调用hello()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//资源类中增加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主类中修改</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    phone.hello();</span><br><span class="line">&#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——hello<br>——sendSMS</p></blockquote></li><li><p>创建两个Phone实例, 一个调用sendSMS, 一个调用sendEmail</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 3-4情况说明:</p><ul><li>普通方法与锁无关, 不会被阻塞</li><li>两个实例对象不是同一把锁</li></ul></li><li><p>将sendSMS()和sendEmail()变成静态方法, 一个实例对象去调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote></li><li><p>两个实例对象调用静态方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendSMS</p><p>——sendEmail</p></blockquote><p> 5-6情况说明:</p><ul><li>对于普通方法来说, 锁的对象是this, 也就是当前实例对象</li><li>对于静态方法来说, 锁的对象就是当前类的Class对象, 也就是说这个类的所有实例对象公用同一把锁</li></ul></li><li><p>一个静态方法, 一个普通方法, 一个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote></li><li><p>一个静态方法, 一个普通方法, 两个实例对象调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLocks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone2.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果</p><blockquote><p>——sendEmail</p><p>——sendSMS</p></blockquote><p> 7-8情况说明:</p><ul><li>不管是一个实例对象还是多个实例对象, 普通同步方法与静态同步方法的锁都不是同一把</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;创建一个资源类Phone(手机), 里面两个方法sendEmail(发邮件), sendSMS(发短信), 都是线程同步方法</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之集合线程安全</title>
    <link href="http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://www.ayu.link/2022/03/27/JUC%E4%B9%8B%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-03-27T05:43:59.000Z</published>
    <updated>2022-03-27T07:01:47.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合演示"><a href="#List集合演示" class="headerlink" title="List集合演示"></a>List集合演示</h2><p>先来看下面一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//多线程并发访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个ArrayList集合, 下面十个线程每个都往里放一条数据并读取这个集合, 看一下运行结果</p><p><img src="/img/2022-03-27/01.png" alt="image-20220327140910524"></p><p>报了java.util.ConcurrentModificationException这么一个错误, 这个错误是并发修改异常, 看一下ArrayList的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add()这个方法没有加synchronized关键字也没有Lock接口, 说明这是一个线程不安全的类。</p><p>想要线程安全有以下三种解决方法</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector也是List的子类, 并且Vector的方法有synchronized关键字修饰, 所以Vector是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们只需要将ArrayList改为Vector就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br></pre></td></tr></table></figure><p>但是Vector在高并发情况下的性能堪忧, 所以不推荐使用</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>使用Collections工具类返回一个线程同步列表, 方法是<code>Collections.synchronizedList(List<T> list)</code></p><p>改一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>但是这种方法也比较过时了, 不推荐使用</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList底层使用<strong>写时复制技术</strong>, 每次往列表里写入的时候会复制整个列表到新的列表, 读的时候读原来的那个旧的, 当写操作进行完之后再将新老列表合并覆盖, 我们推荐使用写时复制列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><p>同理, 来看一下另外两个常用的集合类, <code>HashSet</code>和 <code>HashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的add方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看的出来, 这两个类都是线程不安全的。</p><ul><li><p>Set想要实现线程安全, 推荐使用<code>CopyOnWriteArraySet</code>, 底层同样是写时复制技术</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>Map推荐使用<code>ConcurrentHashMap</code>, 底层使用自旋锁CAS实现线程安全</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List集合演示&quot;&gt;&lt;a href=&quot;#List集合演示&quot; class=&quot;headerlink&quot; title=&quot;List集合演示&quot;&gt;&lt;/a&gt;List集合演示&lt;/h2&gt;&lt;p&gt;先来看下面一段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程间通信</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2022-03-26T13:21:25.000Z</published>
    <updated>2022-03-26T15:09:43.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>谈到线程间通信就不得不说一个经典的生产者-消费者模型, 我们假定这样一个场景:</p><ol><li>一个小小的饮品店, 桌子太小了每次只能放一杯饮品</li><li>桌子上没有饮品的时候顾客就会等待</li><li>桌子上有饮品的时候店长就不做了(很佛系)</li></ol><p>我们尝试用代码实现以下这个场景:</p><ol><li><p>把饮品店, 饮品, 做饮品, 取饮品给抽象出来</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的具体实现, 考虑多线程操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>来个main()方法调用一下</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行一下:</p><p> <img src="/img/2022-03-26/11.png"></p><p> 发现非常和睦, produce1做一杯, consume1买一杯。</p></li></ol><p>这时我们需求升级了, 多来个做饮品的, 买饮品的也多排了一队, 但是桌子还是那么大, 简单, 我们再来两个线程就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建资源类</span></span><br><span class="line">        IceCream ic = <span class="keyword">new</span> IceCream();</span><br><span class="line">        <span class="comment">//创建生产线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建生产线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.produce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;produce2&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//创建消费线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ic.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;consume2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/12.png"></p><p>出大问题, 不是说好的桌子上只能放一杯么, 为什么会出现这种问题呢, 那是因为在程序中发生了虚假唤醒:</p><p>之前说过, wait()这个方法是在哪里停下就在那里开始, 回头看一眼代码两个方法中进行判断的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line"><span class="keyword">if</span> (water != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait();<span class="comment">//在这里醒来就相当于判断已经结束, 要执行下面的代码块了, 但是这是重新进来的, 应该再次进行判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用while循环替代if, 这样每次醒过来就会重新进行判断, 改完之后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有咱就做一杯</span></span><br><span class="line">        water++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">        <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有就取走</span></span><br><span class="line">        water--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">        <span class="comment">//告诉店家该做了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次看一下运行结果: </p><p><img src="/img/2022-03-26/13.png"></p><p>又和睦起来了!</p><h3 id="多线程编程步骤"><a href="#多线程编程步骤" class="headerlink" title="多线程编程步骤"></a>多线程编程步骤</h3><p>经过上面的那个案例, 可以总结一下四个步骤:</p><ol><li>创建资源类, 在资源类中创建共享属性和操作方法</li><li>在资源类操作方法: 判断、操作、通知</li><li>创建多个线程, 调用资源类的操作方法</li><li>防止虚拟唤醒问题</li></ol><h3 id="Lock接口版"><a href="#Lock接口版" class="headerlink" title="Lock接口版"></a>Lock接口版</h3><p>既然synchronized可以实现上面的案例, 那么Lock接口肯定也可以实现, 使用Condition的两个方法实现线程等待和唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">    <span class="comment">//饮品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//获得condition实例</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">//做饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 有就不做了</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">0</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有咱就做一杯</span></span><br><span class="line">            water++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉消费者可以取了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取饮品</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断桌子上有没有饮品, 没有就等着</span></span><br><span class="line">            <span class="keyword">while</span> (water != <span class="number">1</span>) &#123;<span class="comment">//使用while循环解决虚假唤醒问题</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有就取走</span></span><br><span class="line">            water--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + water);</span><br><span class="line">            <span class="comment">//告诉店家该做了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/14.png"></p><p>完美复刻!</p><h3 id="线程定制化通信"><a href="#线程定制化通信" class="headerlink" title="线程定制化通信"></a>线程定制化通信</h3><p>上面案例的结果都有一个特点, 两个生产者和两个消费者出现的很乱, 有没有可能让线程间按照我们想要的顺序运行呢?</p><p>来看一个简单案例, 要求是</p><ul><li>AA, BB, CC三个线程, 每个线程调用一个方法</li><li>执行顺序是AA-&gt;BB-&gt;CC</li><li>循环执行10轮</li></ul><p>看一下思路</p><p><img src="/img/2022-03-26/15.png"></p><p>根据这个思路, 来编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建三个condition</span></span><br><span class="line">    Condition cA = lock.newCondition();</span><br><span class="line">    Condition cB = lock.newCondition();</span><br><span class="line">    Condition cC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//A方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                cA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodA : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为2</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//cB唤醒</span></span><br><span class="line">            cB.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                cB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodB : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为3</span></span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//cC唤醒</span></span><br><span class="line">            cC.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                cC.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;methodC : 第&quot;</span> + loop + <span class="string">&quot;轮&quot;</span>);</span><br><span class="line">            <span class="comment">//设置标志位为1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cA唤醒</span></span><br><span class="line">            cA.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个主类测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodA(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodB(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.methodC(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下运行结果</p><p><img src="/img/2022-03-26/16.png"></p><p>按照我们的需求完美运行, 这就是线程定制化通信!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们知道了什么是线程, 知道了什么是锁, 但是怎样编写多线程程序呢? 通过下面的文章将告诉大家编写一个简单的多线程程序需要那几步。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识锁</title>
    <link href="http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/"/>
    <id>http://www.ayu.link/2022/03/26/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E9%94%81/</id>
    <published>2022-03-26T07:14:57.000Z</published>
    <updated>2022-03-26T15:10:28.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先来看一段代码"><a href="#先来看一段代码" class="headerlink" title="先来看一段代码"></a>先来看一段代码</h2><p>使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下运行结果:</p><p><img src="/img/2022-03-26/01.png"> </p><p>我们发现一个很奇怪的事情, 买票的顺序不是从19到0, 是一个很混乱的顺序, 这是为什么呢? 因为我们在多个线程进行操作的时候难免会发生线程抢占, 明明我这个线程进来做完操作了准备打印结果, 但这时又被另一个线程抢了过去运行权, 它先打印了结果, 我这好不容易再次抢了回来, 可这时已经晚了, 打印出了原本的结果, 可这个结果却是过时错误的结果, 那么怎样避免这样的事发生呢, 我们就需要给买票操作加把锁。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><blockquote><p>synchronized是Java中的关键字, 中文意思是同步, 也称之为”同步锁”。</p><p>作用主要有三个:</p><ul><li>原子性: 确保线程互斥地访问同步代码</li><li>可见性: 保证共享变量的修改能够及时可见, 其实是通过Java内存模型中的”对一个变量unlock操作之前, 必须要同步到主内存中; 如果对一个变量进行lock操作, 则将会清空工作内存中此变量的值, 在执行引擎使用此变量前, 需要重新从主内存中load操作或assign操作初始化变量值 “来保证的</li><li>有序性: 有效解决重排序问题, 即”一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</li></ul></blockquote><p>synchronized的3种使用方式:</p><ul><li><p>修饰实例方法: 作用于当前实例加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意: </p><ul><li>在定义接口方法时不能使用synchronized关键字。</li><li>构造方法不能使用synchronized关键字, 但可以使用synchronized代码块来进行同步。 </li></ul></li><li><p>修饰静态方法: 作用于当前类对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  与上一个不同的是, 被synchronized修饰的静态方法是对于这个类的所有实例对象都起作用的, 也就是说所有这个类的实例对象用的是同一把锁。</p></li><li><p>修饰代码块: 指定加锁对象, 对给定对象加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给这个类的某一代码块加锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给这个对象加锁</span></span><br><span class="line">Object obj;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在我们就可以使用synchronized帮我们上边的例子进行加锁操作, 很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有余票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一看运行结果:</p><p><img src="/img/2022-03-26/02.png"> </p><p>很明显, 票按照正常的顺序出售了。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><blockquote><p>Lock是java.util.concurrent.locks包下常用的接口</p><p>代表实现类是ReentrantLock(可重入锁)</p></blockquote><p>常用方法:</p><ul><li>lock(): 获取锁, 也就是给下面操作上锁</li><li>unlock(): 释放锁</li></ul><p>被lock()上锁后即使发生异常也不会释放锁, 所以我们通常在lock()方法后紧跟try…catch…块, 并将unlock()释放锁方法放在finally块中, 以此来保证锁的释放, 防止死锁的产生。</p><p>下面我们使用Lock接口对上面的例子进行修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 三个线程卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Ticket对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//买票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//lock()方法一定紧跟try块</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有余票</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : 卖出一张票, 剩余票数: &quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-26/03.png"> </p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>synchronized与Lock的异同：</p><ul><li>synchronized是java关键字, 内置, 而lock不是内置, 是一个接口, 可以实现同步访问且比synchronized中的方法更加丰富</li><li>synchronized不用手动释放锁, 而lock需手动释放锁(不解锁会出现死锁, 需要在 finally 块中释放锁)</li><li>Lock等待锁的线程会响应中断, 而synchronized不会响应，只会一直等待</li><li>通过 Lock 可以知道有没有成功获取锁, 而 synchronized 却无法办到</li><li>Lock 可以提高多个线程进行读操作的效率(当多个线程竞争的时候)</li></ul><h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>在synchronized中, 如果要对线程进行一些操作可以使用Object类自带的这些方法:</p><ul><li>wait(): 让当前线程进入等待, 并且遵循在哪里停下, 被唤醒时就在哪里开始的原则</li><li>notify(): JVM随机唤醒一个线程</li><li>notifyAll(): 唤醒所有线程</li></ul><p>而Lock锁可以使用newCondition()方法返回一个Condition对象, Condition类中有下面几个方法:</p><ul><li>await(): 使当前线程进入等待, 并且释放锁, 当被其他线程调用signal()唤醒时会重新获得锁</li><li>signal(): 唤醒被这个Condition实例等待的线程</li><li>signalAll(): 唤醒所有线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;先来看一段代码&quot;&gt;&lt;a href=&quot;#先来看一段代码&quot; class=&quot;headerlink&quot; title=&quot;先来看一段代码&quot;&gt;&lt;/a&gt;先来看一段代码&lt;/h2&gt;&lt;p&gt;使用三个线程来模拟三个售票员售票, 票数是固定的, 并且在三个售票员之间时共享的。&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之初识线程</title>
    <link href="http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.ayu.link/2022/03/25/JUC%E4%B9%8B%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-25T08:01:21.000Z</published>
    <updated>2022-03-26T10:02:57.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:</p><blockquote><p>进程（Process）</p><ul><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>进程是线程的容器</li><li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li><li>系统进行资源分配和调度的基本单位，是操作系统结构的基础</li></ul><p>线程（thread）</p><ul><li>操作系统能够进行运算调度的最小单位</li><li>被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流</li></ul></blockquote><p>如果没有操作系统知识的话有点难理解上面的话, 我用一个简单的比喻来解释一下, 把一个进程比作一辆正在运行的火车, 那么线程就是火车中的一个车厢, 每个车厢里都在干着自己的事, 车厢与车厢之间可以相互连通的。听不懂也没有关系, 抽象的概念往往是难以理解的, 会在后面的学习中不断领悟。</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>我们平常写的程序只有一个main()方法入口, 这就是一个典型的单线程程序, 为了后面的学习我们先来认识一下<strong>Thread</strong>这个类和这个类中一些常用的方法:</p><blockquote><p>public class Thread extends Object<br>                                    implements Runnable</p><p>线程是一个线程的执行程序。Java虚拟机允许应用程序同时运行多个线程的执行。 </p></blockquote><table><thead><tr><th>function</th><th>description</th></tr></thead><tbody><tr><td><code>start()</code></td><td>开始执行这个线程;Java虚拟机调用 <code>run</code>这个线程的方法。</td></tr><tr><td><code>sleep(long millis)</code></td><td>线程睡眠(暂时停止执行)指定的毫秒数。</td></tr><tr><td><code>currentThread()</code></td><td>返回当前线程的引用。</td></tr><tr><td><code>getName()</code></td><td>返回当前线程的名称。</td></tr><tr><td><code>setDaemon(boolean on)</code></td><td>将线程设置为守护线程或用户线程。</td></tr><tr><td><code>isDaemon()</code></td><td>这个线程是否为一个守护线程。</td></tr></tbody></table><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>通过线程枚举类的状态我么可以得知有以下六种状态:</p><ul><li><strong>NEW</strong>, 创建线程</li><li><strong>RUNNABLE</strong>, 线程准备就绪</li><li><strong>BLOCKED</strong>, 线程阻塞</li><li><strong>WAITING</strong>, 线程等待(会一直等待)</li><li><strong>TIMED_WAITING</strong>, 线程等待(超时会取消等待状态)</li><li><strong>TERMINATED</strong>, 线程终结(消亡)</li></ul><p>线程状态之间的相互转换:</p><p><img src="/img/2022-03-25/02.jpg"></p><h3 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h3><ul><li><p>通过继承Thread类(不推荐)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为在Java中继承是很宝贵的, 每个类只能继承一个类, 所以我们通常不使用这种方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过实现Runnable接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用匿名内部类实现Runnable接口传入Thread(常用)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Runnable接口是一个函数式接口, 所以我们可以使用Lambda表达式简化开发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Callable接口</p></li><li><p>使用线程池创建</p></li></ul><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><ul><li>用户线程是自定义的线程</li><li>守护线程是后台的特殊线程, 依赖于创建它的线程, 比如JVM的垃圾回收</li><li>主线程如果结束了用户线程还在执行, JVM还会存活</li><li>没有用户线程后，剩下都是守护线程, JVM就会结束</li></ul><p>我们写个小Demo来演示以下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/03.png"></p><p>发现程序打印完并未结束, 是因为我们自己创建的线程是用户线程, 而用户线程不结束, JVM是不会结束的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread aa = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//使用死循环让线程一直存活</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    aa.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    aa.start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; over!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/img/2022-03-25/04.png"></p><p>程序直接结束了, 这是因为我们将自己创建的线程设置为了守护线程, 当只剩下守护线程, JVM就会结束。</p><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><blockquote><p>不同点:</p><ul><li>wait()是Object 的方法, 会释放锁, 调用它的前提是当前线程占有锁(即代码要在 synchronized 中)</li><li>sleep()是Thread 的静态方法, 任何对象实例都能调用, 不会释放锁, 也不需要占用锁</li></ul><p>相同点:</p><ul><li>都可以被interrupted()方法中断</li></ul></blockquote><h3 id="串行、并行和并发"><a href="#串行、并行和并发" class="headerlink" title="串行、并行和并发"></a>串行、并行和并发</h3><ul><li><p><strong>串行</strong>表示程序所有任务都按先后顺序进行</p></li><li><p><strong>并行</strong>表示程序同时执行多个任务</p></li><li><p><strong>并发</strong>(concurrent)：同一时刻多个线程访问统一资源</p></li></ul><p><img src="/img/2022-03-25/05.png"></p><blockquote><p>实际上, 对于单核 CPU 来说, 同一时刻只能运行一个线程, 所以, 这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象, 这是并行的概念, 而是提供一种功能让用户看来多个程序同时运行起来了, 但实际上这些程序中的进程不是一直霸占 CPU 的, 而是执行一会停一会。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h2&gt;&lt;p&gt;在讨论多线程之前, 我们先来了解一下什么是线程, 什么是进程, 以及两个的区别是什么:&lt;/p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JUC" scheme="http://www.ayu.link/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC配置与使用</title>
    <link href="http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.ayu.link/2021/12/07/Spring-IOC%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-07T08:03:00.000Z</published>
    <updated>2021-12-08T14:50:34.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件和注解, 我们都会一一讲到。</p><h2 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h2><p>IOC容器的底层就是对象工厂</p><p>Spring提供了IOC容器的两种实现方式(两个接口):</p><ul><li><p>BeanFactory: IOC容器基本实现, 是Spring内部使用的接口, 不提供给开发人员使用, <strong>加载文件的时候不会船舰对象, 在获取对象的时候才会创建对象</strong>。</p></li><li><p>ApplicationContext: BeanFactory接口的子接口, 提供更多更强大的功能, <strong>加载配置文件的时候就会把在配置文件中配置好的对象进行创建</strong>。</p><p>ApplicationContext的四个常用实现类:</p><ul><li><strong>FileSystemXmlApplicationContext：</strong>加载配置文件的时候采用的是项目的路径, 也就是绝对路径。</li><li><strong>ClassPathXmlApplicationContext：</strong>加载配置文件的时候根据ClassPath位置, 也就是项目相对路径。</li><li><strong>XmlWebApplicationContext：</strong>在Web环境下初始化监听器的时候会加载该类。</li><li><strong>AnnotationConfigApplicationContext：</strong>根据注解的方式启动Spring 容器。</li></ul></li></ul><h2 id="SpringDI的方式"><a href="#SpringDI的方式" class="headerlink" title="SpringDI的方式"></a>SpringDI的方式</h2><p>​    Spring提供了三种方式来依赖注入,有构造方法注入, setter方法注入以及接口注入。其中Spring以往推荐使用Setter的方法现在改成推荐构造方法注入。使用构造方法注入需要注意的一点就是要避免循环依赖。所谓的循环依赖指的就是在A对象的构造方法中Spring要注入B，而在B对象中Spring要注入A。这个时候会形成一个闭环因为Spring不知道该先注入哪一个接着会抛出异常。而Spring建议的处理方式是说如果遇到这种情况的话就改用Setter方式注入。</p><h2 id="Bean管理-基于xml"><a href="#Bean管理-基于xml" class="headerlink" title="Bean管理(基于xml)"></a>Bean管理(基于xml)</h2><h3 id="基于xml创建对象"><a href="#基于xml创建对象" class="headerlink" title="基于xml创建对象:"></a>基于xml创建对象:</h3><ul><li>在Spring配置文件中, 使用bean标签创建对象</li><li>在bean标签中有多个属性, 常用的有:<ul><li>id: 唯一标识, 用于获取对象</li><li>class: 类的全路径</li></ul></li><li>创建对象的时候, 默认的是执行无参构造方法完成对象创建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象的创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于xml方式注入属性"><a href="#基于xml方式注入属性" class="headerlink" title="基于xml方式注入属性:"></a>基于xml方式注入属性:</h3><ul><li><p>使用set方法进行注入</p><p>在bean标签内使用property标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用set方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用有参构造器进行注入</p><p>在bean标签内使用constructor-arg标签完成属性注入:</p><p>name: 类中属性名称</p><p>value: 属性中注入的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用有参构造方法进行参数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jerry&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入其他属性"><a href="#xml注入其他属性" class="headerlink" title="xml注入其他属性:"></a>xml注入其他属性:</h3><ul><li><p>字面量</p><ul><li><p>null值</p><p>使用<code><null/></code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊符号</p><p>使用CDATA</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特殊字符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[&lt;&lt;时生&gt;&gt;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注入外部bean</p><p>使用ref属性注入外部创建好的bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--外部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注入内部bean</p><p>直接在property标签里创建bean标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;101&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联赋值</p><p>对属性里的bean对象的属性进行赋值操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.deptNo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;102&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="xml注入集合属性"><a href="#xml注入集合属性" class="headerlink" title="xml注入集合属性:"></a>xml注入集合属性:</h3><ul><li>array标签对数组进行赋值</li><li>list标签对List集合进行赋值</li><li>set标签对Set集合进行赋值</li><li>map标签对Map集合进行赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>go<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java&quot;</span> <span class="attr">value</span>=<span class="string">&quot;88&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;c++&quot;</span> <span class="attr">value</span>=<span class="string">&quot;78&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>SQLServer<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Course&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SpringMVC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用util标签共享bean"><a href="#使用util标签共享bean" class="headerlink" title="使用util标签共享bean:"></a>使用util标签共享bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                    http://www.springframework.org/schema/util</span><br><span class="line">                    http://www.springframework.org/schema/util/spring-util-2.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用util标签来配置共享的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>大话数据结构<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>程序是怎样跑起来的<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>操作系统导论<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.collection.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用p命名空间配置bean"><a href="#使用p命名空间配置bean" class="headerlink" title="使用p命名空间配置bean:"></a>使用p命名空间配置bean:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置命名空间 --&gt;</span></span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用p命名空间来配置bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Tom&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域:"></a>Bean作用域:</h3><p>Spring中可以使用scope属性来配置bean的作用域：</p><ul><li>singleton: 单例, 在初始化配置文件时生成单例bean对象(<strong>默认</strong>)</li><li>prototype: 原型的, 在初始化配置文件时不生成bean对象, 使用时返回不同的bean对象</li><li>request: web环境下每一个request请求都会返回一个不同的bean, 只在本次请求中有效</li><li>session: web环境下每一个request请求都会返回一个不同的bean, 在session中有效</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置scope属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期:"></a>Bean生命周期:</h3><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个测试用的Order类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.set方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">        Order order = context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;4.获取到bean对象&quot;</span>);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.Order&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>3.初始化方法<br>4.获取到bean对象<br>com.ayu.bean.Order@69b0fd6f<br>5.销毁方法</p></blockquote><h3 id="Bean的后置处理器"><a href="#Bean的后置处理器" class="headerlink" title="Bean的后置处理器:"></a>Bean的后置处理器:</h3><p>使用后置处理器后的生命周期:</p><ol><li>通过构造方法生成bean的实例</li><li>为bean注入属性</li><li>将bean传给后置处理器的postProcessBeforeInitialization方法</li><li>调用初始化方法(<strong>通过init-method属性配置</strong>)</li><li>将bean传给后置处理器的postProcessAfterInitialization方法</li><li>bean的使用</li><li>IOC容器关闭时，调用销毁方法(<strong>通过destroy-method属性配置</strong>)</li></ol><p>创建一个后置处理器类实现BeanPostProcessor接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中配置BeanPostProcessor:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><blockquote><p>1.无参构造<br>2.set方法<br>初始化之前<br>3.初始化方法<br>初始化之后<br>4.获取到bean对象<br>com.ayu.bean.Order@66d1af89<br>5.销毁方法</p></blockquote><h3 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h3><p>bean标签的autowire属性实现自动装配, autowire有两个常用的值:</p><ul><li><p>byName: 根据属性名称注入, 注入值bean的id值和类属性值名称需一样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType: 根据属性类型注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ayu.autowrite.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注: 通过byType自动装配,已配置的bean中有多个该类型的bean时会报错</p></li></ul><h2 id="Bean管理-基于注解"><a href="#Bean管理-基于注解" class="headerlink" title="Bean管理(基于注解)"></a>Bean管理(基于注解)</h2><h3 id="Spring针对bean管理提供的注解"><a href="#Spring针对bean管理提供的注解" class="headerlink" title="Spring针对bean管理提供的注解"></a>Spring针对bean管理提供的注解</h3><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p><ul><li><strong>@Controlle</strong>r: 控制器, 推荐给controller层添加此注解。</li><li><strong>@Service</strong>: 业务逻辑, 推荐给业务逻辑层添加此注解。</li><li><strong>@Repository</strong>: 仓库管理, 推荐给数据访问层添加此注解。</li><li><strong>@Component</strong>: 给不属于以上基层的组件添加此注解。</li></ul><h3 id="基于注解实现对象创建"><a href="#基于注解实现对象创建" class="headerlink" title="基于注解实现对象创建"></a>基于注解实现对象创建</h3><ol><li><p>开启组件扫描:</p><p>如果扫面多个包, 可以用逗号隔开, 或是扫描包的上层目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建类, 在类上添加对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value属性可以不写, 会默认类名首字母小写为value的值</span></span><br><span class="line"><span class="meta">@Repository(value=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="开启组件扫描细节配置"><a href="#开启组件扫描细节配置" class="headerlink" title="开启组件扫描细节配置"></a>开启组件扫描细节配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例一：use-default-filters表示现在不使用默认filter，自己配置filter</span></span><br><span class="line"><span class="comment">content:include-filter 设置扫面那些内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例二：下面配置扫面包所有内容</span></span><br><span class="line"><span class="comment">content:exclude-filter 设置哪些内容不进行扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ayu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解实现属性注入"><a href="#基于注解实现属性注入" class="headerlink" title="基于注解实现属性注入"></a>基于注解实现属性注入</h3><ul><li><p><strong>@Autowired</strong>: 根据属性类型进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier</strong>: 根据属性名称进行注入, 通常和@Autowired一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要set方法</span></span><br><span class="line">    <span class="comment">//区别同一接口下多个实现类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service&quot;</span>);</span><br><span class="line">        userDaO.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>: 可以根据类型注入，也可以根据名称注入(这个注解是JDK提供的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDaO;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Value</strong>: 注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;service&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ul><h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类, 代替xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.ayu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此时应使用<strong>AnnotationConfigApplicationContext</strong>这个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnnotationConfigApplicationContext需要将配置类传给它</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">userService.hello();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    上篇文章简单介绍了IOC, 本文则是重点讲述如何使用Spring5里的IOC进行Bean管理, 有两种方式, 分别是基于xml文件</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>IOC容器解析</title>
    <link href="http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.ayu.link/2021/12/04/IOC%E5%AE%B9%E5%99%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-04T06:51:28.000Z</published>
    <updated>2021-12-07T08:10:31.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!</p><h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><h3 id="为什么要用IOC"><a href="#为什么要用IOC" class="headerlink" title="为什么要用IOC"></a>为什么要用IOC</h3><p>​    在了解什么是IOC之前, 我们先来了解一下, IOC为什么出现, 以及我们为什么要使用IOC。</p><p>​    在面向对象设计的程序系统里, 有N多个类, 这些类与类相互依赖, 相互合作, 我们的程序才能完整的运行起来, 但是久而久之就发现一些问题, 如果对一个类结构进行更改, 那么与这个类直接依赖或间接依赖的类也要做出相对应的更改; 就像一块精密的手表, 里面多个独立的齿轮相互啮合在一起, 才能正常工作, 但如果更换其中一个齿轮, 变成其他型号, 那么如果别的齿轮不去更换, 手表就很难再继续运行了; 齿轮之间的啮合就像我们程序系统里的耦合一样, 耦合是不能消除的, 我们只能尽量去降低他, 而IOC的出现就是为了解决这个问题。</p><p><img src="/img/2021-12-04/ioc-1.png"></p><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>​    控制反转（Inversion of Control，缩写为IOC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。(引用自百度百科)</p><p>​    IOC的思想就是借助”第三方”实现依赖关系对象之间的解耦, 如下图所示:</p><p><img src="/img/2021-12-04/ioc-2.png"></p><p>​    由于引进了中间位置的“第三方”, 也就是IOC容器, 使得A、B、C、D这4个对象没有了耦合关系, 齿轮之间的传动全部依靠“第三方”了, 全部对象的控制权全部上缴给“第三方”IOC容器, 所以, IOC容器成了整个系统的关键核心, 它起到了一种类似“粘合剂”的作用, 把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”, 对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p>​    如果我们把IOC这个第三方拿掉, 这个系统就变成了:</p><p><img src="/img/2021-12-04/ioc-3.png"></p><p>​    这时候, A、B、C、D这4个对象之间已经没有了耦合关系, 彼此毫无联系, 这样的话, 当你在实现A的时候, 根本无须再去考虑B、C和D了, 对象之间的依赖关系已经降低到了最低程度。</p><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>​    IOC底层使用xml解析, 工厂模式, 和反射技术。</p><p><img src="/img/2021-12-04/ioc-4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本文旨在对IOC容器的简单解析, 主要是对自己学习理解的总结, 如有错误, 欢迎各位大佬指正!&lt;/p&gt;
&lt;h2 id=&quot;IOC原理</summary>
      
    
    
    
    
    <category term="Spring5" scheme="http://www.ayu.link/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四大特性以及事务的隔离级别</title>
    <link href="http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.ayu.link/2021/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-10-15T08:15:16.000Z</published>
    <updated>2022-04-07T13:40:14.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明事务的隔离级别。</p><h2 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性(ACID)"></a>四大特性(ACID)</h2><p>​    如果一个数据库支持事务操作, 那么该数据库必须具备以下四大特性:</p><ul><li><p><strong>原子性(Atomicity)</strong></p><p>​        一个事务(transaction)中的所有操作, 要么全部完成,要么全部不完成, 不会在中间某个环节结束, 事务在执行过程中发生错误, 会被回滚(Rollback)到事务开始前的状态, 就像这个事务从来没有被执行过一样。</p></li><li><p><strong>一致性(Consistency)</strong></p><p>​        在事务开始之前和结束以后, 数据库的完整性没有被破坏, 这表示写入的资料必须完全符合所有的预设规则, 这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性(Isolation)</strong></p><p>​        数据库允许多个并发事务同时对其数据进行修改和读写的能力, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致, 事务隔离分为不同级别, 这里我们后面会讲到。</p></li><li><p><strong>持久性(Durability)</strong></p><p>​        事务处理结束后, 对数据的修改就是永久的, 即使系统故障也不会丢失。</p></li></ul><h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><ul><li><strong>BEGIN</strong> 或 <strong>START TRANSACTION</strong> 开启一个事务</li><li><strong>COMMIT</strong> 提交事务, 并使已对数据库进行的修改成为永久性的</li><li><strong>ROLLBACK</strong> 回滚并结束用户的事务, 撤销正在进行的所有未提交的修改</li><li><strong>ASAVEPIOINT identifier</strong> 在事务中创建一个保存点, 一个事务中可以有多个保存点</li><li><strong>RELEASE SAVEPOINT identifier</strong> 删除一个事务的保存点</li><li><strong>ROLLBACK TO identifier</strong> 把事务回滚到保存点</li></ul><h2 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a>脏读、不可重复读和幻读</h2><p>​    当多个线程都开启事务操作数据库中的数据时, 如果不考虑事务的隔离性, 会发生几种问题:</p><ul><li><p><strong>脏读</strong></p><p>脏读就是当一个事务对数据库中的数据进行了修改, 而这个修改并未提交, 此时, 另一个事务也在访问同一个数据库, 却读到了并未提交的修改后的数据。</p><p>例如:</p><p>事务A中张三向李四转账100元, 但事务并未提交,</p><p>与此同时,</p><p>事务中李四查询余额发现多了100元,</p><p>随后,</p><p>事务A发生了异常, 回滚事务, 转账的操作退回,</p><p>那么,</p><p>事务B读取到多了100元的数据即为脏数据, 我们称事务B做了一次脏读。</p></li><li><p><strong>不可重复读</strong></p><p>不可重复读是指在同一事务内, 多次读取同一数据却返回了不同的数据值, 这是因为在查询的间隔, 数据被另一个事务修改并提交了。</p><p>例如:</p><p>在事务A中, 读取到了张三的工资为5000, 事务还未提交,</p><p>与此同时,</p><p>事务B把张三的工资修改为了8000, 并提交了事务,</p><p>随后,</p><p>事务A再次查询张三的工资变为了8000, 在一个事务中多次读取结果不一致, 我们称发生了不可重复读。</p><p>不可重复读与脏读的区别在于, 脏读是一个事务读取到了另一个事务并未提交的数据, 而不可重复读则是读取到了另一事务提交的数据。</p></li><li><p><strong>幻读(虚读)</strong></p><p>幻读是指当事务不是独立执行时发生的一种现象, 如果一个事务的操作的对象是表的全部数据行, 此时, 另一个事务给表中插入一条新的数据, 那么, 第一个事务操作的用户会发现有一行数据并没有被操作到, 就像发生了幻觉一样。</p><p>例如:</p><p>事务A读取到工资大于5000的人数为10人</p><p>此时,</p><p>事务B插入一条工资为6000的员工数据并提交,</p><p>那么,</p><p>当事务A再次读取工资大于5000的人数就变成了11人, 这就产生了幻读。</p><p>幻读和不可重复读都是读取到了另一事务提交后的数据, 不同的是, 不可重复读强调的是修改, 主要针对同一条数据, 而幻读强调的是新增和删除, 针对的是一批数据的整体。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>Mysql中的四种隔离级别:</p><ul><li><p><strong>Read uncommitted (读未提交)</strong></p><p>最低级别，任何情况都无法保证。</p></li><li><p><strong>Read committed (读已提交)</strong></p><p>是大多数DBMS(如: Oracle, SQLServer)的默认事务隔离级别, 可避免脏读的发生。</p></li><li><p><strong>Repeatable read (可重复读)</strong></p><p>是Mysql的默认事务隔离级别, 可避免脏读、不可重复读的发生。</p></li><li><p><strong>Serializable (串行化)</strong></p><p>事务隔离的最高级别, 可避免脏读、不可重复读、幻读的发生。</p></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted (读未提交)</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Read committed (读已提交)</td><td align="center">-</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">Repeatable read (可重复读)</td><td align="center">-</td><td align="center">-</td><td align="center">Yes</td></tr><tr><td align="center">Serializable (串行化)</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>事务级别越高, 执行效率就越低。像Serializable这样的级别, 以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待, 所以平时选用何种隔离级别应该根据实际情况。</p><p>在Mysql数据库中查看当前事务的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><p>在Mysql数据库中设置事物的隔离级别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation leve 隔离级别名称;</span><br></pre></td></tr></table></figure><p><strong>设置数据库的隔离级别一定要在事务开始之前!</strong></p><h2 id="JDBC中使用事务"><a href="#JDBC中使用事务" class="headerlink" title="JDBC中使用事务"></a>JDBC中使用事务</h2><p>JDBC中事务相关方法</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Method and Description</th></tr></thead><tbody><tr><td align="center"><code>void</code></td><td align="center"><code>setTransactionIsolation(int level)</code>  试图改变这个 <code>Connection</code>对象的事务隔离级别的。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>setAutoCommit(boolean autoCommit)</code>  这个连接的自动提交模式设置为给定的状态。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint()</code>  在当前事务中创建了一个匿名的保存点,并返回新的  <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>Savepoint</code></td><td align="center"><code>setSavepoint(String name)</code>  创建一个保存点与当前事务的名字并返回新的 <code>Savepoint</code>对象表示。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>releaseSavepoint(Savepoint savepoint)</code>  删除指定的 <code>Savepoint</code>从当前事务和随后的  <code>Savepoint</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback()</code>  取消所有更改当前事务和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>rollback(Savepoint savepoint)</code>  取消所有更改了在给定 <code>Savepoint</code>对象集。</td></tr><tr><td align="center"><code>void</code></td><td align="center"><code>commit()</code>  使得所有的更改,因为之前的提交/回滚永久和释放任何数据库锁目前由这个  <code>Connection</code>对象。</td></tr></tbody></table><p>如果要在JDBC中设置隔离级别, 同样需要在事务开始之前设置, 也就是setAutoCommit(false)之前, 使用setTransactionIsolation(level)方法设置, 其中的level是Connection类中的静态字段:</p><table><thead><tr><th align="center">Modifier and Type</th><th align="center">Field and Description</th></tr></thead><tbody><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_NONE</code>  一个常数表明不支持事务。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_COMMITTED</code>  一个常数表明脏读预防;不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_READ_UNCOMMITTED</code>  一个常数表明脏读、不可重复读和虚读可以发生。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_REPEATABLE_READ</code>  一个常数表明脏读和不可重复读预防;幻读也会出现。</td></tr><tr><td align="center"><code>static int</code></td><td align="center"><code>TRANSACTION_SERIALIZABLE</code>  一个常数表明脏读、不可重复读和虚读是预防。</td></tr></tbody></table><p>部分代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line">Statement statement = <span class="keyword">null</span>;</span><br><span class="line">String sql1 = <span class="string">&quot;insert into test_table values(Tom, 123)&quot;</span>;</span><br><span class="line">String sql2 = <span class="string">&quot;insert into test_table values(Jerry, 123)&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = dbUtil.getConnection();</span><br><span class="line">    <span class="comment">//设置隔离级别</span></span><br><span class="line">    connection.setTransactionIsolation(TRANSACTION_REPEATABLE_READ);</span><br><span class="line">    <span class="comment">//开始事务</span></span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    statement = connection.createStatement();</span><br><span class="line">    statement.excuteUpdate(sql1);</span><br><span class="line">    statement.excuteUpdate(sql2);</span><br><span class="line">    <span class="comment">//如果不发生错误,提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">    <span class="comment">//如果发生错误,在这里回滚</span></span><br><span class="line">    connection.rollback();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源占用</span></span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示 : 隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言, 一个窗口就相当于一个链接, 当前窗口设置的隔离级别只对当前窗口中的事务有效; 对于JDBC操作数据库来说，一个Connection对象相当于一个链接, 而对于Connection对象设置的隔离级别只对该Connection对象有效, 与其他链接Connection对象无关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    本篇将会讲述数据库中事务的四大特性(ACID), 事务控制语句, 事务会出现的几种常见问题, JDBC中如何使用事务, 并详细说明</summary>
      
    
    
    
    
    <category term="JDBC" scheme="http://www.ayu.link/tags/JDBC/"/>
    
    <category term="Mysql" scheme="http://www.ayu.link/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>JDBC五种连接方式</title>
    <link href="http://www.ayu.link/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.ayu.link/2021/10/04/JDBC%E4%BA%94%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-04T15:11:56.000Z</published>
    <updated>2022-04-07T13:39:17.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC原理图"><a href="#JDBC原理图" class="headerlink" title="JDBC原理图"></a>JDBC原理图</h2><p><img src="/img/2021-10-04/jdbc.png" alt="jdbc"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在项目目录下创建libs文件夹,将连接用的jar包导入</p><p><img src="/img/2021-10-04/10-4-1.png" alt="10-4-1"></p></li><li><p>把导入的jar包加入到项目中,右键点击jar包</p><p><img src="/img/2021-10-04/10-4-2.png" alt="10-4-2"></p></li></ol><h2 id="五种连接方式"><a href="#五种连接方式" class="headerlink" title="五种连接方式"></a>五种连接方式</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>该方式代码中显式出现了第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用反射实例化Driver,不在代码中体现第三方数据库的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用反射加载Driver类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码放到Properties对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">//用户</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">        Connection connect = driver.connect(url, properties);</span><br><span class="line">        System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用DriverManager代替Driver进行统一管理,实现数据库的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用DriverManager替代Driver进行统一管理</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><p>不必显式的注册驱动了,因为在DriverManager的源码中已经存在静态代码块,实现了驱动的注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//使用Class.forName自动完成注册驱动</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/ayu_db2?useSSL=false&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方式五-推荐"><a href="#方式五-推荐" class="headerlink" title="方式五(推荐)"></a>方式五(推荐)</h3><p>使用配置文件的方式保存配置信息,在代码中加载配置文件<br>使用配置文件的好处:</p><ol><li>实现了代码和数据的分离,如果需要修改配置信息,直接在配置文件中修改,不需要深入代码</li><li>如果修改了配置信息,省去重新编译的过程</li></ol><p>使用方法:</p><p>​    在src目录下创建jdbc.properties文件,添加以下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四个基本要素(记得修改成自己的配置信息)</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/ayu_db2</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关值</span></span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDBC原理图&quot;&gt;&lt;a href=&quot;#JDBC原理图&quot; class=&quot;headerlink&quot; title=&quot;JDBC原理图&quot;&gt;&lt;/a&gt;JDBC原理图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/2021-10-04/jdbc.png&quot; alt=&quot;jdbc&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://www.ayu.link/tags/Java/"/>
    
    <category term="JDBC" scheme="http://www.ayu.link/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建博客并部署到云服务器</title>
    <link href="http://www.ayu.link/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.ayu.link/2021/10/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-10-01T09:44:31.000Z</published>
    <updated>2021-12-07T08:01:54.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做基本不会出错,话不多说,下面开始</p><h2 id="本地部署Hexo"><a href="#本地部署Hexo" class="headerlink" title="本地部署Hexo"></a>本地部署Hexo</h2><h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h3><p>nodejs: <a href="https://nodejs.org/zh-cn/">下载</a></p><p>git: <a href="https://git-scm.com/downloads">下载</a></p><h3 id="二-安装本地hexo环境"><a href="#二-安装本地hexo环境" class="headerlink" title="二.安装本地hexo环境"></a>二.安装本地hexo环境</h3><p>nodejs和git的安装只需要无脑下一步即可,安装完成后可以在dos窗口进行检验,输入命令<code>node -v</code>和<code>npm -v</code>查看版本信息</p><p><img src="/img/2021-10-01/10-1-1.png" alt="10-1-1"></p><h3 id="三-安装hexo框架"><a href="#三-安装hexo框架" class="headerlink" title="三.安装hexo框架"></a>三.安装hexo框架</h3><p>在非系统盘下新建一个blog文件夹,进入文件夹后右键Git Bash Here</p><p>输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//第一条   这是安装hexo的基础框架</span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">//第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">//第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">//第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">//第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>安装完成之后可以去浏览器输入localhost:4000进行查看,效果如下:</p><p><img src="/img/2021-10-01/10-1-2.png" alt="img/2021-10-01"></p><h2 id="将Hexo博客部署到服务器上"><a href="#将Hexo博客部署到服务器上" class="headerlink" title="将Hexo博客部署到服务器上"></a>将Hexo博客部署到服务器上</h2><h3 id="一-服务器和域名的购买"><a href="#一-服务器和域名的购买" class="headerlink" title="一.服务器和域名的购买"></a>一.服务器和域名的购买</h3><ul><li>云服务器可以选择阿里云,腾讯云,华为云,这里演示使用的是阿里云的学生机</li><li>域名建议服务器在哪个平台就在哪个平台购买,域名买完一定要第一时间备案,国内的服务器是必须要备案的,如果是香港和外国的服务器则可以不用备案</li></ul><h3 id="二-云服务器操作-阿里云为例"><a href="#二-云服务器操作-阿里云为例" class="headerlink" title="二.云服务器操作(阿里云为例)"></a>二.云服务器操作(阿里云为例)</h3><h4 id="配置安全组规则"><a href="#配置安全组规则" class="headerlink" title="配置安全组规则"></a>配置安全组规则</h4><p>阿里云默认是不授权80端口访问的,这个端口,这个端口跑的是网页服务器的访问,所以要先把它开启,否则后面配置好后也无法访问</p><p>登录控制台-&gt;云服务器ECS-&gt;安全组-&gt;安全组ID-&gt;手动添加</p><p><img src="/img/2021-10-01/10-1-3.png" alt="10-1-3"></p><h4 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h4><h5 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h5><p>远程链接云服务器后,我们需要安装搭载网站的服务器nginx,安装命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx 安装nginx</span><br><span class="line"></span><br><span class="line">systemctl start nginx 开启nginx服务</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx 跟随系统启动</span><br></pre></td></tr></table></figure><p>安装完成之后,使用公网ip访问,如果显示的是nginx或者是centos的欢迎界面的话就代表安装成功</p><h5 id="创建博客目录"><a href="#创建博客目录" class="headerlink" title="创建博客目录"></a>创建博客目录</h5><p><code>cd /home</code></p><p><code>mkdir www</code></p><p><code>cd www</code></p><p><code>mkdir website</code></p><p>我么们在本地上传的blog文件都会存放在这个文件夹中</p><p>回到home目录修改权限</p><p><code>cd /home</code></p><p><code>chmod -R 777 ./www</code></p><p><code>chmod -R 777 ./www/website</code></p><h5 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h5><p>这里先写好配置文件,然后使用include的方式,引入到nginx的配置文件中</p><p>在/etc/nginx/的目录下创建vhost文件夹,在vhost文件夹下编写配置文件</p><p><code>cd /etc/nginx/</code></p><p><code>mkdir vhost</code></p><p><code>cd vhost</code></p><p><code>vim blog.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen    80;</span><br><span class="line">root /home/www/website;</span><br><span class="line">server_name ;这里填你的域名</span><br><span class="line">location /&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps:注释文字要删掉</span><br></pre></td></tr></table></figure><p>然后把这个文件引入到nginx的配置文件中,并修改server中的一些值</p><p><code>vim /etc/nginx/nginx.conf</code></p><p><img src="/img/2021-10-01/10-1-4.png" alt="10-1-4"></p><p><img src="/img/2021-10-01/10-1-5.png" alt="10-1-5"></p><h3 id="三-安装Git和node-js"><a href="#三-安装Git和node-js" class="headerlink" title="三.安装Git和node.js"></a>三.安装Git和node.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//安装Git</span><br><span class="line">yum install git</span><br><span class="line"></span><br><span class="line">// 安装Node</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><p>新建一个git用户并修改权限</p><p><code>adduser git</code></p><p><code>chmod 740 /etc/sudoers</code></p><p><code>vim /etc/sudoers</code></p><p>修改配置文件,如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line"></span><br><span class="line">添加以下内容</span><br><span class="line"></span><br><span class="line">git ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>再将权限修改过来</p><p><code>chmod 400 /etc/sudoers</code></p><h4 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h4><p>在本机桌面,右键GIt Bash Here打开终端,执行如下命令(三次回车)</p><p><code>ssh-keygen -t rsa</code></p><p>在C:\Users\用户名.ssh中找到id_rsa.pub</p><p>回到服务器端执行如下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git  //设置git密码</span><br><span class="line">su git//切换到git用户</span><br><span class="line"><span class="built_in">cd</span> ~//切换目录</span><br><span class="line">mkdir .ssh//新建.ssh文件夹</span><br><span class="line"><span class="built_in">cd</span> .ssh//进入文件夹</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys</span></span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>在本地Git终端测试连接云服务器</p><p><code>ssh -v git@你的公网IP</code></p><p>如果不需要输入密码就可以连接说明配置成功了,如果配置失败也不是什么大问题,只不过以后每次git需要输入密码</p><h3 id="四-创建git仓库"><a href="#四-创建git仓库" class="headerlink" title="四.创建git仓库"></a>四.创建git仓库</h3><p>在服务器端 创建git仓库</p><p><code>cd ~</code></p><p><code>git init --bare blog.git</code></p><p><code>vi ~/blog.git/hooks/post-receive</code></p><p>添加下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>修改权限</p><p><code>chmod +x ~/blog.git/hooks/post-receive</code></p><h3 id="五-完成部署"><a href="#五-完成部署" class="headerlink" title="五.完成部署"></a>五.完成部署</h3><p>修改hexo的配置文件,就是blog文件夹下的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@你的服务器公网IP:/home/git/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> </span><br></pre></td></tr></table></figure><p>之后在git终端执行</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>最后重新运行nginx服务器即可(ps:每次hexo d后都要重启nginx服务器)</p><p><code>nginx -s reload</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基于hexo搭建个人blog的文章网上有很多,但是其中一些多多少少有点问题,通过搭建本站进行了无数的踩坑,总结出了这篇搭建教程,一步步跟着做</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://www.ayu.link/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.ayu.link/2021/09/04/hello-world/"/>
    <id>http://www.ayu.link/2021/09/04/hello-world/</id>
    <published>2021-09-04T09:07:46.000Z</published>
    <updated>2021-12-07T07:54:34.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的小破站"><a href="#欢迎来到我的小破站" class="headerlink" title="欢迎来到我的小破站"></a>欢迎来到我的小破站</h2><p>​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过wordpress，halo这些框架，和这些比起来hexo的配置好像更加麻烦，但也更加灵活，而且作为一款静态博客框架，安全性也是更高．</p><h2 id="这个站会发布什么内容"><a href="#这个站会发布什么内容" class="headerlink" title="这个站会发布什么内容"></a>这个站会发布什么内容</h2><p>​        主要是记录我个人的成长，分享一下code方面的经验，或者是一些趣事，anyway，关注一下总是不亏的．</p><h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a>自言自语</h2><p>​        搭建一个属于自己的网站一直是我的一个小心愿，这里可以是我的日记本，也可以是我的树洞，更可以是分享自己的一个平台，在各种短视频文化冲击的现代，如此浮躁的网络，能有一片属于自己的净土还是蛮不错的．</p><p>​        I’m OK！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;欢迎来到我的小破站&quot;&gt;&lt;a href=&quot;#欢迎来到我的小破站&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的小破站&quot;&gt;&lt;/a&gt;欢迎来到我的小破站&lt;/h2&gt;&lt;p&gt;​        本站是基于hexo框架搭建的静态博客，在使用这款框架之前，我也用过</summary>
      
    
    
    
    
    <category term="日志" scheme="http://www.ayu.link/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
