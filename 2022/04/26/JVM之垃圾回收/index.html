<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM之垃圾回收 | aYuのblog</title><meta name="keywords" content="Java,JVM"><meta name="author" content="aYu"><meta name="copyright" content="aYu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 如何判断对象可以回收引用计数法当一个对象被引用时, 该对象的引用值就加1, 当这个对象不再被引用时, 引用值就减1, 当引用值为0时, 就表示该对象可以被垃圾回收器回收。引用计数法有一个弊端, 那就是当两个对象相互引用的时, 两个对象的引用值都为1, 此时这两个对象就算用不到了, 也不会被回收。  可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象  扫描堆中的">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM之垃圾回收">
<meta property="og:url" content="http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="aYuのblog">
<meta property="og:description" content="1. 如何判断对象可以回收引用计数法当一个对象被引用时, 该对象的引用值就加1, 当这个对象不再被引用时, 引用值就减1, 当引用值为0时, 就表示该对象可以被垃圾回收器回收。引用计数法有一个弊端, 那就是当两个对象相互引用的时, 两个对象的引用值都为1, 此时这两个对象就算用不到了, 也不会被回收。  可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象  扫描堆中的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.ayu.link/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/wallhaven-v9rr2p.jpg">
<meta property="article:published_time" content="2022-04-26T13:34:00.000Z">
<meta property="article:modified_time" content="2022-04-26T13:57:15.176Z">
<meta property="article:author" content="aYu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.ayu.link/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/wallhaven-v9rr2p.jpg"><link rel="shortcut icon" href="/img/head.png"><link rel="canonical" href="http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM之垃圾回收',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-26 21:57:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom@1.0.0.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/color.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="aYuのblog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/wallhaven-v9rr2p.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">aYuのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM之垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-26T13:34:00.000Z" title="发表于 2022-04-26 21:34:00">2022-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-26T13:57:15.176Z" title="更新于 2022-04-26 21:57:15">2022-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM之垃圾回收"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>当一个对象被引用时, 该对象的引用值就加1, 当这个对象不再被引用时, 引用值就减1, 当引用值为0时, 就表示该对象可以被垃圾回收器回收。引用计数法有一个弊端, 那就是当两个对象相互引用的时, 两个对象的引用值都为1, 此时这两个对象就算用不到了, 也不会被回收。</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用"></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 </li>
<li>扫描堆中的对象, 看是否能够沿着 GC Root对象 为起点的引用链找到该对象, 找不到, 表示可以回收 </li>
<li>哪些对象可以作为 GC Root <ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI (即一般说的Native方法)引用的对象</li>
</ul>
</li>
</ul>
<p>我们使用Eclipse Memory Analyzer(内存分析工具)对一下代码进行分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    list = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用jps命令找到程序进程</p>
<blockquote>
<p>PS D:\JVM\JVM_Study&gt; jps<br>14304 Jps<br>11060 Demo1<br>19532<br>26108 Launcher</p>
</blockquote>
</li>
<li><p>使用jmap命令生成内存快照</p>
<blockquote>
<p>PS D:\JVM\JVM_Study&gt; jmap -dump:format=b,live,file=1.bin 11060<br>Dumping heap to D:\JVM\JVM_Study\1.bin …<br>Heap dump file created</p>
</blockquote>
<p> 命令解释:</p>
<ul>
<li>dump: 转储文件</li>
<li>format=b: 使用二进制文件存储</li>
<li>live: 只抓取存活的对象, 并且抓取快照之前会进行垃圾回收</li>
<li>file=1.bin: 文件名</li>
<li>11060: 进程的id</li>
</ul>
</li>
<li><p>使用mat打开生成的快照, 选择GC Roots分析</p>
<p> <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/GC_Root.png" alt="GC_Root"></p>
</li>
</ol>
<p><code>list=null</code>前:</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%89%8D.png" alt="null前"></p>
<p><code>list=null</code>后:</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/null%E5%90%8E.png" alt="null后"></p>
<p>可以看到, 在第一个快照中找到了ArrayList对象, 并且里面存储的对象也能找到, 第二个快照(也就是<code>list=null</code>后), ArrayList对象找不到了, 说明被回收了。</p>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="引用类型"></p>
<ol>
<li>强引用 <ul>
<li>只有所有<strong>GC Roots</strong>对象都不通过【强引用】引用该对象, 该对象才能被垃圾回收 </li>
</ul>
</li>
<li>软引用(SoftReference)<ul>
<li>仅有软引用引用该对象时, 在垃圾回收后, 内存仍不足时会再次出发垃圾回收, 回收软引用对象 </li>
<li>可以配合引用队列来释放软引用自身 </li>
</ul>
</li>
<li>弱引用(WeakReference)<ul>
<li>仅有弱引用引用该对象时, 在垃圾回收时, 无论内存是否充足, 都会回收弱引用对象 </li>
<li>可以配合引用队列来释放弱引用自身 </li>
</ul>
</li>
<li>虚引用(PhantomReference)<ul>
<li>必须配合引用队列使用, 主要配合<strong>ByteBuffer</strong>使用, 被引用对象回收时, 会将虚引用入队</li>
<li>由<strong>Reference Handler</strong>线程调用虚引用相关方法(如unsafe.freememory)释放直接内存 </li>
</ul>
</li>
<li>终结器引用(FinalReference)<ul>
<li>无需手动编码, 但其内部配合引用队列使用, 在垃圾回收时, 终结器引用入队(被引用对象暂时没有被回收)</li>
<li>再由<strong>Finalizer</strong>线程通过终结器引用找到被引用对象并调用它的<strong>finalize</strong>方法, 第二次 GC 时才能回收被引用对象</li>
</ul>
</li>
</ol>
<p>软引用演示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示软引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束: &quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强引用会直接因为内存不足报错:</p>
<blockquote>
<p>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p>
</blockquote>
<p>软引用分析:</p>
<blockquote>
<p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3</p>
<p>在第四次循环之前内存已经吃紧了, 所以触发了一次垃圾回收, 这是一次minor gc<br>[GC (Allocation Failure) [PSYoungGen: 1900K-&gt;488K(6144K)] 14188K-&gt;12996K(19968K), 0.0010493 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@1540e19d<br>4</p>
<p>第五次循环之前内存已经彻底不够用的, 而且此时一个minor gc也释放不了多少内存, 所以触发了一次full fc<br>[GC (Allocation Failure) –[PSYoungGen: 4696K-&gt;4696K(6144K)] 17204K-&gt;17220K(19968K), 0.0005897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4529K(6144K)] [ParOldGen: 12524K-&gt;12477K(13824K)] 17220K-&gt;17006K(19968K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0039704 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[GC (Allocation Failure) –[PSYoungGen: 4529K-&gt;4529K(6144K)] 17006K-&gt;17038K(19968K), 0.0006478 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (Allocation Failure) [PSYoungGen: 4529K-&gt;0K(6144K)] [ParOldGen: 12509K-&gt;604K(8704K)] 17038K-&gt;604K(14848K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0052899 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[B@677327b6<br>5</p>
<p>可以看到这次full gc将前面的软引用的几个byte数组全部回收, 只留下最后一个byte数组<br>循环结束: 5<br>null<br>null<br>null<br>null<br>[B@677327b6<br>Heap<br>PSYoungGen      total 6144K, used 4263K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda9f70,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 8704K, used 604K [0x00000000fec00000, 0x00000000ff480000, 0x00000000ff980000)<br>object space 8704K, 6% used [0x00000000fec00000,0x00000000fec971a8,0x00000000ff480000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>上面的代码可以看到, 虽然软引用的对象已经被回收了, 但是软引用本身还没有被回收, 虽然软引用只占用很少的内存, 但是也不能留下它, 可以使用引用队列来清理软引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示软引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ArrayList&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列, 当软引用所关联的 byte[] 被回收时, 软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象, 并移除</span></span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[B@1b6d3586<br>1<br>[B@4554617c<br>2<br>[B@74a14482<br>3<br>[B@1540e19d<br>4<br>[B@677327b6</p>
<p>5</p>
<p>[B@677327b6</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>可以看到, 软引用本身也被回收了</p>
<p>弱引用示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method1();</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示弱引用搭配引用队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">        list.add(weakReference);</span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">            System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; wake : list) &#123;</span><br><span class="line">        System.out.print(wake.get() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;488K(6144K)] 5632K-&gt;4760K(19968K), 0.0041741 secs] [Times: user=0.00 sys=0.03, real=0.02 secs]<br>[B@1b6d3586,<br>[B@1b6d3586,[B@4554617c,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,<br>[B@1b6d3586,[B@4554617c,[B@74a14482,[B@1540e19d,</p>
<p>第五次循环前, 触发full gc, 回收弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4951K-&gt;0K(6144K)] [ParOldGen: 12464K-&gt;595K(13824K)] 17415K-&gt;595K(19968K), [Metaspace: 3207K-&gt;3207K(1056768K)], 0.0052947 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,[B@677327b6,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,<br>null,null,null,null,[B@677327b6,[B@14ae5a5,[B@7f31245a,[B@6d6f6e28,</p>
<p>第九次循环前, 内存再次不够触发full gc, 最后只剩下一个弱引用对象<br>[Full GC (Ergonomics) [PSYoungGen: 4207K-&gt;0K(6144K)] [ParOldGen: 12911K-&gt;619K(13824K)] 17118K-&gt;619K(19968K), [Metaspace: 3224K-&gt;3224K(1056768K)], 0.0061594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>null,null,null,null,null,null,null,null,[B@135fbaa4,</p>
<p>===========================================<br>[B@135fbaa4,Heap<br>PSYoungGen      total 6144K, used 4247K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffda5c78,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 13824K, used 619K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)<br>object space 13824K, 4% used [0x00000000fec00000,0x00000000fec9ae68,0x00000000ff980000)<br>Metaspace       used 3231K, capacity 4500K, committed 4864K, reserved 1056768K<br>class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</p>
<p>Process finished with exit code 0</p>
</blockquote>
<h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法(Mark Sweep):</p>
<ul>
<li>速度较快</li>
<li>会产生内存碎片</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法(Mark Compact)</p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制(Copy)</p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用两倍内存空间</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p>
<h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><ul>
<li>新创建的对象首先分配在<strong>eden</strong>区</li>
<li>新生代空间不足时, 触发<strong>minor gc</strong>, <strong>eden</strong>区和<strong>from</strong>区存活的对象使用 copy 复制到 to 中, 存活的对象年龄加一, 然后交换 from 和 to</li>
<li><strong>minor gc</strong> 会引发 <strong>stop the world</strong>(咋瓦鲁多), 暂停其他线程, 等垃圾回收结束后, 恢复用户线程运行</li>
<li>当幸存区对象的寿命超过阈值时, 会晋升到老年代, 默认最大的寿命是15(4bit)</li>
<li>当老年代空间不足时, 会先触发<strong>minor gc</strong>, 如果空间仍然不足, 那么就触发<strong>full gc</strong> , STW的时间更长</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="分代垃圾回收"></p>
<h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>Full GC前Minor GC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>相关概念:</p>
<ul>
<li>并行收集: 指多条垃圾收集线程并行工作, 但此时用户线程仍处于等待状态</li>
<li>并发收集: 指用户线程与垃圾收集线程同时工作(不一定是并行的可能会交替执行), 用户程序在继续运行, 而垃圾收集程序运行在另一个CPU上</li>
<li>吞吐量: 即CPU用于运行用户代码的时间与CPU总消耗时间的比值(吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )), 例如, 虚拟机共运行 100 分钟, 垃圾收集器花掉 1 分钟, 那么吞吐量就是 99% </li>
</ul>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li>单线程</li>
<li>堆内存较少, 适合个人电脑</li>
</ul>
<p><code>-XX:+UseSerialGC = Serial + SerialOld</code></p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%B2%E8%A1%8C.png" alt="串行"></p>
<p><strong>安全点</strong>: 让其他线程都在这个点停下来, 以免垃圾回收时移动对象地址, 使得其他线程找不到被移动的对象<br>因为是串行的, 所以只有一个垃圾回收线程。且在该线程执行回收工作时, 其他线程进入阻塞状态。</p>
<p><strong>Serial 收集器</strong><br>Serial 收集器是最基本的、发展历史最悠久的收集器<br><strong>特点</strong>: 单线程、简单高效(与其他收集器的单线程相比), 采用复制算法。对于限定单个 CPU 的环境来说, Serial 收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时, 必须暂停其他所有的工作线程, 直到它结束(Stop The World)</p>
<p><strong>ParNew 收集器</strong><br>ParNew 收集器其实就是 Serial 收集器的多线程版本<br><strong>特点</strong>: 多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同, 在 CPU 非常多的环境中, 可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p>
<p><strong>Serial Old 收集器</strong><br>Serial Old 是 Serial 收集器的老年代版本<br><strong>特点</strong>: 同样是单线程收集器, 采用标记-整理算法</p>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul>
<li>多线程</li>
<li>堆内存较大, 多核CPU</li>
<li>让单位时间内, STW 的时间最短</li>
</ul>
<p><code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></p>
<p><code>-XX:+UseAdaptiveSizePolicy</code></p>
<p><code>-XX:GCTimeRatio=ratio</code></p>
<p><code>-XX:MaxGCPauseMillis=ms</code></p>
<p><code>-XX:ParallelGCThreads=n</code></p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png" alt="吞吐量优先"></p>
<p><strong>Parallel Scavenge 收集器</strong><br>与吞吐量关系密切, 故也称为吞吐量优先收集器<br><strong>特点</strong>: 属于新生代收集器也是采用复制算法的收集器(用到了新生代的幸存区), 又是并行的多线程收集器(与 ParNew 收集器类似)<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是: GC自适应调节策略(与 ParNew 收集器最重要的一个区别)</p>
<p>**GC自适应调节策略: **<br>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。<br>当开关打开时不需要手动指定新生代的大小(-Xmn)、Eden 与 Survivor 区的比例(-XX:SurvivorRation)、晋升老年代的对象年龄(-XX:PretenureSizeThreshold)等, 虚拟机会根据系统的运行状况收集性能监控信息, 动态设置这些参数以提供最优的停顿时间和最高的吞吐量, 这种调节方式称为 GC 的自适应调节策略。</p>
<p>Parallel Scavenge 收集器使用两个参数控制吞吐量: </p>
<ul>
<li><p>XX:MaxGCPauseMillis=ms 控制最大的垃圾收集停顿时间(默认200ms)</p>
</li>
<li><p>XX:GCTimeRatio=rario 直接设置吞吐量的大小(默认值为99, 但是不容易达到, 一般设置为19)</p>
</li>
</ul>
<p><strong>Parallel Old 收集器</strong><br>是 Parallel Scavenge 收集器的老年代版本<br><strong>特点</strong>: 多线程, 采用标记-整理算法(老年代没有幸存区)</p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>堆内存较大, 多核CPU</li>
<li>尽可能让 STW 的单次时间最短</li>
</ul>
<p><code>-XX:+UseConcMarkSweepGC</code> ~ <code>-XX:+UseParNewGC</code> ~ <code>SerialOld</code><br><code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConcGCThreads=threads</code><br><code>-XX:CMSInitiatingOccupancyFraction=percent</code><br><code>-XX:+CMSScavengeBeforeRemark</code></p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="响应时间优先"></p>
<p><strong>CMS 收集器</strong><br>Concurrent Mark Sweep, 一种以获取最短回收停顿时间为目标的老年代收集器<br><strong>特点</strong>: 基于标记-清除算法实现。并发收集, 低停顿, 但是会产生内存碎片<br><strong>应用场景</strong>: 适用于注重服务的响应速度, 希望系统停顿时间最短, 给用户带来更好的体验等场景下。如 web 程序、b/s 服务<br><strong>CMS 收集器的运行过程分为下列4步</strong>:<br><strong>初始标记</strong>: 标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。<br><strong>并发标记</strong>: 进行 GC Roots Tracing 的过程, 找出存活对象且用户线程可并发执行。<br><strong>重新标记</strong>: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题<br><strong>并发清除</strong>: 对标记的对象进行清除回收, 清除的过程中, 可能任然会有新的垃圾产生, 这些垃圾就叫浮动垃圾, 如果当用户需要存入一个很大的对象时, 新生代放不下去, 老年代由于浮动垃圾过多, 就会退化为 serial Old 收集器, 将老年代垃圾进行标记-整理, 当然这也是很耗费时间的！</p>
<p>CMS 收集器的内存回收过程是与用户线程一起并发执行的, 可以搭配 ParNew 收集器(多线程, 新生代, 复制算法)与 Serial Old 收集器(单线程, 老年代, 标记-整理算法)使用。</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>定义</strong>:  Garbage First</p>
<p><strong>适用场景</strong>: </p>
<ul>
<li>同时注重吞吐量和低延迟(响应时间), 默认暂停目标是200ms</li>
<li>超大堆内存(内存大的), 会将堆内存划分为多个大小相等的区域</li>
<li>整体上是标记-整理算法, 两个区域之间是复制算法</li>
</ul>
<p><strong>相关参数</strong>:<br>JDK8 并不是默认开启的, 所需要参数开启<br><code>-XX:+UseG1GC</code><br><code>-XX:G1HeapRegionSize=size</code><br><code>-XX:MaxGCPauseMillis=time</code></p>
<h4 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h4><p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" alt="G1垃圾回收阶段"></p>
<p>Young Collection: 对新生代垃圾收集<br>Young Collection + Concurrent Mark: 如果老年代内存到达一定的阈值了, 新生代垃圾收集同时会执行一些并发的标记<br>Mixed Collection: 会对新生代 + 老年代 + 幸存区等进行混合收集, 然后收集结束, 会重新进入新生代收集</p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p><strong>新生代存在 STW</strong>:<br>分代是按对象的生命周期划分, 分区则是将堆空间划分连续几个不同小区间, 每一个小区间独立回收, 可以控制一次回收多少个小区间, 方便控制 GC 产生的停顿时间！<br>E: 伊甸园, S: 幸存区, O: 老年代</p>
<p>![Young Collection](/img/垃圾回收/Young Collection.gif)</p>
<h4 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h4><ul>
<li><p>在 Young GC 时会进行 GC Root 的初始标记 </p>
</li>
<li><p>老年代占用堆空间比例达到阈值时, 进行并发标记(不会 STW), 由下面的 JVM 参数决定</p>
<p>  <code>-XX:InitiatingHeapOccupancyPercent=percent</code> (默认45%)</p>
</li>
</ul>
<p>![Young Collection + CM](/img/垃圾回收/Young Collection + CM.png)</p>
<h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><p>会对 E、S、O 进行全面垃圾回收</p>
<ul>
<li>最终标记(Remark), 会 STW </li>
<li>拷贝存活(Evacuation), 会 STW</li>
</ul>
<p> <code>-XX:MaxGCPauseMillis=ms</code> 用于指定最长的停顿时间</p>
<blockquote>
<p>为什么有的老年代被拷贝了, 有的没拷贝？<br>因为指定了最大停顿时间, 如果对所有老年代都进行回收, 耗时可能过高, 为了保证时间不超过设定的停顿时间, 会回收最有价值的老年代(回收后, 能够得到更多内存)</p>
</blockquote>
<p>![Mixed Collection](/img/垃圾回收/Mixed Collection.png)</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ul>
<li><strong>SerialGC</strong> <ul>
<li>新生代内存不足发生的垃圾收集 - minor gc </li>
<li>老年代内存不足发生的垃圾收集 - full gc </li>
</ul>
</li>
<li><strong>ParallelGC</strong> <ul>
<li>新生代内存不足发生的垃圾收集 - minor gc </li>
<li>老年代内存不足发生的垃圾收集 - full gc </li>
</ul>
</li>
<li><strong>CMS</strong><ul>
<li>新生代内存不足发生的垃圾收集 - minor gc </li>
<li>老年代内存不足 </li>
</ul>
</li>
<li><strong>G1</strong><ul>
<li>新生代内存不足发生的垃圾收集 - minor gc </li>
<li>老年代内存不足</li>
<li>如果垃圾产生速度慢于垃圾回收速度, 不会触发 Full GC, 还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度, 便会触发 Full GC, 然后退化成 serial Old 收集器串行的收集, 就会导致停顿的时间较长</li>
</ul>
</li>
</ul>
<h4 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h4><ul>
<li><p>新生代回收的跨代引用(老年代引用新生代)问题</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" alt="跨代引用"></p>
</li>
<li><p>卡表 与 Remembered Set</p>
<ul>
<li><p>卡表: O 被划分为多个区域(一个区域512K)</p>
</li>
<li><p>脏卡: 如果卡表中有区域引用了新生代对象, 则该区域被称为脏卡</p>
</li>
<li><p>Remembered Set 存在于E中, 用于保存新生代对象对应的脏卡</p>
</li>
</ul>
</li>
<li><p>在引用变更时通过 post-write barried + dirty card queue</p>
</li>
<li><p>concurrent refinement threads 更新 Remembered Set</p>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E8%84%8F%E5%8D%A1.png" alt="脏卡"></p>
<h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h4><p>pre-write barrier + satb_mark_queue<br>重新标记阶段<br>在垃圾回收时, 收集器处理对象的过程中</p>
<ul>
<li>黑色: 已被处理, 需要保留的</li>
<li>灰色: 正在处理中的</li>
<li>白色: 还未处理的</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark.png" alt="Remark"></p>
<p>看一下案例:</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-1.png" alt="Remark-1"></p>
<ul>
<li><p>在处理B的过程中, B断开了对C的引用, 这样B会变成黑色, C最终会标记为白色</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-2.png" alt="Remark-2"></p>
</li>
<li><p>但是此时A又引用了C, 可是C已经被标记为白色, C最终会被回收</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-3.png" alt="Remark-3"></p>
</li>
<li><p>这样就有问题了, C还在被A引用, 不该被回收, 这时就要用到<strong>Remark</strong>, 在C的引用改变时, JVM会给加上一个pre-write barrier(写屏障)</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-4.png" alt="Remark-4"></p>
</li>
<li><p>当A引用C时, C的引用发生变化, 写屏障指令触发, 将C放入一个队列(satb_mark_queue)中, 并将C的状态修改为处理中状态</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-5.png" alt="Remark-5"></p>
</li>
<li><p>在并发标记阶段结束以后, 重新标记阶段会 STW , 然后将放在该队列中的对象重新处理, 发现有A强引用C, 就会处理它, 由灰色变成黑色</p>
<p>  <img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Remark-6.png" alt="Remark-6"></p>
</li>
</ul>
<h4 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h4><p><code>-XX:+UseStringDeduplication</code></p>
<ul>
<li>优点: 节省大量内存 </li>
<li>缺点: 略微多占用了 cpu 时间, 新生代回收时间略微增加</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>过程: </p>
<ul>
<li>将所有新分配的字符串(底层是 char[])放入一个队列</li>
<li>当新生代回收时, G1 并发检查是否有重复的字符串</li>
<li>如果字符串的值一样, 就让他们引用同一个char[]</li>
<li>注意, 其与 String.intern() 的区别<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>字符串去重关注的是 char[]</li>
<li>在 JVM 内部, 使用了不同的字符串标</li>
</ul>
</li>
</ul>
<h4 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后, 就能知道哪些类不再被使用, 当一个类加载器的所有类都不再使用, 则卸载它所加载的所有类<br><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认启用</p>
<h4 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h4><ul>
<li>一个对象大于 region 的一半时, 称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝 </li>
<li>回收时被优先考虑 </li>
<li>G1 会跟踪老年代所有 incoming 引用, 这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="回收巨型对象"></p>
<h4 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h4><ul>
<li>并发标记必须在堆空间占满前完成, 否则退化为 Full GC</li>
<li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code></li>
<li>JDK 9 可以动态调整<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空挡空间</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h3><p>查看虚拟机参数命令:</p>
<blockquote>
<p>java  -XX:+PrintFlagsFinal -version | findstr “GC”</p>
</blockquote>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
<li>gc</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><ul>
<li><strong>低延迟</strong>还是<strong>高吞吐量</strong>, 选择合适的回收器</li>
<li>CMS, G1, ZGC </li>
<li>ParallelGC</li>
<li>Zing(低延迟JVM, 宣称0停顿)</li>
</ul>
<h4 id="最快的-GC"><a href="#最快的-GC" class="headerlink" title="最快的 GC"></a>最快的 GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<p>查看 Full GC 前后的内存占用, 考虑以下几个问题</p>
<ul>
<li>数据是不是太多？<ul>
<li>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li>
</ul>
</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小 16 Integer 24 int 4</li>
</ul>
</li>
<li>是否存在内存泄漏<ul>
<li>static Map map …</li>
<li>软</li>
<li>弱</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><p>新生代的特点</p>
<ul>
<li>所有的 new 操作的内存分配非常廉价<ul>
<li>TLAB thread-local allocation buffer</li>
</ul>
</li>
<li>死亡对象的回收代价为零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远低于 Full GC</li>
</ul>
<p>新生代内存越大越好吗?</p>
<blockquote>
<p>-Xmn </p>
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p>
<p>设置新生代（托儿所）堆的初始大小和最大值（字节）。GC在该区域的执行频率高于其他区域。如果新生代的内存太小，则会执行大量Minor GC。如果内存太大，则只执行Full GC，这可能需要很长时间才能完成。Oracle建议将新生代的堆内存大小保持在总堆大小的25%以上，50%以下。</p>
</blockquote>
<ul>
<li><p>新生代能容纳所有【并发量 * (请求-响应)】的数据 </p>
</li>
<li><p>幸存区大到能保留【当前活跃对象+需要晋升对象】 </p>
</li>
<li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<p>  <code>-XX:MaxTenuringThreshold=threshold</code></p>
<p>  <code>-XX:+PrintTenuringDistribution</code></p>
  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, new threshold <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p>以CMS为例:</p>
<ul>
<li><p>CMS 的老年代内存越大越好</p>
</li>
<li><p>先尝试不做调优, 如果没有 Full GC, 那么已经OK了, 否则先尝试调优新生代</p>
</li>
<li><p>观察发生 Full GC 时老年代内存占用, 将老年代内存预设调大1/4 ~ 1/3</p>
<p>  <code>-XX:CMSInitiatingOccupancyFraction=percent</code></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">aYu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">http://www.ayu.link/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.ayu.link" target="_blank">aYuのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/wallhaven-v9rr2p.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/03/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/"><img class="prev-cover" src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM之字节码技术</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><img class="next-cover" src="/img/JVM/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM之内存结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/15/JVM之初识JVM/" title="JVM之初识JVM"><img class="cover" src="/img/JVM/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">JVM之初识JVM</div></div></a></div><div><a href="/2022/04/15/JVM之内存结构/" title="JVM之内存结构"><img class="cover" src="/img/JVM/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">JVM之内存结构</div></div></a></div><div><a href="/2022/06/08/JVM之类加载/" title="JVM之类加载"><img class="cover" src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/wallhaven-e7ek7k_QbVtA_z3Yp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-08</div><div class="title">JVM之类加载</div></div></a></div><div><a href="/2022/06/08/JVM之内存模型/" title="JVM之内存模型"><img class="cover" src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/wallhaven-e71o5r_AlbZWekQpw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-08</div><div class="title">JVM之内存模型</div></div></a></div><div><a href="/2022/05/03/JVM字节码技术/" title="JVM之字节码技术"><img class="cover" src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-03</div><div class="title">JVM之字节码技术</div></div></a></div><div><a href="/2022/04/06/JUC之Callable接口/" title="JUC之Callable接口"><img class="cover" src="/img/2022-04-06/wallhaven-72qqoo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-06</div><div class="title">JUC之Callable接口</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">aYu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">I'm OK!<div class="twopeople"><div class="twopeople"><div class="container"style="height:200px;"><canvas class="illo"width="800"height="800"style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="/js/twopeople1.js"></script><script src="/js/zdog.dist.js"></script><script id="rendered-js"src="/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">1. 如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">五种引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">复制算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">3. 分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3JVM%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">相关JVM参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">4. 垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">4.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">4.3.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">4.4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">4.4.1.</span> <span class="toc-text">垃圾回收阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection"><span class="toc-number">4.4.2.</span> <span class="toc-text">Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-number">4.4.3.</span> <span class="toc-text">Young Collection + CM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection"><span class="toc-number">4.4.4.</span> <span class="toc-text">Mixed Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC"><span class="toc-number">4.4.5.</span> <span class="toc-text">Full GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-number">4.4.6.</span> <span class="toc-text">Young Collection 跨代引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Remark"><span class="toc-number">4.4.7.</span> <span class="toc-text">Remark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">4.4.8.</span> <span class="toc-text">JDK 8u20 字符串去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u40-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">4.4.9.</span> <span class="toc-text">JDK 8u40 并发标记类卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8u60-%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.10.</span> <span class="toc-text">JDK 8u60 回收巨型对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-9-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">4.4.11.</span> <span class="toc-text">JDK 9 并发标记起始时间的调整</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">4.5.</span> <span class="toc-text">垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E9%A2%86%E5%9F%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">调优领域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">4.5.2.</span> <span class="toc-text">确定目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84-GC"><span class="toc-number">4.5.3.</span> <span class="toc-text">最快的 GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">4.5.4.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">4.5.5.</span> <span class="toc-text">老年代调优</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/08/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="JVM之内存模型"><img src="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/wallhaven-e71o5r_AlbZWekQpw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之内存模型"/></a><div class="content"><a class="title" href="/2022/06/08/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="JVM之内存模型">JVM之内存模型</a><time datetime="2022-06-08T06:29:40.000Z" title="发表于 2022-06-08 14:29:40">2022-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/08/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/" title="JVM之类加载"><img src="/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD/wallhaven-e7ek7k_QbVtA_z3Yp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之类加载"/></a><div class="content"><a class="title" href="/2022/06/08/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD/" title="JVM之类加载">JVM之类加载</a><time datetime="2022-06-08T06:29:25.000Z" title="发表于 2022-06-08 14:29:25">2022-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/03/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/" title="JVM之字节码技术"><img src="/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之字节码技术"/></a><div class="content"><a class="title" href="/2022/05/03/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/" title="JVM之字节码技术">JVM之字节码技术</a><time datetime="2022-05-03T13:35:21.000Z" title="发表于 2022-05-03 21:35:21">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM之垃圾回收"><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/wallhaven-v9rr2p.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之垃圾回收"/></a><div class="content"><a class="title" href="/2022/04/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM之垃圾回收">JVM之垃圾回收</a><time datetime="2022-04-26T13:34:00.000Z" title="发表于 2022-04-26 21:34:00">2022-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="JVM之内存结构"><img src="/img/JVM/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之内存结构"/></a><div class="content"><a class="title" href="/2022/04/15/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="JVM之内存结构">JVM之内存结构</a><time datetime="2022-04-15T11:49:14.000Z" title="发表于 2022-04-15 19:49:14">2022-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By aYu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-5ip6-k5d1623s2-1556872271-qqcom.vercel.app/',
      region: 'ap-xian'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-5ip6-k5d1623s2-1556872271-qqcom.vercel.app/',
      region: 'ap-xian',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = '/posts/,/about/'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>